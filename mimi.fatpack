#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/mimi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MIMI';
  package App::mimi;use strict;use warnings;our$VERSION='0.03';use Carp qw(croak);use Cwd qw(abs_path);use File::Spec;use File::Basename ();use DBI;use App::mimi::db;use App::mimi::migration;sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{dsn}=$params{dsn};$self->{schema}=$params{schema};$self->{initial_schema}=$params{initial_schema};$self->{initial_migration}=$params{initial_migration};$self->{dry_run}=$params{dry_run};$self->{verbose}=$params{verbose};$self->{migration}=$params{migration};$self->{setup}=$params{setup};$self->{dbh}=$params{dbh};return$self}sub setup {my$self=shift;my$db=$self->_build_db;if ($db->is_prepared){$self->_print("Notice: migrations table already exists");return}$self->_print("Creating migrations table");$db->prepare unless$self->_is_dry_run;if (my$initial_schema=$self->{initial_schema}){my$migration=App::mimi::migration->build('sql')->parse($initial_schema);my$initial_migration=$self->_detect_initial_migration($self->{initial_migration}|| 0);$self->_print("Initializing with '$initial_schema' ($initial_migration)");next if$self->_is_dry_run;my$dbh=$self->{dbh};my$result=$migration->execute($dbh);die "Error: $result->{error}\n" unless$result->{success}}elsif ($self->{initial_migration}){my$initial_migration=$self->_detect_initial_migration($self->{initial_migration}|| 0);$self->_print("Setting initial migration ($initial_migration)");$db->create_migration(no=>$initial_migration,created=>time,status=>'success')unless$self->_is_dry_run}return$self}sub migrate {my$self=shift;die "Error: Schema directory is required\n" unless$self->{schema}&& -d $self->{schema};if ($self->{setup}){$self->setup}my@schema_files=grep {!/^\./}glob("$self->{schema}/*");die "Error: No schema files found in '$self->{schema}'\n" unless@schema_files;my$db=$self->_build_db_prepared;my$last_migration=$db->fetch_last_migration;if ($last_migration && $last_migration->{status}ne 'success'){$last_migration->{error}||= 'Unknown error';die "Error: Migrations are dirty. " ."Last error was in migration $last_migration->{no}:\n\n" ."    $last_migration->{error}\n" ."After fixing the problem run <fix> command\n"}$self->_print("Found last migration $last_migration->{no}")if$last_migration;my@migrations;for my$file (@schema_files){my ($no,$name)=File::Basename::basename($file)=~ /^(\d+)(.*)$/;next unless$no && $name;my ($ext)=$name =~ m/\.([^\.]+)$/;next unless$ext;$no=int($no);next if$last_migration && $no <= $last_migration->{no};eval {my$migration=App::mimi::migration->build($ext)->parse(abs_path($file));push@migrations,{file=>$file,no=>$no,name=>$name,migration=>$migration };1}or do {my$e=$@;$self->_finalize($no,{success=>0,error=>$e})}}if (@migrations){for my$migration (@migrations){$self->_print("Migrating '$migration->{file}'");next if$self->_is_dry_run;my$result=$migration->{migration}->execute($self->{dbh});$self->_finalize($migration->{no},$result)}}else {$self->_print("Nothing to migrate")}return$self}sub check {my$self=shift;$self->{verbose}=1;my$db=$self->_build_db;if (!$db->is_prepared){$self->_print('Migrations are not installed')}else {my$last_migration=$db->fetch_last_migration;if (!defined$last_migration){$self->_print('No migrations found')}else {$self->_print(sprintf 'Last migration: %d (%s)',$last_migration->{no},$last_migration->{status});if (my$error=$last_migration->{error}){$self->_print("\n" .$error)}}}}sub fix {my$self=shift;my$db=$self->_build_db_prepared;my$last_migration=$db->fetch_last_migration;if (!$last_migration || $last_migration->{status}eq 'success'){$self->_print('Nothing to fix')}else {$self->_print("Fixing migration $last_migration->{no}");$db->fix_last_migration unless$self->_is_dry_run}}sub set {my$self=shift;my$db=$self->_build_db_prepared;$self->_print("Creating migration $self->{migration}");$db->create_migration(no=>$self->{migration},created=>time,status=>'success')unless$self->_is_dry_run}sub _detect_initial_migration {my$self=shift;my ($initial_migration)=@_;if ($initial_migration eq 'auto'){die "Error: --schema is required in auto mode\n" unless$self->{schema}&& -d $self->{schema};my@schema_files=map {File::Basename::basename($_)}glob("$self->{schema}/*.sql");@schema_files=grep {/^(\d+).*?\.sql$/}@schema_files;if (@schema_files){($initial_migration)=$schema_files[-1]=~ m/^(\d+)/}else {die "Error: Can't automatically detect last migration\n"}}die "Invalid migration '$initial_migration'\n" unless$initial_migration =~ m/^\d+$/;return$initial_migration}sub _finalize {my$self=shift;my ($no,$result)=@_;my$db=$self->_build_db;$self->_print("Finalizing migration: $no");$db->create_migration(no=>$no,created=>time,status=>$result->{success}? 'success' : 'error',error=>substr($result->{error}// '',0,255));die "Error: $result->{error}\n" unless$result->{success}}sub _build_db_prepared {my$self=shift;my$db=$self->_build_db;die "Error: Migrations table not found. Run <setup> command first or use --setup flag\n" unless$db->is_prepared;return$db}sub _build_db {my$self=shift;my$dbh=$self->{dbh};if (!$dbh){$dbh=DBI->connect($self->{dsn},'','',{RaiseError=>1,PrintError=>0,PrintWarn=>0});$self->{dbh}=$dbh}return App::mimi::db->new(dbh=>$dbh)}sub _print {my$self=shift;return unless$self->_is_verbose;print 'DRY RUN: ' if$self->_is_dry_run;print @_,"\n"}sub _is_dry_run {$_[0]->{dry_run}}sub _is_verbose {$_[0]->{verbose}|| $_[0]->_is_dry_run}1;
APP_MIMI

$fatpacked{"App/mimi/db.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MIMI_DB';
  package App::mimi::db;use strict;use warnings;use Carp qw(croak);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{dbh}=$params{dbh}or croak 'dbh required';$self->{columns}=[qw/no created status error/];return$self}sub is_prepared {my$self=shift;local$SIG{__WARN__}=sub {};my$rv;eval {$rv=$self->{dbh}->do('SELECT 1 FROM mimi LIMIT 1')};return unless$rv;return 1}sub prepare {my$self=shift;my$driver=$self->{dbh}->{Driver}->{Name};if ($driver eq 'SQLite'){$self->{dbh}->do(<<'EOF')}elsif ($driver eq 'Pg'){$self->{dbh}->do(<<'EOF')}}sub fix_last_migration {my$self=shift;my$last_migration=$self->fetch_last_migration;return unless$last_migration;$self->{dbh}->do("UPDATE mimi SET status = 'success', error = '' WHERE id=$last_migration->{id}")or die $!;return$self}sub create_migration {my$self=shift;my (%migration)=@_;$migration{created}||= time;my$columns=join ',',keys%migration;my$values=join ',',map {'?'}values%migration;my$sth=$self->{dbh}->prepare("INSERT INTO mimi ($columns) VALUES ($values)")or die $!;my$rv=$sth->execute(values%migration);die "Can't create migration\n" unless$rv;return$self}sub fetch_last_migration {my$self=shift;my$sth=$self->{dbh}->prepare('SELECT id, no, created, status, error FROM mimi ORDER BY id DESC LIMIT 1');my$rv=$sth->execute or die $!;my$row=$sth->fetchall_arrayref->[0];return unless$row;my$migration={};for (qw/id no created status error/){$migration->{$_}=shift @$row}return$migration}1;
      CREATE TABLE mimi (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          created INTEGER NOT NULL,
          no INTEGER NOT NULL,
          status VARCHAR(32) NOT NULL,
          error VARCHAR(255)
      );
  EOF
      CREATE TABLE mimi (
          id serial PRIMARY KEY,
          created INTEGER NOT NULL,
          no INTEGER NOT NULL,
          status VARCHAR(32) NOT NULL,
          error VARCHAR(255)
      );
  EOF
APP_MIMI_DB

$fatpacked{"App/mimi/migration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MIMI_MIGRATION';
  package App::mimi::migration;use strict;use warnings;use App::mimi::migration::sql;use App::mimi::migration::perl;sub build {my$class=shift;my ($type,@params)=@_;if ($type eq 'sql'){return App::mimi::migration::sql->new(@params)}elsif ($type eq 'pm'){return App::mimi::migration::perl->new(@params)}die "unknown type '$type'"}1;
APP_MIMI_MIGRATION

$fatpacked{"App/mimi/migration/perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MIMI_MIGRATION_PERL';
  package App::mimi::migration::perl;use strict;use warnings;use Carp qw(croak);sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub parse {my$self=shift;my ($file)=@_;my$code=$self->_slurp($file);my ($package)=$code =~ m/^package\s*(.*?);/ms;die "No package name found\n" unless$package;$self->{file}=$file;$self->{package}=$package;return$self}sub execute {my$self=shift;my ($dbh)=@_;my$e;eval {my$file=$self->{file};require$file;$self->{package}->migrate($dbh);1}or do {$e=$@};return {success=>defined($e)? 0 : 1,error=>$e }}sub _slurp {my$self=shift;my ($file)=@_;open my$fh,'<',$file or croak "Can't open file '$file': $!";<$fh>}1;
APP_MIMI_MIGRATION_PERL

$fatpacked{"App/mimi/migration/sql.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MIMI_MIGRATION_SQL';
  package App::mimi::migration::sql;use strict;use warnings;use Carp qw(croak);sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub sql {shift->{sql}}sub parse {my$self=shift;my ($file)=@_;my@lines=map {chomp;$_}$self->_slurp($file);my$multiline='';my@sql;my@parts;for my$line (@lines){next if$line =~ m/^(?:--|#)/;push@parts,$line;pos$parts[-1]=0;if ($multiline){if ($parts[-1]=~ m/\G.*?\Q$multiline\E/gc){$multiline=''}else {next}}if ($parts[-1]=~ m/\G.*?(\$.*?\$)/gc){$multiline=$1}if (!$multiline && $parts[-1]=~ s/;$//){push@sql,$self->_join(@parts);@parts=()}}push@sql,$self->_join(@parts)if@parts;@sql=grep {length}map {s/^\s+//;s/\s+$//;$_}@sql;$self->{sql}=\@sql;return$self}sub execute {my$self=shift;my ($dbh)=@_;my$e;my$last_query='';my$sqls=$self->{sql};eval {for my$sql (@{$sqls || []}){$last_query=$sql;$dbh->do($sql)}1}or do {$e=$@;$e =~ s{ at .*? line \d+.$}{}};return {success=>defined($e)? 0 : 1,error=>$e }}sub _join {my$self=shift;my (@parts)=@_;return join "\n",@parts}sub _slurp {my$self=shift;my ($file)=@_;open my$fh,'<',$file or croak "Can't open file '$file': $!";<$fh>}1;
APP_MIMI_MIGRATION_SQL

$fatpacked{"Class/Accessor/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_ACCESSOR_LITE';
  package Class::Accessor::Lite;use strict;our$VERSION='0.08';sub croak {require Carp;Carp::croak(@_)}sub import {shift;my%args=@_;my$pkg=caller(0);my%key_ctor=(rw=>\&_mk_accessors,ro=>\&_mk_ro_accessors,wo=>\&_mk_wo_accessors,);for my$key (sort keys%key_ctor){if (defined$args{$key}){croak("value of the '$key' parameter should be an arrayref")unless ref($args{$key})eq 'ARRAY';$key_ctor{$key}->($pkg,@{$args{$key}})}}_mk_new($pkg)if$args{new};1}sub mk_new_and_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_new($pkg);_mk_accessors($pkg,@properties)}sub mk_new {my$pkg=caller(0);_mk_new($pkg)}sub mk_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_accessors($pkg,@properties)}sub mk_ro_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_ro_accessors($pkg,@properties)}sub mk_wo_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_wo_accessors($pkg,@properties)}sub _mk_new {my$pkg=shift;no strict 'refs';*{$pkg .'::new'}=__m_new($pkg)}sub _mk_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m($n)}}sub _mk_ro_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m_ro($pkg,$n)}}sub _mk_wo_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m_wo($pkg,$n)}}sub __m_new {my$pkg=shift;no strict 'refs';return sub {my$klass=shift;bless {(@_==1 && ref($_[0])eq 'HASH' ? %{$_[0]}: @_),},$klass}}sub __m {my$n=shift;sub {return $_[0]->{$n}if @_==1;return $_[0]->{$n}=$_[1]if @_==2;shift->{$n}=\@_}}sub __m_ro {my ($pkg,$n)=@_;sub {if (@_==1){return $_[0]->{$n}if @_==1}else {my$caller=caller(0);croak("'$caller' cannot access the value of '$n' on objects of class '$pkg'")}}}sub __m_wo {my ($pkg,$n)=@_;sub {if (@_==1){my$caller=caller(0);croak("'$caller' cannot alter the value of '$n' on objects of class '$pkg'")}else {return $_[0]->{$n}=$_[1]if @_==2;shift->{$n}=\@_}}}1;
CLASS_ACCESSOR_LITE

$fatpacked{"Docopt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DOCOPT';
  use 5.008005;use strict;use warnings FATAL=>'all';package Docopt;use Docopt::Util qw(string_partition in serialize defined_or);package Docopt::Pattern;use Docopt::Util qw(defined_or);sub new {my$class=shift;bless [],$class}sub fix {my$self=shift;$self->fix_identities();$self->fix_repeating_arguments();return$self}use Docopt::Util qw(in serialize);sub fix_identities {my ($self,$uniq)=@_;if (!$self->can('children')){return$self}$uniq=defined_or($uniq,$self->flat);for (my$i=0;$i<@{$self->children};$i++){my$child=$self->children->[$i];if (not $child->can('children')){local$Storable::canonical=1;in(serialize($child),[map {serialize($_)}@$uniq])or die;($self->children->[$i],)=grep {serialize($_)eq serialize($child)}@$uniq}else {$child->fix_identities($uniq)}}}use Scalar::Util qw(refaddr);use Docopt::Util qw(repl serialize);sub fix_repeating_arguments {my$self=shift;my$list_count=sub {my ($list,$stuff)=@_;my$n=0;for (@$list){$n++ if serialize($stuff)eq serialize($_)}return$n};my@either=map {$_->children}@{Docopt::transform($self)->children};for my$case (@either){for my$e (grep {$list_count->($case,$_)> 1}@$case){if ($e->isa('Docopt::Argument')|| ($e->isa('Docopt::Option')&& $e->argcount)){if (not defined$e->value){$e->value([])}elsif (ref($e->value)ne 'ARRAY'){$e->value([split /\s+/,$e->value])}}if ($e->isa('Docopt::Command')|| ($e->isa('Docopt::Option')&& $e->argcount==0)){$e->value(0)}}}return$self}package Docopt;use parent qw(Exporter);our@EXPORT=qw(docopt);use List::MoreUtils qw(any);use Scalar::Util qw(blessed refaddr);use Docopt::Util qw(repl pyprint serialize);sub transform {my ($pattern)=@_;my@results;my@groups=[$pattern];while (@groups){my$children=shift@groups;my@parents=qw(Docopt::Required Docopt::Optional Docopt::OptionsShortcut Docopt::Either Docopt::OneOrMore);if (any {in($_,[map {blessed $_}@$children])}@parents){my$child=[grep {in(blessed $_,\@parents)}@$children]->[0];$children=[grep {refaddr($child)ne refaddr($_)}@$children ];if ($child->isa('Docopt::Either')){for (@{$child->children}){push@groups,[$_,@{$children}]}}elsif ($child->isa('Docopt::OneOrMore')){push@groups,[@{$child->children},@{Storable::dclone($child->children)},@$children]}else {push@groups,[@{$child->children},@$children]}}else {push@results,$children}}return Docopt::Either->new([map {Docopt::Required->new($_)}@results])}package Docopt::LeafPattern;use parent -norequire,qw(Docopt::Pattern);use Docopt::Util qw(repl class_name True False is_number);use Class::Accessor::Lite (rw=>[qw(name)],);sub value {my$self=shift;return$self->{value}if @_==0;if (@_==1){$self->{value}=$_[0]}else {Carp::confess("Too much arguments")}}sub new {my ($class,$name,$value)=@_;bless {name=>$name,value=>$value,},$class}sub __repl__ {my$self=shift;sprintf '%s(%s, %s)',class_name($self),repl($self->name),repl($self->value)}sub flat {my ($self,$types)=@_;if (!defined($types)|| $self->isa($types)){return [$self]}else {return []}}sub match {my$self=shift;my@left=@{+shift};my@collected=@{+shift || +[]};my ($pos,$match)=$self->single_match(\@left);unless ($match){return (False,\@left,\@collected)}my@left_=(@left[0..$pos-1],@left[$pos+1..@left-1]);my@same_name=grep {$_->name eq $self->name}@collected;if (is_number($self->value)|| ref($self->value)eq 'ARRAY'){my$increment;if (is_number($self->value)){$increment=1}else {$increment=ref($match->value)eq 'ARRAY' ? $match->value : [$match->value]}unless (@same_name){$match->value($increment);return (True,\@left_,[@collected,$match])}if (ref$same_name[0]->value eq 'ARRAY'){$same_name[0]->value([@{$same_name[0]->value},ref($increment)eq 'ARRAY' ? @$increment : $increment])}else {ref($increment)ne 'ARRAY' or Carp::confess("Invalid addition");$same_name[0]->value($same_name[0]->value + $increment)}return (True,\@left_,\@collected)}return (True,\@left_,[@collected,$match])}package Docopt::BranchPattern;use parent -norequire,qw(Docopt::Pattern);use Carp;use Docopt::Util qw(repl class_name);use Scalar::Util qw(blessed);sub new {my ($class,$children)=@_;Carp::croak("Too much arguments")unless @_==2;Carp::confess "Children must be arrayref: $class, $children" unless ref$children eq 'ARRAY';$children=[map {ref($_)eq 'ARRAY' ? @$_ : $_}@$children];bless {children=>[@$children],},$class}sub children {my$self=shift;return$self->{children}if @_==0;if (@_==1){ref($_[0])eq 'ARRAY' or Carp::confess("Argument must be ArrayRef but: " .$_[0]);$self->{children}=$_[0]}else {Carp::confess("Too much arguments")}}sub __repl__ {my$self=shift;sprintf '%s(%s)',class_name($self),join(', ',map {repl($_)}@{$self->{children}})}sub flat {my$self=shift;my$types=shift;if (defined($types)&& $self->isa($types)){return [$self]}my@ret=map {ref($_)eq 'ARRAY' ? @$_ : $_}map {$_->flat($types)}@{$self->children};return \@ret}package Docopt::Argument;use parent -norequire,qw(Docopt::LeafPattern);sub single_match {my ($self,$left)=@_;ref$left eq 'ARRAY' or die;for (my$n=0;$n<@$left;$n++){my$pattern=$left->[$n];if ($pattern->isa(Docopt::Argument::)){return ($n,Docopt::Argument->new($self->name,$pattern->value))}}return (undef,undef)}sub parse {my ($class,$source)=@_;$source =~ /(<\S*?>)/;my$name=$1;$source =~ /\[default: (.*)\]/i;my$value=$1;return$class->new($name,$value)}package Docopt::Command;use parent -norequire,qw(Docopt::Argument);use Class::Accessor::Lite (rw=>[qw(name value)]);use boolean;sub new {my ($class,$name,$value)=@_;bless {name=>$name,value=>$value,},$class}sub single_match {my ($self,$left)=@_;ref$left eq 'ARRAY' or die;for (my$n=0;$n<@$left;$n++){my$pattern=$left->[$n];if ($pattern->isa(Docopt::Argument::)){if ($pattern->value eq $self->name){return ($n,Docopt::Command->new($self->name,true))}else {last}}}return (undef,undef)}package Docopt::Required;use parent -norequire,qw(Docopt::BranchPattern);use boolean;sub match {my ($self,$left,$collected)=@_;$collected ||= [];my$l=$left;my$c=$collected;for my$pattern (@{$self->children}){my$matched;($matched,$l,$c)=$pattern->match($l,$c);unless ($matched){ref($c)eq 'ARRAY' or Carp::confess("c is not arrayref");return (false,$left,$collected)}}ref($c)eq 'ARRAY' or Carp::confess("c is not arrayref: " .join(', ',@{$self->children}));return (true,$l,$c)}package Docopt::Optional;use parent -norequire,qw(Docopt::BranchPattern);use boolean;sub match {my ($self,$left,$collected)=@_;$collected ||= [];ref($collected)eq 'ARRAY' or Carp::confess("collected is not arrayref: " .join(', ',@{$self->children}));my$m;for my$pattern (@{$self->children}){($m,$left,$collected)=$pattern->match($left,$collected)}ref($collected)eq 'ARRAY' or Carp::confess("collected is not arrayref: " .join(', ',@{$self->children}));return (true,$left,$collected)}package Docopt::OptionsShortcut;use parent -norequire,qw(Docopt::Optional);package Docopt::OneOrMore;use parent -norequire,qw(Docopt::BranchPattern);use boolean;use Storable;use Docopt::Util qw(serialize);sub match {my ($self,$left,$collected)=@_;@{$self->children}==1 or die;$collected ||= [];my$l=$left;my$c=$collected;my$l_=undef;my$matched=true;my$times=0;while ($matched){($matched,$l,$c)=$self->children->[0]->match($l,$c);$times++ if$matched;if (serialize(\$l_)eq serialize(\$l)){last}$l_=$l}if ($times >= 1){return (true,$l,$c)}return (false,$left,$collected)}package Docopt::Either;use parent -norequire,qw(Docopt::BranchPattern);use boolean;sub match {my ($self,$left,$collected)=@_;$collected ||= [];my@outcomes;for my$pattern (@{$self->children}){my@outcome=$pattern->match($left,$collected);my$matched=$outcome[0];if ($matched){push@outcomes,\@outcome}}if (@outcomes){my$retval=shift@outcomes;for (@outcomes){if (@{$_->[1]}< @{$retval->[1]}){$retval=$_}}return @$retval}return (false,$left,$collected)}package Docopt::Tokens;use Docopt::Util qw(repl);use Class::Accessor::Lite 0.05 (rw=>[qw(error source)],);sub new {my ($class,$source,$error)=@_;$error ||= 'Docopt::Exceptions::DocoptExit';unless (ref$source){$source=[split /\s+/,$source]}bless {source=>[@$source],error=>$error},$class}sub from_pattern {my ($class,$source)=@_;$source =~ s/([\[\]\(\)\|]|\.\.\.)/ $1 /g;my@source=grep {defined($_)&& length $_ > 0}split /\s+|(\S*<.*?>)/,$source;return Docopt::Tokens->new(\@source,'Docopt::Exceptions::DocoptLanguageError')}sub move {my$self=shift;shift @{$self->{source}}}sub current {my$self=shift;$self->source->[0]}sub __repl__ {my$self=shift;'[' .join(', ',map {repl($_)}@{$self->source}).']'}package Docopt;our$VERSION="0.03";package Docopt::Option;use parent -norequire,qw(Docopt::LeafPattern);use Docopt::Util qw(repl string_strip string_partition defined_or);use Class::Accessor::Lite 0.05 (rw=>[qw(short long argcount)],);sub new {my ($class,$short,$long,$argcount,$value)=@_;if (@_<= 3){$argcount=0}return bless {short=>$short,long=>$long,argcount=>$argcount,value=>!defined($value)&& $argcount ? undef : $value,},$class}sub value {my$self=shift;return$self->{value}if @_==0;if (@_==1){$self->{value}=$_[0]}else {Carp::confess("Too much arguments")}}sub single_match {my ($self,$left)=@_;ref$left eq 'ARRAY' or die;for (my$n=0;$n<@$left;$n++){my$pattern=$left->[$n];if ($self->name eq defined_or($pattern->name,'')){return ($n,$pattern)}}return (undef,undef)}sub name {my$self=shift;if (defined($self->long)&&!ref($self->long)){$self->long}else {$self->short}}sub parse {my ($class,$option_description)=@_;my ($short,$long,$argcount,$value)=(undef,undef,0,undef);my ($options,undef,$description)=string_partition(string_strip($option_description),'  ');$options =~ s/,/ /g;$options =~ s/=/ /g;for my$s (split /\s+/,$options){if ($s =~ /^--/){$long=$s}elsif ($s =~ /^-/){$short=$s}else {$argcount=1}}if ($argcount){if (defined($description)&& $description =~ /\[default: (.*)\]/i){$value=$1}}return$class->new($short,$long,$argcount,$value)}sub __repl__ {my ($self)=@_;sprintf 'Option(%s, %s, %s, %s)',repl($self->{short}),repl($self->{long}),repl($self->{argcount}),repl($self->{value})}package Docopt;use boolean;sub parse_long {my ($tokens,$options)=@_;ref($options)eq 'ARRAY' or Carp::confess "Options must be arrayref";my ($long,$eq,$value)=string_partition($tokens->move,'=');$long =~ /\A--/ or die;$value=$eq eq '' && $value eq '' ? undef : $value;my@similar=grep {$_->long && $_->long eq $long}@$options;if ($tokens->error eq 'Docopt::Exceptions::DocoptExit' && @similar==0){@similar=grep {$_->long && $_->long =~ /$long/}@$options}my$o;if (@similar > 1){$tokens->error->throw(sprintf '%s is not a unique prefix: %s?',$long,join(', ',map {$_->long}@similar))}elsif (@similar < 1){my$argcount=$eq eq '=' ? 1 : 0;$o=Docopt::Option->new(undef,$long,$argcount);push @$options,$o;if ($tokens->error eq 'Docopt::Exceptions::DocoptExit'){$o=Docopt::Option->new(undef,$long,$argcount,$argcount ? $value : true)}}else {$o=Docopt::Option->new($similar[0]->short,$similar[0]->long,$similar[0]->argcount,$similar[0]->value,);if ($o->argcount==0){if (defined$value){$tokens->error->throw(sprintf "%s must not have an argument",$o->long)}}else {if (not defined$value){if ((not defined$tokens->current())|| $tokens->current eq '--'){$tokens->error->throw(sprintf "%s requires argument",$o->long)}$value=$tokens->move}}if ($tokens->error eq 'Docopt::Exceptions::DocoptExit'){$o->value(defined($value)? $value : true)}}return [$o]}sub parse_shorts {my ($tokens,$options)=@_;my$token=$tokens->move;(my$left=$token)=~ s/^-//;my@parsed;while ($left ne ''){my$o;$left =~ s/\A(.)//;my$short='-' .$1;my@similar=grep {defined_or($_->short,'')eq $short}@$options;if (@similar > 1){$tokens->error->throw(sprintf "%s is specified ambiguously %d times",$short,0+@similar)}elsif (@similar < 1){$o=Docopt::Option->new($short,undef,0);push @$options,$o;if ($tokens->error eq 'Docopt::Exceptions::DocoptExit'){$o=Docopt::Option->new($short,undef,0,undef)}}else {$o=Docopt::Option->new($short,$similar[0]->long,$similar[0]->argcount,$similar[0]->value);my$value=undef;if ($o->argcount!=0){if ($left eq ''){if (!defined($tokens->current)|| $tokens->current eq '--'){$tokens->error->throw("$short requires argument")}$value=$tokens->move}else {$value=$left;$left=''}}if ($tokens->error eq 'Docopt::Exceptions::DocoptExit'){$o->value(defined($value)? $value : true)}}push@parsed,$o}return \@parsed}use Docopt::Util qw(repl);sub parse_pattern {my ($source,$options)=@_;my$tokens=Docopt::Tokens->from_pattern($source);my$result=parse_expr($tokens,$options);if (defined$tokens->current()){$tokens->error->throw("unexpected ending: " .repl(join(' ',$tokens)))}return Docopt::Required->new($result)}sub parse_expr {my ($tokens,$options)=@_;my$seq=parse_seq($tokens,$options);if (!defined($tokens->current)|| $tokens->current ne '|'){return$seq}my@result=@$seq > 1 ? Docopt::Required->new($seq): @$seq;while (defined($tokens->current)&& $tokens->current eq '|'){$tokens->move();$seq=parse_seq($tokens,$options);push@result,@$seq > 1 ? Docopt::Required->new($seq): @$seq}return@result > 1 ? [Docopt::Either->new([map {ref($_)eq 'ARRAY' ? @$_ : $_}@result])]: \@result}sub parse_seq {my ($tokens,$options)=@_;my@result;while (not in($tokens->current,[undef,']',')','|'])){my$atom=parse_atom($tokens,$options);if (defined($tokens->current)&& $tokens->current eq '...'){$atom=Docopt::OneOrMore->new($atom);$tokens->move}push@result,$atom}return [map {ref($_)eq 'ARRAY' ? @$_ : $_}@result]}sub parse_atom {my ($tokens,$options)=@_;my$token=$tokens->current();my@result;if ($token eq '(' || $token eq '['){$tokens->move;my ($matching,$pattern)=@{{'('=>[')',Docopt::Required::],'['=>[']',Docopt::Optional::]}->{$token}};my$expr=parse_expr($tokens,$options);my$result=$pattern->new($expr);if (($tokens->move ||'')ne $matching){Docopt::Exceptions::DocoptLanguageError->throw("unmatched '$token'")}return [$result]}elsif ($token eq 'options'){$tokens->move;return [Docopt::OptionsShortcut->new([])]}elsif ($token =~ /^--/ && $token ne '--'){return parse_long($tokens,$options)}elsif ($token =~ /^-/ && ($token ne '-' && $token ne '--')){return parse_shorts($tokens,$options)}elsif (($token =~ /^</ && $token =~ />$/)or $token =~ /\A[A-Z]+\z/){return [Docopt::Argument->new($tokens->move)]}else {return [Docopt::Command->new($tokens->move)]}}sub parse_argv {my ($tokens,$options,$options_first)=@_;ref($options)eq 'ARRAY' or Carp::confess "Options must be arrayref";my@parsed;while (defined$tokens->current()){if ($tokens->current()eq '--'){return [@parsed,map {Docopt::Argument->new(undef,$_)}@{$tokens->source}]}elsif ($tokens->current()=~ /\A--/){push@parsed,@{parse_long($tokens,$options)}}elsif ($tokens->current()=~ /\A-/ && $tokens->current ne '-'){push@parsed,@{parse_shorts($tokens,$options)}}elsif ($options_first){return [@parsed,map {Docopt::Argument->new(undef,$_)}@{$tokens->source}]}else {push@parsed,Docopt::Argument->new(undef,$tokens->move)}}return \@parsed}sub parse_defaults {my ($doc)=@_;my@defaults;for my$s (parse_section('options:',$doc)){(undef,undef,$s)=string_partition($s,':');my@split=split /\n *(-\S+?)/,"\n" .$s;shift@split;my@split2;for (my$i=0;$i<@split;$i+=2){push@split2,$split[$i].defined_or($split[$i+1],'')}for my$s (grep /^-/,@split2){push@defaults,Docopt::Option->parse($s)}}return@defaults}sub parse_section {my ($name,$source)=@_;defined($source)or Carp::confess("Missing source");my@s;while ($source =~ /^([^\n]*${name}[^\n]*\n?(?:[ \t].*?(?:\n|$))*)/img){local $_=$1;s/\A\s+//;s/\s+\z//;push@s,$_}return@s}sub formal_usage {my ($section)=@_;(undef,undef,$section)=string_partition($section,':');my@pu=grep {/\S/}split /\s+/,$section;my$cmd=shift@pu;return '( ' .join(' ',map {$_ eq $cmd ? ') | (' : $_}@pu).' )'}use List::MoreUtils qw(any);sub extras {my ($help,$version,$options,$doc)=@_;if ($help && any {in($_->name,['-h','--help'])&& $_->value}@$options){print$doc ."\n";exit(0)}if ($version && grep {defined($_->name)&& $_->name eq '--version'}@$options){print "$version\n";exit(0)}}sub docopt {@_%2==0 or Carp::confess("You need to pass arguments are hash");my%args=@_;my$doc=delete$args{doc};my$argv=delete$args{argv}|| \@ARGV;my$help=exists($args{help})? delete$args{help}: true;my$version=delete$args{version};my$option_first=delete$args{option_first};if (%args){Carp::confess("Unknown argument passed to docopt(): " .join(", ",keys%args))}if (not defined$doc){require Pod::Usage;open my$fh,'>',\$doc or die $!;my$parser=Pod::Usage->new(USAGE_OPTIONS=>+{});$parser->select('(?:SYNOPSIS|USAGE)\s*');$parser->parse_from_file($0,$fh)}my@usage_sections=parse_section('usage:',$doc);if (@usage_sections==0){Docopt::Exceptions::DocoptLanguageError->throw('"usage:" (case-insensitive) not found.')}if (@usage_sections > 1){Docopt::Exceptions::DocoptLanguageError->throw('More than one "usage:" (case-insensitive).')}$Docopt::Exceptions::DocoptExit::USAGE=$usage_sections[0];my$options=[parse_defaults($doc)];my$pattern=parse_pattern(formal_usage($usage_sections[0]),$options);$argv=parse_argv(Docopt::Tokens->new($argv),$options,$option_first);my$parse_options=$pattern->flat(Docopt::Option::);for my$options_shortcut (@{$pattern->flat(Docopt::OptionsShortcut::)}){my@doc_options=parse_defaults($doc);$options_shortcut->children([grep {!in(serialize($_),[map {serialize($_)}@$parse_options])}@doc_options])}extras($help,$version,$argv,$doc);my ($matched,$left,$collected)=$pattern->fix->match($argv);if ($matched && serialize($left)eq serialize([])){return +{map {$_->name=>$_->value}@{$pattern->flat},@$collected }}Docopt::Exceptions::DocoptExit->throw()}package Docopt::Exception;use overload (q{""}=>'stringify',);sub stringify {my$self=shift;sprintf "[%s] %s",ref$self,$self->{message}|| 'Died'}sub new {my ($class,$message)=@_;bless {message=>$message},$class}sub throw {my ($class,$message)=@_;die$class->new($message)}package Docopt::Exceptions::DocoptLanguageError;use parent -norequire,qw(Docopt::Exception);package Docopt::Exceptions::DocoptExit;use parent -norequire,qw(Docopt::Exception);our$USAGE;sub stringify {my$self=shift;sprintf "%s\n%s\n",$self->{message}|| '',$USAGE}1;
DOCOPT

$fatpacked{"Docopt/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DOCOPT_UTIL';
  package Docopt::Util;use strict;use warnings;use utf8;use parent qw(Exporter);use boolean;our@EXPORT_OK=qw(repl class_name string_strip string_partition in True False is_number defined_or serialize pyprint);sub True() {true}sub False() {false}use Data::Dumper;use Scalar::Util ();use Storable ();use B;sub pyprint {print Docopt::Util::repl($_[0]),$/}sub serialize($) {local$Storable::canonical=1;return Storable::nfreeze($_[0])}sub is_number {my$value=shift;my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK | B::SVp_NOK)and!($flags & B::SVp_POK);return 0}sub in {my ($val,$patterns)=@_;for (@$patterns){if (defined $_){return 0 if not defined$val;return 1 if$val eq $_}else {return 1 if not defined$val}}return 0}sub repl($) {my ($val)=@_;if (Scalar::Util::blessed($val)&& $val->can('__repl__')){$val->__repl__}elsif ((Scalar::Util::blessed($val)||'')eq 'boolean'){$val ? 'True' : 'False'}elsif (ref($val)eq 'ARRAY'){return '[' .join(', ',map {&repl($_)}@$val).']'}else {local$Data::Dumper::Terse=1;local$Data::Dumper::Indent=0;local$Data::Dumper::Useqq=1;Dumper($val)}}sub class_name {my$name=ref $_[0]|| $_[0];$name =~ s/^Docopt:://;$name}sub string_strip($) {local $_=shift;s/^\s+//;s/\s+$//;$_}sub string_partition($$) {my ($str,$sep)=@_;if ($str =~ /\A(.*?)$sep(.*)\z/s){return ($1,$sep,$2)}else {return ($str,'','')}}sub defined_or {defined($_[0])? $_[0]: $_[1]}1;
DOCOPT_UTIL

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;use 5.006001;use strict;use warnings;use Exporter::Tiny ();our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.044';sub import {my$me=shift;my$caller=caller;(my$nominal_file=$caller)=~ s(::)(/)g;$INC{"$nominal_file\.pm"}||= __FILE__;if (@_==2 and $_[0]eq -setup){my (undef,$opts)=@_;@_=@{delete($opts->{exports})|| []};if (%$opts){Exporter::Tiny::_croak('Unsupported Sub::Exporter-style options: %s',join(q[, ],sort keys %$opts),)}}ref($_)&& Exporter::Tiny::_croak('Expected sub name, got ref %s',$_)for @_;no strict qw(refs);push @{"$caller\::ISA"},'Exporter::Tiny';push @{"$caller\::EXPORT_OK"},@_}1;
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;use 5.006001;use strict;use warnings;no warnings qw(void once uninitialized numeric redefine);our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.044';our@EXPORT_OK=qw<mkopt mkopt_hash _croak _carp>;sub _croak ($;@) {require Carp;my$fmt=shift;@_=sprintf($fmt,@_);goto \&Carp::croak}sub _carp ($;@) {require Carp;my$fmt=shift;@_=sprintf($fmt,@_);goto \&Carp::carp}my$_process_optlist=sub {my$class=shift;my ($global_opts,$opts,$want,$not_want)=@_;while (@$opts){my$opt=shift @{$opts};my ($name,$value)=@$opt;($name =~ m{\A\!(/.+/[msixpodual]+)\z})? do {my@not=$class->_exporter_expand_regexp($1,$value,$global_opts);++$not_want->{$_->[0]}for@not}: ($name =~ m{\A\!(.+)\z})? (++$not_want->{$1}): ($name =~ m{\A[:-](.+)\z})? push(@$opts,$class->_exporter_expand_tag($1,$value,$global_opts)): ($name =~ m{\A/.+/[msixpodual]+\z})? push(@$opts,$class->_exporter_expand_regexp($name,$value,$global_opts)): push(@$want,$opt)}};sub import {my$class=shift;my$global_opts=+{@_ && ref($_[0])eq q(HASH) ? %{+shift}: ()};$global_opts->{into}=caller unless exists$global_opts->{into};my@want;my%not_want;$global_opts->{not}=\%not_want;my@args=do {no strict qw(refs);@_ ? @_ : @{"$class\::EXPORT"}};my$opts=mkopt(\@args);$class->$_process_optlist($global_opts,$opts,\@want,\%not_want);my$permitted=$class->_exporter_permitted_regexp($global_opts);$class->_exporter_validate_opts($global_opts);for my$wanted (@want){next if$not_want{$wanted->[0]};my%symbols=$class->_exporter_expand_sub(@$wanted,$global_opts,$permitted);$class->_exporter_install_sub($_,$wanted->[1],$global_opts,$symbols{$_})for keys%symbols}}sub unimport {my$class=shift;my$global_opts=+{@_ && ref($_[0])eq q(HASH) ? %{+shift}: ()};$global_opts->{into}=caller unless exists$global_opts->{into};$global_opts->{is_unimport}=1;my@want;my%not_want;$global_opts->{not}=\%not_want;my@args=do {our%TRACKED;@_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}})};my$opts=mkopt(\@args);$class->$_process_optlist($global_opts,$opts,\@want,\%not_want);my$permitted=$class->_exporter_permitted_regexp($global_opts);$class->_exporter_validate_unimport_opts($global_opts);my$expando=$class->can('_exporter_expand_sub');$expando=undef if$expando==\&_exporter_expand_sub;for my$wanted (@want){next if$not_want{$wanted->[0]};if ($wanted->[1]){_carp("Passing options to unimport '%s' makes no sense",$wanted->[0])unless (ref($wanted->[1])eq 'HASH' and not keys %{$wanted->[1]})}my%symbols=defined($expando)? $class->$expando(@$wanted,$global_opts,$permitted): ($wanted->[0]=>sub {"dummy"});$class->_exporter_uninstall_sub($_,$wanted->[1],$global_opts)for keys%symbols}}sub _exporter_validate_opts {1}sub _exporter_validate_unimport_opts {1}sub _exporter_merge_opts {my$class=shift;my ($tag_opts,$global_opts,@stuff)=@_;$tag_opts={}unless ref($tag_opts)eq q(HASH);_croak('Cannot provide an -as option for tags')if exists$tag_opts->{-as}&& ref$tag_opts->{-as}ne 'CODE';my$optlist=mkopt(\@stuff);for my$export (@$optlist){next if defined($export->[1])&& ref($export->[1])ne q(HASH);my%sub_opts=(%{$export->[1]or {}},%$tag_opts);$sub_opts{-prefix}=sprintf('%s%s',$tag_opts->{-prefix},$export->[1]{-prefix})if exists($export->[1]{-prefix})&& exists($tag_opts->{-prefix});$sub_opts{-suffix}=sprintf('%s%s',$export->[1]{-suffix},$tag_opts->{-suffix})if exists($export->[1]{-suffix})&& exists($tag_opts->{-suffix});$export->[1]=\%sub_opts}return @$optlist}sub _exporter_expand_tag {no strict qw(refs);my$class=shift;my ($name,$value,$globals)=@_;my$tags=\%{"$class\::EXPORT_TAGS"};return$class->_exporter_merge_opts($value,$globals,$tags->{$name}->($class,@_))if ref($tags->{$name})eq q(CODE);return$class->_exporter_merge_opts($value,$globals,@{$tags->{$name}})if exists$tags->{$name};return$class->_exporter_merge_opts($value,$globals,@{"$class\::EXPORT"},@{"$class\::EXPORT_OK"})if$name eq 'all';return$class->_exporter_merge_opts($value,$globals,@{"$class\::EXPORT"})if$name eq 'default';$globals->{$name}=$value || 1;return}sub _exporter_expand_regexp {no strict qw(refs);our%TRACKED;my$class=shift;my ($name,$value,$globals)=@_;my$compiled=eval("qr$name");my@possible=$globals->{is_unimport}? keys(%{$TRACKED{$class}{$globals->{into}}}): @{"$class\::EXPORT_OK"};$class->_exporter_merge_opts($value,$globals,grep /$compiled/,@possible)}sub _exporter_permitted_regexp {no strict qw(refs);my$class=shift;my$re=join "|",map quotemeta,sort {length($b)<=> length($a)or $a cmp $b}@{"$class\::EXPORT"},@{"$class\::EXPORT_OK"};qr{^(?:$re)$}ms}sub _exporter_expand_sub {my$class=shift;my ($name,$value,$globals,$permitted)=@_;$permitted ||= $class->_exporter_permitted_regexp($globals);no strict qw(refs);if ($name =~ $permitted){my$generator=$class->can("_generate_$name");return$name=>$class->$generator($name,$value,$globals)if$generator;my$sub=$class->can($name);return$name=>$sub if$sub}$class->_exporter_fail(@_)}sub _exporter_fail {my$class=shift;my ($name,$value,$globals)=@_;return if$globals->{is_unimport};_croak("Could not find sub '%s' exported by %s",$name,$class)}sub _exporter_install_sub {my$class=shift;my ($name,$value,$globals,$sym)=@_;my$into=$globals->{into};my$installer=$globals->{installer}|| $globals->{exporter};$name=ref$globals->{as}? $globals->{as}->($name): ref$value->{-as}? $value->{-as}->($name): exists$value->{-as}? $value->{-as}: $name;return unless defined$name;unless (ref($name)){my ($prefix)=grep defined,$value->{-prefix},$globals->{prefix},q();my ($suffix)=grep defined,$value->{-suffix},$globals->{suffix},q();$name="$prefix$name$suffix"}return ($$name=$sym)if ref($name)eq q(SCALAR);return ($into->{$name}=$sym)if ref($into)eq q(HASH);no strict qw(refs);if (exists &{"$into\::$name"}and \&{"$into\::$name"}!=$sym){my ($level)=grep defined,$value->{-replace},$globals->{replace},q(0);my$action={carp=>\&_carp,0=>\&_carp,''=>\&_carp,warn=>\&_carp,nonfatal=>\&_carp,croak=>\&_croak,fatal=>\&_croak,die=>\&_croak,}->{$level}|| sub {};$action->($action==\&_croak ? "Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s" : "Overwriting existing sub '%s::%s' with sub '%s' exported by %s",$into,$name,$_[0],$class,)}our%TRACKED;$TRACKED{$class}{$into}{$name}=$sym;no warnings qw(prototype);$installer ? $installer->($globals,[$name,$sym]): (*{"$into\::$name"}=$sym)}sub _exporter_uninstall_sub {our%TRACKED;my$class=shift;my ($name,$value,$globals,$sym)=@_;my$into=$globals->{into};ref$into and return;no strict qw(refs);my$our_coderef=$TRACKED{$class}{$into}{$name};my$cur_coderef=exists(&{"$into\::$name"})? \&{"$into\::$name"}: -1;return unless$our_coderef==$cur_coderef;my$stash=\%{"$into\::"};my$old=delete$stash->{$name};my$full_name=join('::',$into,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});*$full_name=*{$old}{$type}}delete$TRACKED{$class}{$into}{$name}}sub mkopt {my$in=shift or return [];my@out;$in=[map(($_=>ref($in->{$_})? $in->{$_}: ()),sort keys %$in)]if ref($in)eq q(HASH);for (my$i=0;$i < @$in;$i++){my$k=$in->[$i];my$v;($i==$#$in)? ($v=undef): !defined($in->[$i+1])? (++$i,($v=undef)): !ref($in->[$i+1])? ($v=undef): ($v=$in->[++$i]);push@out,[$k=>$v ]}\@out}sub mkopt_hash {my$in=shift or return;my%out=map +($_->[0]=>$_->[1]),@{mkopt($in)};\%out}1;
EXPORTER_TINY

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.011';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,blib=>'blib',create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my (%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"List/MoreUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS';
  package List::MoreUtils;use 5.008_001;use strict;use warnings;my$have_xs;BEGIN {our$VERSION='0.419';unless (defined($have_xs)){eval {require List::MoreUtils::XS}unless$ENV{LIST_MOREUTILS_PP};die $@ if $@ && defined$ENV{LIST_MOREUTILS_PP}&& $ENV{LIST_MOREUTILS_PP}==0;$have_xs=0+defined($INC{'List/MoreUtils/XS.pm'})}use List::MoreUtils::PP qw()}use Exporter::Tiny qw();my@junctions=qw(any all none notall);my@v0_22=qw(true false firstidx lastidx insert_after insert_after_string apply indexes after after_incl before before_incl firstval lastval each_array each_arrayref pairwise natatime mesh uniq minmax part _XScompiled);my@v0_24=qw(bsearch);my@v0_33=qw(sort_by nsort_by);my@v0_400=qw(one any_u all_u none_u notall_u one_u firstres onlyidx onlyval onlyres lastres singleton bsearchidx);my@all_functions=(@junctions,@v0_22,@v0_24,@v0_33,@v0_400);no strict "refs";if ($have_xs){my$x;for (@all_functions){List::MoreUtils->can($_)or *$_=$x if ($x=List::MoreUtils::XS->can($_))}}List::MoreUtils->can($_)or *$_=List::MoreUtils::PP->can($_)for (@all_functions);use strict;my%alias_list=(v0_22=>{first_index=>"firstidx",last_index=>"lastidx",first_value=>"firstval",last_value=>"lastval",zip=>"mesh",},v0_33=>{distinct=>"uniq",},v0_400=>{first_result=>"firstres",only_index=>"onlyidx",only_value=>"onlyval",only_result=>"onlyres",last_result=>"lastres",bsearch_index=>"bsearchidx",},);our@ISA=qw(Exporter::Tiny);our@EXPORT_OK=(@all_functions,map {keys %$_}values%alias_list);our%EXPORT_TAGS=(all=>\@EXPORT_OK,'like_0.22'=>[any_u=>{-as=>'any'},all_u=>{-as=>'all'},none_u=>{-as=>'none'},notall_u=>{-as=>'notall'},@v0_22,keys %{$alias_list{v0_22}},],'like_0.24'=>[any_u=>{-as=>'any'},all_u=>{-as=>'all'},notall_u=>{-as=>'notall'},'none',@v0_22,@v0_24,keys %{$alias_list{v0_22}},],'like_0.33'=>[@junctions,@v0_22,@v0_33,keys %{$alias_list{v0_22}},keys %{$alias_list{v0_33}},],);for my$set (values%alias_list){for my$alias (keys %$set){no strict qw(refs);*$alias=__PACKAGE__->can($set->{$alias})}}1;
LIST_MOREUTILS

$fatpacked{"List/MoreUtils/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS_PP';
  package List::MoreUtils::PP;use 5.008_001;use strict;use warnings;our$VERSION='0.419';sub any (&@) {my$f=shift;for (@_){return 1 if$f->()}return 0}sub all (&@) {my$f=shift;for (@_){return 0 unless$f->()}return 1}sub none (&@) {my$f=shift;for (@_){return 0 if$f->()}return 1}sub notall (&@) {my$f=shift;for (@_){return 1 unless$f->()}return 0}sub one (&@) {my$f=shift;my$found=0;for (@_){$f->()and $found++ and return 0}$found}sub any_u (&@) {my$f=shift;return if!@_;$f->()and return 1 foreach (@_);return 0}sub all_u (&@) {my$f=shift;return if!@_;$f->()or return 0 foreach (@_);return 1}sub none_u (&@) {my$f=shift;return if!@_;$f->()and return 0 foreach (@_);return 1}sub notall_u (&@) {my$f=shift;return if!@_;$f->()or return 1 foreach (@_);return 0}sub one_u (&@) {my$f=shift;return if!@_;my$found=0;for (@_){$f->()and $found++ and return 0}$found}sub true (&@) {my$f=shift;my$count=0;$f->()and ++$count foreach (@_);return$count}sub false (&@) {my$f=shift;my$count=0;$f->()or ++$count foreach (@_);return$count}sub firstidx (&@) {my$f=shift;for my$i (0 .. $#_){local*_=\$_[$i];return$i if$f->()}return -1}sub firstval (&@) {my$test=shift;for (@_){return $_ if$test->()}return undef}sub firstres (&@) {my$test=shift;for (@_){my$testval=$test->();$testval and return$testval}return undef}sub onlyidx (&@) {my$f=shift;my$found;for my$i (0 .. $#_){local*_=\$_[$i];$f->()or next;defined$found and return -1;$found=$i}return defined$found ? $found : -1}sub onlyval (&@) {my$test=shift;my$result=undef;my$found=0;for (@_){$test->()or next;$result=$_;$found++ and return undef}return$result}sub onlyres (&@) {my$test=shift;my$result=undef;my$found=0;for (@_){my$rv=$test->()or next;$result=$rv;$found++ and return undef}return$found ? $result : undef}sub lastidx (&@) {my$f=shift;for my$i (reverse 0 .. $#_){local*_=\$_[$i];return$i if$f->()}return -1}sub lastval (&@) {my$test=shift;my$ix;for ($ix=$#_;$ix >= 0;$ix-- ){local*_=\$_[$ix];my$testval=$test->();$_[$ix]=$_;return $_ if$testval}return undef}sub lastres (&@) {my$test=shift;my$ix;for ($ix=$#_;$ix >= 0;$ix-- ){local*_=\$_[$ix];my$testval=$test->();$_[$ix]=$_;return$testval if$testval}return undef}sub insert_after (&$\@) {my ($f,$val,$list)=@_;my$c=&firstidx($f,@$list);@$list=(@{$list}[0 .. $c ],$val,@{$list}[$c + 1 .. $#$list ],)and return 1 if$c!=-1;return 0}sub insert_after_string ($$\@) {my ($string,$val,$list)=@_;my$c=firstidx {defined $_ and $string eq $_}@$list;@$list=(@{$list}[0 .. $c ],$val,@{$list}[$c + 1 .. $#$list ],)and return 1 if$c!=-1;return 0}sub apply (&@) {my$action=shift;&$action foreach my@values=@_;wantarray ? @values : $values[-1]}sub after (&@) {my$test=shift;my$started;my$lag;grep$started ||= do {my$x=$lag;$lag=$test->();$x},@_}sub after_incl (&@) {my$test=shift;my$started;grep$started ||= $test->(),@_}sub before (&@) {my$test=shift;my$more=1;grep$more &&=!$test->(),@_}sub before_incl (&@) {my$test=shift;my$more=1;my$lag=1;grep$more &&= do {my$x=$lag;$lag=!$test->();$x},@_}sub indexes (&@) {my$test=shift;grep {local*_=\$_[$_];$test->()}0 .. $#_}sub pairwise (&\@\@) {my$op=shift;use vars qw{@A @B};local (*A,*B)=@_;my ($caller_a,$caller_b)=do {my$pkg=caller();no strict 'refs';\*{$pkg .'::a'},\*{$pkg .'::b'}};my$limit=$#A > $#B ? $#A : $#B;local (*$caller_a,*$caller_b);map {(*$caller_a,*$caller_b)=\($A[$_],$B[$_]);$op->()}0 .. $limit}sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {return each_arrayref(@_)}sub each_arrayref {my@list=@_;my$index=0;my$max=0;for (@list){unless (ref $_ eq 'ARRAY'){require Carp;Carp::croak("each_arrayref: argument is not an array reference\n")}$max=@$_ if @$_ > $max}return sub {if (@_){my$method=shift;unless ($method eq 'index'){require Carp;Carp::croak("each_array: unknown argument '$method' passed to iterator.")}return undef if$index==0 || $index > $max;return$index - 1}return if$index >= $max;my$i=$index++;return map $_->[$i],@list}}sub natatime ($@) {my$n=shift;my@list=@_;return sub {return splice@list,0,$n}}sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {my$max=-1;$max < $#$_ && ($max=$#$_)foreach @_;map {my$ix=$_;map $_->[$ix],@_}0 .. $max}sub uniq (@) {my%seen=();my$k;my$seen_undef;grep {defined $_ ? not $seen{$k=$_ }++ : not $seen_undef++}@_}sub singleton (@) {my%seen=();my$k;my$seen_undef;grep {1==(defined $_ ? $seen{$k=$_ }: $seen_undef)}grep {defined $_ ? not $seen{$k=$_ }++ : not $seen_undef++}@_}sub minmax (@) {return unless @_;my$min=my$max=$_[0];for (my$i=1;$i < @_;$i += 2 ){if ($_[$i - 1 ]<= $_[$i]){$min=$_[$i - 1 ]if$min > $_[$i - 1 ];$max=$_[$i]if$max < $_[$i]}else {$min=$_[$i]if$min > $_[$i];$max=$_[$i - 1 ]if$max < $_[$i - 1 ]}}if (@_ & 1){my$i=$#_;if ($_[$i - 1 ]<= $_[$i]){$min=$_[$i - 1 ]if$min > $_[$i - 1 ];$max=$_[$i]if$max < $_[$i]}else {$min=$_[$i]if$min > $_[$i];$max=$_[$i - 1 ]if$max < $_[$i - 1 ]}}return ($min,$max)}sub part (&@) {my ($code,@list)=@_;my@parts;push @{$parts[$code->($_)]},$_ foreach@list;return@parts}sub bsearch(&@) {my$code=shift;my$rc;my$i=0;my$j=@_;do {my$k=int(($i + $j)/ 2);$k >= @_ and return;local*_=\$_[$k];$rc=$code->();$rc==0 and return wantarray ? $_ : 1;if ($rc < 0){$i=$k + 1}else {$j=$k - 1}}until$i > $j;return}sub bsearchidx(&@) {my$code=shift;my$rc;my$i=0;my$j=@_;do {my$k=int(($i + $j)/ 2);$k >= @_ and return -1;local*_=\$_[$k];$rc=$code->();$rc==0 and return$k;if ($rc < 0){$i=$k + 1}else {$j=$k - 1}}until$i > $j;return -1}sub sort_by(&@) {my ($code,@list)=@_;return map {$_->[0]}sort {$a->[1]cmp $b->[1]}map {[$_,scalar($code->())]}@list}sub nsort_by(&@) {my ($code,@list)=@_;return map {$_->[0]}sort {$a->[1]<=> $b->[1]}map {[$_,scalar($code->())]}@list}sub _XScompiled {0}1;
LIST_MOREUTILS_PP

$fatpacked{"Test/Deep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP';
  use strict;use warnings;package Test::Deep;use Carp qw(confess);use Test::Deep::Cache;use Test::Deep::Stack;use Test::Deep::RegexpVersion;require overload;use Scalar::Util;my$Test;unless (defined$Test::Deep::NoTest::NoTest){require Test::Builder;$Test=Test::Builder->new}our ($Stack,%Compared,$CompareCache,%WrapCache,$Shallow);our$VERSION='1.127';$VERSION =~ tr/_//d;require Exporter;our@ISA=qw(Exporter);our$Snobby=1;our$Expects=0;our$LeafWrapper;our$DNE=\"";our$DNE_ADDR=Scalar::Util::refaddr($DNE);my@constructors=(All=>"",Any=>"",Array=>"",ArrayEach=>"array_each",ArrayElementsOnly=>"",ArrayLength=>"",ArrayLengthOnly=>"",Blessed=>"",Boolean=>"bool",Code=>"",Hash=>"",HashEach=>"hash_each",HashKeys=>"",HashKeysOnly=>"",Ignore=>"",Isa=>"Isa",ListMethods=>"",Methods=>"",None=>"",Number=>"num",Obj=>"obj_isa",RefType=>"",Regexp=>"re",RegexpMatches=>"",RegexpOnly=>"",RegexpRef=>"",RegexpRefOnly=>"",ScalarRef=>"scalref",ScalarRefOnly=>"",Shallow=>"",String=>"str",);my@CONSTRUCTORS_FROM_CLASSES;while (my ($pkg,$name)=splice@constructors,0,2){$name=lc($pkg)unless$name;my$full_pkg="Test::Deep::$pkg";my$file="$full_pkg.pm";$file =~ s#::#/#g;my$sub=sub {require$file;return$full_pkg->new(@_)};{no strict 'refs';*{$name}=$sub}push@CONSTRUCTORS_FROM_CLASSES,$name}{our@EXPORT_OK=qw(descend render_stack cmp_details deep_diag);our%EXPORT_TAGS;$EXPORT_TAGS{preload}=[];$EXPORT_TAGS{v0}=[qw(Isa blessed obj_isa all any array array_each arrayelementsonly arraylength arraylengthonly bag bool cmp_bag cmp_deeply cmp_methods cmp_set code eq_deeply hash hash_each hashkeys hashkeysonly ignore isa listmethods methods noclass none noneof num re reftype regexpmatches regexponly regexpref regexprefonly scalarrefonly scalref set shallow str subbagof subhashof subsetof superbagof superhashof supersetof useclass) ];$EXPORT_TAGS{v1}=[qw(obj_isa all any array array_each arrayelementsonly arraylength arraylengthonly bag bool cmp_bag cmp_deeply cmp_methods cmp_set code eq_deeply hash hash_each hashkeys hashkeysonly ignore listmethods methods noclass none noneof num re reftype regexpmatches regexponly regexpref regexprefonly scalarrefonly scalref set shallow str subbagof subhashof subsetof superbagof superhashof supersetof useclass) ];our@EXPORT=@{$EXPORT_TAGS{v0 }};$EXPORT_TAGS{all}=[@EXPORT,@EXPORT_OK ]}sub import {my$self=shift;my@sans_preload=grep {;$_ ne ':preload'}@_;if (@_!=@sans_preload){require Test::Deep::All;require Test::Deep::Any;require Test::Deep::Array;require Test::Deep::ArrayEach;require Test::Deep::ArrayElementsOnly;require Test::Deep::ArrayLength;require Test::Deep::ArrayLengthOnly;require Test::Deep::Blessed;require Test::Deep::Boolean;require Test::Deep::Cache::Simple;require Test::Deep::Cache;require Test::Deep::Class;require Test::Deep::Cmp;require Test::Deep::Code;require Test::Deep::Hash;require Test::Deep::HashEach;require Test::Deep::HashElements;require Test::Deep::HashKeys;require Test::Deep::HashKeysOnly;require Test::Deep::Ignore;require Test::Deep::Isa;require Test::Deep::ListMethods;require Test::Deep::Methods;require Test::Deep::MM;require Test::Deep::None;require Test::Deep::Number;require Test::Deep::Obj;require Test::Deep::Ref;require Test::Deep::RefType;require Test::Deep::Regexp;require Test::Deep::RegexpMatches;require Test::Deep::RegexpOnly;require Test::Deep::RegexpRef;require Test::Deep::RegexpRefOnly;require Test::Deep::RegexpVersion;require Test::Deep::ScalarRef;require Test::Deep::ScalarRefOnly;require Test::Deep::Set;require Test::Deep::Shallow;require Test::Deep::Stack;require Test::Deep::String}$self->export_to_level(1,$self,@_)}sub isa {if (@_==1){goto&Isa}else {goto&UNIVERSAL::isa}}sub cmp_deeply {my ($d1,$d2,$name)=@_;my ($ok,$stack)=cmp_details($d1,$d2);if (not $Test->ok($ok,$name)){my$diag=deep_diag($stack);$Test->diag($diag)}return$ok}sub cmp_details {my ($d1,$d2)=@_;local$Stack=Test::Deep::Stack->new;local$CompareCache=Test::Deep::Cache->new;local%WrapCache;my$ok=descend($d1,$d2);return ($ok,$Stack)}sub eq_deeply {my ($d1,$d2)=@_;my ($ok)=cmp_details($d1,$d2);return$ok}sub eq_deeply_cache {my ($d1,$d2,$name)=@_;local$Stack=Test::Deep::Stack->new;$CompareCache->local;my$ok=descend($d1,$d2);$CompareCache->finish($ok);return$ok}sub deep_diag {my$stack=shift;local$Stack=$stack;my$where=render_stack('$data',$stack);confess "No stack to diagnose" unless$stack;my$last=$stack->getLast;my$diag;my$message;my$got;my$expected;my$exp=$last->{exp};if (Scalar::Util::blessed($exp)){if ($exp->can("diagnostics")){$diag=$exp->diagnostics($where,$last);$diag =~ s/\n+$/\n/}else {if ($exp->can("diag_message")){$message=$exp->diag_message($where)}}}if (not defined$diag){$got=$exp->renderGot($last->{got})unless defined$got;$expected=$exp->renderExp unless defined$expected;$message="Compared $where" unless defined$message;$diag=<<EOM}return$diag}sub render_val {my$val=shift;my$rendered;if (defined$val){$rendered=ref($val)? (Scalar::Util::refaddr($val)eq $DNE_ADDR ? "Does not exist" : overload::StrVal($val)): qq('$val')}else {$rendered="undef"}return$rendered}sub descend {my ($d1,$d2)=@_;if (!ref$d1 and!ref$d2){if (defined$d1){return 1 if defined$d2 and $d1 eq $d2}else {return 1 if!defined$d2}}if (!$Expects and Scalar::Util::blessed($d1)and $d1->isa("Test::Deep::Cmp")){my$where=$Stack->render('$data');confess "Found a special comparison in $where\nYou can only use specials in the expects structure"}if (ref$d1 and ref$d2){if ($Expects and Scalar::Util::blessed($d1)and $d1->isa("Test::Deep::Cmp")){return 0 unless Test::Deep::blessed(Scalar::Util::blessed($d2))->descend($d1);if ($d1->can("compare")){return$d1->compare($d2)}}my$s1=Scalar::Util::refaddr($d1);my$s2=Scalar::Util::refaddr($d2);if ($s1 eq $s2){return 1}if ($CompareCache->cmp($d1,$d2)){return 1}else {$CompareCache->add($d1,$d2)}}$d2=wrap($d2);$Stack->push({exp=>$d2,got=>$d1});if (ref($d1)and (Scalar::Util::refaddr($d1)==$DNE_ADDR)){return 0}if ($d2->descend($d1)){$Stack->pop;return 1}else {return 0}}sub wrap {my$data=shift;my$class=Scalar::Util::blessed($data);return$data if defined$class and $data->isa("Test::Deep::Cmp");if (defined$class and $data->can('as_test_deep_cmp')){my$cmp=$data->as_test_deep_cmp;return$cmp if$cmp->isa('Test::Deep::Cmp');Carp::confess("object in expected structure provides as_test_deep_cmp but it did not return a Test::Deep::Cmp")}my$reftype=_td_reftype($data);my$cmp;if($reftype eq ''){$cmp=$Test::Deep::LeafWrapper ? $Test::Deep::LeafWrapper->($data): shallow($data)}else {my$addr=Scalar::Util::refaddr($data);return$WrapCache{$addr}if$WrapCache{$addr};if($reftype eq 'ARRAY'){$cmp=array($data)}elsif($reftype eq 'HASH'){$cmp=hash($data)}elsif($reftype eq 'SCALAR' or $reftype eq 'REF'){$cmp=scalref($data)}elsif(($reftype eq 'Regexp')or ($reftype eq 'REGEXP')){$cmp=regexpref($data)}else {$cmp=$Test::Deep::LeafWrapper ? $Test::Deep::LeafWrapper->($data): shallow($data)}$WrapCache{$addr}=$cmp}return$cmp}sub _td_reftype {my$val=shift;my$reftype=Scalar::Util::reftype($val);return '' unless defined$reftype;return$reftype unless$Test::Deep::RegexpVersion::OldStyle;my$blessed=Scalar::Util::blessed($val);return$reftype unless defined$blessed;if ($blessed && $blessed eq "Regexp" and $reftype eq "SCALAR"){$reftype="Regexp"}return$reftype}sub render_stack {my ($var,$stack)=@_;return$stack->render($var)}sub cmp_methods {local$Test::Builder::Level=$Test::Builder::Level + 1;return cmp_deeply(shift,methods(@{shift()}),shift)}sub requireclass {require Test::Deep::Class;my$val=shift;return Test::Deep::Class->new(1,$val)}*useclass=\&requireclass;sub noclass {require Test::Deep::Class;my$val=shift;return Test::Deep::Class->new(0,$val)}sub set {require Test::Deep::Set;return Test::Deep::Set->new(1,"",@_)}sub supersetof {require Test::Deep::Set;return Test::Deep::Set->new(1,"sup",@_)}sub subsetof {require Test::Deep::Set;return Test::Deep::Set->new(1,"sub",@_)}sub noneof {require Test::Deep::Set;return Test::Deep::Set->new(1,"none",@_)}sub cmp_set {local$Test::Builder::Level=$Test::Builder::Level + 1;return cmp_deeply(shift,set(@{shift()}),shift)}sub bag {require Test::Deep::Set;return Test::Deep::Set->new(0,"",@_)}sub superbagof {require Test::Deep::Set;return Test::Deep::Set->new(0,"sup",@_)}sub subbagof {require Test::Deep::Set;return Test::Deep::Set->new(0,"sub",@_)}sub cmp_bag {local$Test::Builder::Level=$Test::Builder::Level + 1;my$ref=ref($_[1])|| "";confess "Argument 2 to cmp_bag is not an ARRAY ref (".render_val($_[1]).")" unless$ref eq "ARRAY";return cmp_deeply(shift,bag(@{shift()}),shift)}sub superhashof {require Test::Deep::Hash;my$val=shift;return Test::Deep::SuperHash->new($val)}sub subhashof {require Test::Deep::Hash;my$val=shift;return Test::Deep::SubHash->new($val)}sub builder {if (@_){$Test=shift}return$Test}1;
  $message
     got : $got
  expect : $expected
  EOM
TEST_DEEP

$fatpacked{"Test/Deep/All.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ALL';
  use strict;use warnings;package Test::Deep::All;use Scalar::Util ();use Test::Deep::Cmp;sub init {my$self=shift;my@list=map {(Scalar::Util::blessed($_)&& $_->isa('Test::Deep::All'))? @{$_->{val}}: $_}@_;$self->{val}=\@list}sub descend {my$self=shift;my$got=shift;my$data=$self->data;my$index=1;for my$cmp (@{$self->{val}}){$data->{index}=$index;$index++;next if Test::Deep::descend($got,$cmp);return 0}return 1}sub render_stack {my$self=shift;my$var=shift;my$data=shift;my$max=@{$self->{val}};return "(Part $data->{index} of $max in $var)"}1;
TEST_DEEP_ALL

$fatpacked{"Test/Deep/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ANY';
  use strict;use warnings;package Test::Deep::Any;use Scalar::Util ();use Test::Deep::Cmp;sub init {my$self=shift;my@list=map {(Scalar::Util::blessed($_)&& $_->isa('Test::Deep::Any'))? @{$_->{val}}: $_}@_;$self->{val}=\@list}sub descend {my$self=shift;my$got=shift;for my$cmp (@{$self->{val}}){return 1 if Test::Deep::eq_deeply_cache($got,$cmp)}return 0}sub renderExp {my$self=shift;my@expect=map {;Test::Deep::wrap($_)}@{$self->{val}};my$things=join(", ",map {$_->renderExp}@expect);return "Any of ( $things )"}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$got=$self->renderGot($last->{got});my$exp=$self->renderExp;my$diag=<<EOM;$diag =~ s/\n+$/\n/;return$diag}4;
  Comparing $where with Any
  got      : $got
  expected : $exp
  EOM
TEST_DEEP_ANY

$fatpacked{"Test/Deep/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAY';
  use strict;use warnings;package Test::Deep::Array;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless Test::Deep::descend($got,Test::Deep::arraylength(scalar @$exp));return 0 unless$self->test_class($got);return Test::Deep::descend($got,Test::Deep::arrayelementsonly($exp))}sub reset_arrow {return 0}1;
TEST_DEEP_ARRAY

$fatpacked{"Test/Deep/ArrayEach.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYEACH';
  use strict;use warnings;package Test::Deep::ArrayEach;use Test::Deep::Cmp;use Scalar::Util ();sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;return unless ref$got && Scalar::Util::reftype($got)eq 'ARRAY';my$exp=[($self->{val})x @$got ];return Test::Deep::descend($got,$exp)}sub renderExp {my$self=shift;my$exp=shift;return '[ ' .$self->SUPER::renderExp($self->{val}).', ... ]'}1;
TEST_DEEP_ARRAYEACH

$fatpacked{"Test/Deep/ArrayElementsOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYELEMENTSONLY';
  use strict;use warnings;package Test::Deep::ArrayElementsOnly;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$data=$self->data;for my$i (0..$#{$exp}){$data->{index}=$i;my$got_elem=$got->[$i];my$exp_elem=$exp->[$i];return 0 unless Test::Deep::descend($got_elem,$exp_elem)}return 1}sub render_stack {my$self=shift;my ($var,$data)=@_;$var .= "->" unless$Test::Deep::Stack->incArrow;$var .= "[$data->{index}]";return$var}sub reset_arrow {return 0}1;
TEST_DEEP_ARRAYELEMENTSONLY

$fatpacked{"Test/Deep/ArrayLength.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYLENGTH';
  use strict;use warnings;package Test::Deep::ArrayLength;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless$self->test_reftype($got,"ARRAY");return Test::Deep::descend($got,Test::Deep::arraylengthonly($exp))}1;
TEST_DEEP_ARRAYLENGTH

$fatpacked{"Test/Deep/ArrayLengthOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYLENGTHONLY';
  use strict;use warnings;package Test::Deep::ArrayLengthOnly;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$len=$self->{val};return @$got==$len}sub render_stack {my$self=shift;my ($var,$data)=@_;return "array length of $var"}sub renderVal {my$self=shift;my$val=shift;return "array with $val element(s)"}sub renderGot {my$self=shift;my$got=shift;return$self->renderVal(@$got + 0)}sub renderExp {my$self=shift;return$self->renderVal($self->{val})}1;
TEST_DEEP_ARRAYLENGTHONLY

$fatpacked{"Test/Deep/Blessed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_BLESSED';
  use strict;use warnings;package Test::Deep::Blessed;use Test::Deep::Cmp;use Scalar::Util qw(blessed);sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$blessed=blessed($got);return Test::Deep::descend($blessed,Test::Deep::shallow($exp))}sub render_stack {my$self=shift;my$var=shift;return "blessed($var)"}sub renderGot {my$self=shift;my$got=shift;$self->SUPER::renderGot(blessed($got))}1;
TEST_DEEP_BLESSED

$fatpacked{"Test/Deep/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_BOOLEAN';
  use strict;use warnings;package Test::Deep::Boolean;use Test::Deep::Cmp;sub init {my$self=shift;$self->{val}=shift()? 1 : 0}sub descend {my$self=shift;my$got=shift;return!($got xor $self->{val})}sub diag_message {my$self=shift;my$where=shift;return "Comparing $where as a boolean"}sub renderExp {my$self=shift;$self->renderGot($self->{val})}sub renderGot {my$self=shift;my$val=shift;return ($val ? "true" : "false")." (".Test::Deep::render_val($val).")"}1;
TEST_DEEP_BOOLEAN

$fatpacked{"Test/Deep/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CACHE';
  use strict;use warnings;package Test::Deep::Cache;use Test::Deep::Cache::Simple;sub new {my$pkg=shift;my$self=bless {},$pkg;$self->{expects}=[Test::Deep::Cache::Simple->new];$self->{normal}=[Test::Deep::Cache::Simple->new];$self->local;return$self}sub add {my$self=shift;my$type=$self->type;$self->{$type}->[-1]->add(@_)}sub cmp {my$self=shift;my$type=$self->type;for my$cache (@{$self->{$type}}){return 1 if$cache->cmp(@_)}return 0}sub local {my$self=shift;for my$type (qw(expects normal)){push(@{$self->{$type}},Test::Deep::Cache::Simple->new)}}sub finish {my$self=shift;my$keep=shift;for my$type (qw(expects normal)){my$caches=$self->{$type};my$last=pop @$caches;$caches->[-1]->absorb($last)if$keep}}sub type {return$Test::Deep::Expects ? "expects" : "normal"}1;
TEST_DEEP_CACHE

$fatpacked{"Test/Deep/Cache/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CACHE_SIMPLE';
  use strict;use warnings;package Test::Deep::Cache::Simple;use Carp qw(confess);use Scalar::Util qw(refaddr);BEGIN {if (grep /^weaken$/,@Scalar::Util::EXPORT_FAIL){*weaken=sub {}}else {Scalar::Util->import('weaken')}}sub new {my$pkg=shift;my$self=bless {},$pkg;return$self}sub add {my$self=shift;my ($d1,$d2)=@_;{local$SIG{__DIE__};local $@;eval{weaken($d1)};eval{weaken($d2)}}$self->{fn_get_key(@_)}=[$d1,$d2]}sub cmp {my$self=shift;my$key=fn_get_key(@_);my$pair=$self->{$key};if (ref($pair->[0])and ref($pair->[1])){return 1}else {delete$self->{$key};return 0}}sub absorb {my$self=shift;my$other=shift;@{$self}{keys %$other}=values %$other}sub fn_get_key {return join(",",sort (map {refaddr($_)}@_))}1;
TEST_DEEP_CACHE_SIMPLE

$fatpacked{"Test/Deep/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CLASS';
  use strict;use warnings;package Test::Deep::Class;use Test::Deep::Cmp;sub init {my$self=shift;my$snobby=shift;my$val=shift;$self->{snobby}=$snobby;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;local$Test::Deep::Snobby=$self->{snobby};Test::Deep::wrap($self->{val})->descend($got)}1;
TEST_DEEP_CLASS

$fatpacked{"Test/Deep/Cmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CMP';
  use strict;use warnings;package Test::Deep::Cmp;use overload '&'=>\&make_all,'|'=>\&make_any,'""'=>\&string,fallback=>1,;use Scalar::Util ();sub import {my$pkg=shift;my$callpkg=caller();if ($callpkg =~ /^Test::Deep::/){no strict 'refs';push @{$callpkg."::ISA"},$pkg}}sub new {my$pkg=shift;my$self=bless {},$pkg;$self->init(@_);return$self}sub init {}sub make_all {my ($e1,$e2)=@_;return Test::Deep::all($e1,$e2)}sub make_any {my ($e1,$e2)=@_;return Test::Deep::any($e1,$e2)}sub cmp {my ($a1,$a2,$rev)=@_;($a1,$a2)=($a2,$a1)if$rev;return (overload::StrVal($a1)cmp overload::StrVal($a2))}sub string {my$self=shift;return overload::StrVal($self)}sub render_stack {my$self=shift;my$var=shift;return$var}sub renderExp {my$self=shift;return$self->renderGot($self->{val})}sub renderGot {my$self=shift;return Test::Deep::render_val(@_)}sub reset_arrow {return 1}sub data {my$self=shift;return$Test::Deep::Stack->getLast}1;
TEST_DEEP_CMP

$fatpacked{"Test/Deep/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CODE';
  use strict;use warnings;package Test::Deep::Code;use Test::Deep::Cmp;sub init {my$self=shift;my$code=shift || die "No coderef supplied";$self->{code}=$code}sub descend {my$self=shift;my$got=shift;my ($ok,$diag)=&{$self->{code}}($got);$self->data->{diag}=$diag;return$ok}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$error=$last->{diag};my$data=Test::Deep::render_val($last->{got});my$diag=<<EOM;if (defined($error)){$diag .= <<EOM}else {$diag .= <<EOM}return$diag}1;
  Ran coderef at $where on
  
  $data
  EOM
  and it said
  $error
  EOM
  it failed but it didn't say why.
  EOM
TEST_DEEP_CODE

$fatpacked{"Test/Deep/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASH';
  use strict;use warnings;package Test::Deep::Hash;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$data=$self->data;return 0 unless Test::Deep::descend($got,$self->hash_keys($exp));return 0 unless$self->test_class($got);return Test::Deep::descend($got,$self->hash_elements($exp))}sub hash_elements {require Test::Deep::HashElements;my$self=shift;return Test::Deep::HashElements->new(@_)}sub hash_keys {require Test::Deep::HashKeys;my$self=shift;my$exp=shift;return Test::Deep::HashKeys->new(keys %$exp)}sub reset_arrow {return 0}package Test::Deep::SuperHash;use base 'Test::Deep::Hash';sub hash_elements {require Test::Deep::HashElements;my$self=shift;return Test::Deep::SuperHashElements->new(@_)}sub hash_keys {require Test::Deep::HashKeys;my$self=shift;my$exp=shift;return Test::Deep::SuperHashKeys->new(keys %$exp)}package Test::Deep::SubHash;use base 'Test::Deep::Hash';sub hash_elements {require Test::Deep::HashElements;my$self=shift;return Test::Deep::SubHashElements->new(@_)}sub hash_keys {require Test::Deep::HashKeys;my$self=shift;my$exp=shift;return Test::Deep::SubHashKeys->new(keys %$exp)}1;
TEST_DEEP_HASH

$fatpacked{"Test/Deep/HashEach.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHEACH';
  use strict;use warnings;package Test::Deep::HashEach;use Test::Deep::Cmp;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my%exp;@exp{keys %$got}=($self->{val})x (keys %$got);return Test::Deep::descend($got,\%exp)}1;
TEST_DEEP_HASHEACH

$fatpacked{"Test/Deep/HashElements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHELEMENTS';
  use strict;use warnings;package Test::Deep::HashElements;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$data=$self->data;my$master=$self->getMaster($got,$exp);for my$key (keys %$master){$data->{index}=$key;my$got_elem=exists$got->{$key}? $got->{$key}: $Test::Deep::DNE;my$exp_elem=exists$exp->{$key}? $exp->{$key}: $Test::Deep::DNE;next if Test::Deep::descend($got_elem,$exp_elem);return 0}return 1}sub getMaster {my$self=shift;my ($got,$exp)=@_;return keys %$got > keys %$exp ? $got : $exp}sub render_stack {my$self=shift;my ($var,$data)=@_;$var .= "->" unless$Test::Deep::Stack->incArrow;$var .= '{"'.quotemeta($data->{index}).'"}';return$var}sub reset_arrow {return 0}package Test::Deep::SuperHashElements;use base 'Test::Deep::HashElements';sub getMaster {my$self=shift;my ($got,$exp)=@_;return$exp}package Test::Deep::SubHashElements;use base 'Test::Deep::HashElements';sub getMaster {my$self=shift;my ($got,$exp)=@_;return$got}1;
TEST_DEEP_HASHELEMENTS

$fatpacked{"Test/Deep/HashKeys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHKEYS';
  use strict;use warnings;package Test::Deep::HashKeys;use Test::Deep::Ref;sub init {my$self=shift;my%keys;@keys{@_}=();$self->{val}=\%keys;$self->{keys}=[sort @_]}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless$self->test_reftype($got,"HASH");return Test::Deep::descend($got,$self->hashkeysonly($exp))}sub hashkeysonly {require Test::Deep::HashKeysOnly;my$self=shift;my$exp=shift;return Test::Deep::HashKeysOnly->new(keys %$exp)}package Test::Deep::SuperHashKeys;use base 'Test::Deep::HashKeys';sub hashkeysonly {require Test::Deep::HashKeysOnly;my$self=shift;my$exp=shift;return Test::Deep::SuperHashKeysOnly->new(keys %$exp)}package Test::Deep::SubHashKeys;use base 'Test::Deep::HashKeys';sub hashkeysonly {require Test::Deep::HashKeysOnly;my$self=shift;my$exp=shift;return Test::Deep::SubHashKeysOnly->new(keys %$exp)}1;
TEST_DEEP_HASHKEYS

$fatpacked{"Test/Deep/HashKeysOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHKEYSONLY';
  use strict;use warnings;package Test::Deep::HashKeysOnly;use Test::Deep::Ref;sub init {my$self=shift;my%keys;@keys{@_}=();$self->{val}=\%keys;$self->{keys}=[sort @_]}sub descend {my$self=shift;my$hash=shift;my$data=$self->data;my$exp=$self->{val};my%got;@got{keys %$hash}=();my@missing;my@extra;while (my ($key,$value)=each %$exp){if (exists$got{$key}){delete$got{$key}}else {push(@missing,$key)}}my@diags;if (@missing and (not $self->ignoreMissing)){push(@diags,"Missing: ".nice_list(\@missing))}if (%got and (not $self->ignoreExtra)){push(@diags,"Extra: ".nice_list([keys%got]))}if (@diags){$data->{diag}=join("\n",@diags);return 0}return 1}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$type=$self->{IgnoreDupes}? "Set" : "Bag";my$error=$last->{diag};my$diag=<<EOM;return$diag}sub nice_list {my$list=shift;return join(", ",(map {"'$_'"}sort @$list),)}sub ignoreMissing {return 0}sub ignoreExtra {return 0}package Test::Deep::SuperHashKeysOnly;use base 'Test::Deep::HashKeysOnly';sub ignoreMissing {return 0}sub ignoreExtra {return 1}package Test::Deep::SubHashKeysOnly;use base 'Test::Deep::HashKeysOnly';sub ignoreMissing {return 1}sub ignoreExtra {return 0}1;
  Comparing hash keys of $where
  $error
  EOM
TEST_DEEP_HASHKEYSONLY

$fatpacked{"Test/Deep/Ignore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_IGNORE';
  use strict;use warnings;package Test::Deep::Ignore;use Test::Deep::Cmp;my$Singleton=__PACKAGE__->SUPER::new;sub new {return$Singleton}sub descend {return 1}1;
TEST_DEEP_IGNORE

$fatpacked{"Test/Deep/Isa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ISA';
  use strict;use warnings;package Test::Deep::Isa;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;return Scalar::Util::blessed($got)? $got->isa($self->{val}): ref($got)eq $self->{val}}sub diag_message {my$self=shift;my$where=shift;return "Checking class of $where with isa()"}sub renderExp {my$self=shift;return "blessed into or ref of type '$self->{val}'"}1;
TEST_DEEP_ISA

$fatpacked{"Test/Deep/ListMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_LISTMETHODS';
  use strict;use warnings;package Test::Deep::ListMethods;use base 'Test::Deep::Methods';sub call_method {my$self=shift;return [$self->SUPER::call_method(@_)]}sub render_stack {my$self=shift;my$var=$self->SUPER::render_stack(@_);return "[$var]"}1;
TEST_DEEP_LISTMETHODS

$fatpacked{"Test/Deep/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_MM';
  use strict;use warnings;package Test::Deep::MM;sub import {my$self=shift;my ($pkg)=caller();my$mpkg=$pkg."::Methods";for my$attr (@_){if ($attr =~ /^[a-z]/){no strict 'refs';*{$mpkg."::$attr"}=\&{$attr}}else {my$get_name=$mpkg."::get$attr";my$set_name=$mpkg."::set$attr";my$get_sub=sub {return $_[0]->{$attr}};my$set_sub=sub {return $_[0]->{$attr}=$_[1]};{no strict 'refs';*$get_name=$get_sub;*$set_name=$set_sub;push(@{$pkg."::ISA"},$mpkg)}}}}sub new {my$pkg=shift;my$self=bless {},$pkg;$self->init(@_);return$self}sub init {my$self=shift;while (@_){my$name=shift || confess("No name");my$method="set$name";$self->$method(shift)}}1;
TEST_DEEP_MM

$fatpacked{"Test/Deep/Methods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_METHODS';
  use strict;use warnings;package Test::Deep::Methods;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;my@methods;while (@_){my$name=shift;my$value=shift;push(@methods,[ref($name)? $name : [$name ],$value ])}$self->{methods}=\@methods}sub descend {my$self=shift;my$got=shift;my$data=$self->data;for my$method (@{$self->{methods}}){$data->{method}=$method;my ($call,$exp_res)=@$method;my ($name,@args)=@$call;local $@;my$got_res;if (!eval {$got_res=$self->call_method($got,$call);1}){die $@ unless $@ =~ /\ACan't locate object method "\Q$name"/;$got_res=$Test::Deep::DNE}next if Test::Deep::descend($got_res,$exp_res);return 0}return 1}sub call_method {my$self=shift;my ($got,$call)=@_;my ($name,@args)=@$call;return$got->$name(@args)}sub render_stack {my$self=shift;my ($var,$data)=@_;my$method=$data->{method};my ($call,$expect)=@$method;my ($name,@args)=@$call;my$args=@args ? "(".join(", ",@args).")" : "";$var .= "->$name$args";return$var}1;
TEST_DEEP_METHODS

$fatpacked{"Test/Deep/NoTest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_NOTEST';
  use strict;use warnings;package Test::Deep::NoTest;our$NoTest;{local$NoTest=1;require Test::Deep}sub import {my$import=Test::Deep->can("import");my$pkg=shift;unshift(@_,"Test::Deep");goto &$import}1;
TEST_DEEP_NOTEST

$fatpacked{"Test/Deep/None.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_NONE';
  use strict;use warnings;package Test::Deep::None;use Test::Deep::Cmp;sub init {my$self=shift;my@list=map {eval {$_->isa('Test::Deep::None')}? @{$_->{val}}: $_}@_;$self->{val}=\@list}sub descend {my$self=shift;my$got=shift;for my$cmp (@{$self->{val}}){return 0 if Test::Deep::eq_deeply_cache($got,$cmp)}return 1}sub renderExp {my$self=shift;my@expect=map {;Test::Deep::wrap($_)}@{$self->{val}};my$things=join(", ",map {$_->renderExp}@expect);return "None of ( $things )"}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$got=$self->renderGot($last->{got});my$exp=$self->renderExp;my$diag=<<EOM;$diag =~ s/\n+$/\n/;return$diag}1;
  Comparing $where with None
  got      : $got
  expected : $exp
  EOM
TEST_DEEP_NONE

$fatpacked{"Test/Deep/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_NUMBER';
  use strict;use warnings;package Test::Deep::Number;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;$self->{val}=shift(@_)+ 0;$self->{tolerance}=shift}sub descend {my$self=shift;my$got=shift;$self->data->{got_string}=$got;{no warnings 'numeric';$got += 0}$self->data->{got}=$got;if (defined(my$tolerance=$self->{tolerance})){return abs($got - $self->{val})<= $tolerance}else {return$got==$self->{val}}}sub diag_message {my$self=shift;my$where=shift;return "Comparing $where as a number"}sub renderGot {my$self=shift;my$val=shift;my$got_string=$self->data->{got_string};if ("$val" ne "$got_string"){$got_string=$self->SUPER::renderGot($got_string);return "$val ($got_string)"}else {return$val}}sub renderExp {my$self=shift;my$exp=$self->{val};if (defined(my$tolerance=$self->{tolerance})){return "$exp +/- $tolerance"}else {return$exp}}1;
TEST_DEEP_NUMBER

$fatpacked{"Test/Deep/Obj.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_OBJ';
  use strict;use warnings;package Test::Deep::Obj;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;return Scalar::Util::blessed($got)&& $got->isa($self->{val})}sub diag_message {my$self=shift;my$where=shift;return "Checking class of $where with isa()"}sub renderExp {my$self=shift;return "blessed into '$self->{val}' or subclass of '$self->{val}'"}1;
TEST_DEEP_OBJ

$fatpacked{"Test/Deep/Ref.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REF';
  use strict;use warnings;package Test::Deep::Ref;use Test::Deep::Cmp;use Scalar::Util qw(blessed);sub test_class {my$self=shift;my$got=shift;my$exp=$self->{val};if ($Test::Deep::Snobby){return Test::Deep::descend($got,Test::Deep::blessed(blessed($exp)))}else {return 1}}sub test_reftype {my$self=shift;my$got=shift;my$reftype=shift;return Test::Deep::descend($got,Test::Deep::reftype($reftype))}1;
TEST_DEEP_REF

$fatpacked{"Test/Deep/RefType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REFTYPE';
  use strict;use warnings;package Test::Deep::RefType;use Test::Deep::Cmp;use Scalar::Util qw(reftype);sub init {my$self=shift;$self->{val}=shift}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$reftype=reftype($got);return Test::Deep::descend($reftype,Test::Deep::shallow($exp))}sub render_stack {my$self=shift;my$var=shift;return "reftype($var)"}sub renderGot {my$self=shift;my$got=shift;$self->SUPER::renderGot(reftype($got))}1;
TEST_DEEP_REFTYPE

$fatpacked{"Test/Deep/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXP';
  use strict;use warnings;package Test::Deep::Regexp;use Test::Deep::Cmp;use Test::Deep::RegexpMatches;sub init {my$self=shift;my$val=shift;$val=ref$val ? $val : qr/$val/;$self->{val}=$val;if (my$matches=shift){$self->{matches}=Test::Deep::regexpmatches($matches,$val);$self->{flags}=shift || ""}}sub descend {my$self=shift;my$got=shift;my$re=$self->{val};if (my$match_exp=$self->{matches}){my$flags=$self->{flags};my@match_got;if ($flags eq "g"){@match_got=$got =~ /$re/g}else {@match_got=$got =~ /$re/}if (@match_got){return Test::Deep::descend(\@match_got,$match_exp)}else {return 0}}else {return ($got =~ $re)? 1 : 0}}sub diag_message {my$self=shift;my$where=shift;return "Using Regexp on $where"}sub render_stack1 {my$self=shift;my$stack=shift;return "($stack =~ $self->{regex})"}sub renderExp {my$self=shift;return "$self->{val}"}sub renderGot {my$self=shift;my$got=shift;if (defined (my$class=Scalar::Util::blessed($got))){my$ostr=qq{$got};if ($ostr ne overload::StrVal($got)){return qq{'$ostr' (instance of $class)}}}return Test::Deep::render_val($got)}1;
TEST_DEEP_REGEXP

$fatpacked{"Test/Deep/RegexpMatches.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPMATCHES';
  use strict;use warnings;package Test::Deep::RegexpMatches;use Test::Deep::Array;use base 'Test::Deep::Array';use Scalar::Util qw(blessed);sub init {my$self=shift;my$val=shift;$val=Test::Deep::array($val)unless blessed($val)and $val->isa("Test::Deep::Cmp");$self->{val}=$val;$self->{regex}=shift}sub descend {my$self=shift;my$got=shift;return Test::Deep::descend($got,$self->{val})}sub render_stack {my$self=shift;my$stack=shift;$stack="[$stack =~ $self->{regex}]";return$stack}sub reset_arrow {return 1}1;
TEST_DEEP_REGEXPMATCHES

$fatpacked{"Test/Deep/RegexpOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPONLY';
  use strict;use warnings;package Test::Deep::RegexpOnly;use Test::Deep::Cmp;use Scalar::Util qw(blessed);sub init {my$self=shift;my$val=shift;$val=ref$val ? $val : qr/$val/;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$re=$self->{val};return$got =~ $self->{val}? 1 : 0}sub diag_message {my$self=shift;my$where=shift;return "Using Regexp on $where"}sub renderExp {my$self=shift;return "$self->{val}"}1;
TEST_DEEP_REGEXPONLY

$fatpacked{"Test/Deep/RegexpRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPREF';
  use strict;use warnings;package Test::Deep::RegexpRef;use Test::Deep::Ref;use Test::Deep::RegexpVersion;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};if ($Test::Deep::RegexpVersion::OldStyle){return 0 unless$self->test_class($got,"Regexp");return 0 unless$self->test_reftype($got,"SCALAR")}else {return 0 unless$self->test_reftype($got,"REGEXP")}return Test::Deep::descend($got,Test::Deep::regexprefonly($exp))}sub renderGot {my$self=shift;return shift().""}1;
TEST_DEEP_REGEXPREF

$fatpacked{"Test/Deep/RegexpRefOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPREFONLY';
  use strict;use warnings;package Test::Deep::RegexpRefOnly;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return$got eq $exp}sub render_stack {my$self=shift;my ($var,$data)=@_;return "m/$var/"}sub renderGot {my$self=shift;return shift().""}1;
TEST_DEEP_REGEXPREFONLY

$fatpacked{"Test/Deep/RegexpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPVERSION';
  use strict;use warnings;package Test::Deep::RegexpVersion;our$OldStyle=($] < 5.011);1;
TEST_DEEP_REGEXPVERSION

$fatpacked{"Test/Deep/ScalarRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SCALARREF';
  use strict;use warnings;package Test::Deep::ScalarRef;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless$self->test_class($got);return 0 unless$self->test_reftype($got,Scalar::Util::reftype($exp));return Test::Deep::descend($got,Test::Deep::scalarrefonly($exp))}1;
TEST_DEEP_SCALARREF

$fatpacked{"Test/Deep/ScalarRefOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SCALARREFONLY';
  use strict;use warnings;package Test::Deep::ScalarRefOnly;use Test::Deep::Cmp;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return Test::Deep::descend($$got,$$exp)}sub render_stack {my$self=shift;my ($var,$data)=@_;return "\${$var}"}1;
TEST_DEEP_SCALARREFONLY

$fatpacked{"Test/Deep/Set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SET';
  use strict;use warnings;package Test::Deep::Set;use Test::Deep::Cmp;sub init {my$self=shift;$self->{IgnoreDupes}=shift;$self->{SubSup}=shift;$self->{val}=[];$self->add(@_)}sub descend {my$self=shift;my$d1=shift;my$d2=$self->{val};my$IgnoreDupes=$self->{IgnoreDupes};my$data=$self->data;my$SubSup=$self->{SubSup};my$type=$IgnoreDupes ? "Set" : "Bag";my$diag;if (ref$d1 ne 'ARRAY'){my$got=Test::Deep::render_val($d1);$diag=<<EOM}if (not $diag){my@got=@$d1;my@found;my@missing;for my$expect (@$d2){my$found=0;for (my$i=$#got;$i >= 0;$i--){if (Test::Deep::eq_deeply_cache($got[$i],$expect)){$found=1;push(@found,$expect);splice(@got,$i,1);last unless$IgnoreDupes}}push(@missing,$expect)unless$found}my@diags;if (@missing and $SubSup ne "sub" && $SubSup ne "none"){push(@diags,"Missing: ".nice_list(\@missing))}if (@got and $SubSup ne "sup" && $SubSup ne "none"){my$got=__PACKAGE__->new($IgnoreDupes,"",@got);push(@diags,"Extra: ".nice_list($got->{val}))}if (@found and $SubSup eq "none"){my$found=__PACKAGE__->new($IgnoreDupes,"",@found);push(@diags,"Extra: ".nice_list($found->{val}))}$diag=join("\n",@diags)}if ($diag){$data->{diag}=$diag;return 0}else {return 1}}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$type=$self->{IgnoreDupes}? "Set" : "Bag";$type="Sub$type" if$self->{SubSup}eq "sub";$type="Super$type" if$self->{SubSup}eq "sup";$type="NoneOf" if$self->{SubSup}eq "none";my$error=$last->{diag};my$diag=<<EOM;return$diag}sub add {my$self=shift;my@array=@_;my$IgnoreDupes=$self->{IgnoreDupes};my$already=$self->{val};local$Test::Deep::Expects=1;for my$new_elem (@array){my$want_push=1;my$push_this=$new_elem;for my$old_elem (@$already){if (Test::Deep::eq_deeply($new_elem,$old_elem)){$push_this=$old_elem;$want_push=!$IgnoreDupes;last}}push(@$already,$push_this)if$want_push}@$already=sort {(defined$a ? $a : "")cmp (defined$b ? $b : "")}@$already}sub nice_list {my$list=shift;my@scalars=grep!ref $_,@$list;my$refs=grep ref $_,@$list;my@ref_string="$refs reference" if$refs;$ref_string[0].= "s" if$refs > 1;return join(", ",(map {Test::Deep::render_val($_)}sort {(defined$a ? $a : "")cmp (defined$b ? $b : "")}@scalars),@ref_string)}sub compare {my$self=shift;my$other=shift;return 0 if$self->{IgnoreDupes}!=$other->{IgnoreDupes};return Test::Deep::descend($self->{val},$other->{val})}1;
  got    : $got
  expect : An array to use as a $type
  EOM
  Comparing $where as a $type
  $error
  EOM
TEST_DEEP_SET

$fatpacked{"Test/Deep/Shallow.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SHALLOW';
  use strict;use warnings;package Test::Deep::Shallow;use Test::Deep::Cmp;use Scalar::Util qw(refaddr);sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$ok;if (!defined$got and!defined$exp){$ok=1}elsif (defined$got xor defined$exp){$ok=0}elsif (ref$got and ref$exp){$ok=refaddr($got)==refaddr($exp)}elsif (ref$got xor ref$exp){$ok=0}else {$ok=$got eq $exp}return$ok}1;
TEST_DEEP_SHALLOW

$fatpacked{"Test/Deep/Stack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_STACK';
  use strict;use warnings;package Test::Deep::Stack;use Carp qw(confess);use Scalar::Util;use Test::Deep::MM qw(new init Stack Arrow);sub init {my$self=shift;$self->SUPER::init(@_);$self->setStack([])unless$self->getStack}sub push {my$self=shift;push(@{$self->getStack},@_)}sub pop {my$self=shift;return pop @{$self->getStack}}sub render {my$self=shift;my$var=shift;my$stack=$self->getStack;$self->setArrow(0);for my$data (@$stack){my$exp=$data->{exp};if (Scalar::Util::blessed($exp)and $exp->isa("Test::Deep::Cmp")){$var=$exp->render_stack($var,$data);$self->setArrow(0)if$exp->reset_arrow}else {confess "Don't know how to render '$exp'"}}return$var}sub getLast {my$self=shift;return$self->getStack->[-1]}sub incArrow {my$self=shift;my$a=$self->getArrow;$self->setArrow($a + 1);return$a}sub length {my$self=shift;return @{$self->getStack}+ 0}1;
TEST_DEEP_STACK

$fatpacked{"Test/Deep/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_STRING';
  use strict;use warnings;package Test::Deep::String;use Test::Deep::Cmp;sub init {my$self=shift;$self->{val}=shift}sub descend {my$self=shift;my$got=shift()."";$self->data->{got}=$got;return$got eq $self->{val}}sub diag_message {my$self=shift;my$where=shift;return "Comparing $where as a string"}1;
TEST_DEEP_STRING

$fatpacked{"Test/Fatal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_FATAL';
  use strict;use warnings;package Test::Fatal;$Test::Fatal::VERSION='0.014';use Carp ();use Try::Tiny 0.07;use Exporter 5.57 'import';our@EXPORT=qw(exception);our@EXPORT_OK=qw(exception success dies_ok lives_ok);our ($REAL_TBL,$REAL_CALCULATED_TBL)=(1,1);sub exception (&) {my$code=shift;return try {my$incremented=$Test::Builder::Level - $REAL_CALCULATED_TBL;local$Test::Builder::Level=$REAL_CALCULATED_TBL;if ($incremented){$Test::Builder::Level += 5;for my$i (1..$incremented){my$caller=caller($Test::Builder::Level - 2);if ($caller eq __PACKAGE__){$Test::Builder::Level=$Test::Builder::Level + 5}else {$Test::Builder::Level=$Test::Builder::Level + 1}}}local$REAL_CALCULATED_TBL=$Test::Builder::Level;$code->();return undef}catch {return $_ if $_;my$problem=defined $_ ? 'false' : 'undef';Carp::confess("$problem exception caught by Test::Fatal::exception")}}sub success (&;@) {my$code=shift;return finally(sub {return if @_;$code->()},@_)}my$Tester;sub dies_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||= Test::Builder->new;my$ok=$Tester->ok(exception(\&$code),$name);$ok or $Tester->diag("expected an exception but none was raised");return$ok}sub lives_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||= Test::Builder->new;my$ok=$Tester->ok(!exception(\&$code),$name);$ok or $Tester->diag("expected return but an exception was raised");return$ok}1;
TEST_FATAL

$fatpacked{"Test/TempDir/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TEMPDIR_TINY';
  use 5.006002;use strict;use warnings;package Test::TempDir::Tiny;our$VERSION='0.016';use Exporter 5.57 qw/import/;our@EXPORT=qw/tempdir in_tempdir/;use Carp qw/confess/;use Cwd qw/abs_path/;use Errno qw/EEXIST ENOENT/;{no warnings 'numeric';use File::Path 2.01 qw/remove_tree/}use File::Spec::Functions qw/catdir/;use File::Temp;my ($ROOT_DIR,$TEST_DIR,%COUNTER);my ($ORIGINAL_PID,$ORIGINAL_CWD,$TRIES,$DELAY,$SYSTEM_TEMP)=($$,abs_path("."),100,50 / 1000,0);sub _untaint {my$thing=shift;($thing)=$thing =~ /^(.*)$/;return$thing}sub tempdir {my$label=defined($_[0])? $_[0]: 'default';$label =~ tr{a-zA-Z0-9_-}{_}cs;_init()unless$ROOT_DIR && $TEST_DIR;my$suffix=++$COUNTER{$label};my$subdir=catdir($TEST_DIR,"${label}_${suffix}");mkdir _untaint($subdir)or confess("Couldn't create $subdir: $!");return$subdir}sub in_tempdir {my ($label,$code)=@_;my$wantarray=wantarray;my$cwd=abs_path(".");my$tempdir=tempdir($label);chdir$tempdir or die "Can't chdir to '$tempdir'";my (@ret);my$ok=eval {$code->($tempdir);1};my$err=$@;chdir$cwd or chdir "/" or die "Can't chdir to either '$cwd' or '/'";confess($err || "error from eval was lost")if!$ok;return}sub _inside_t_dir {-d "../t" && abs_path(".")eq abs_path("../t")}sub _init {my$DEFAULT_ROOT=catdir($ORIGINAL_CWD,"tmp");if (-d 't' && (-w $DEFAULT_ROOT || -w '.')){$ROOT_DIR=$DEFAULT_ROOT}elsif (_inside_t_dir()&& (-w '../$DEFAULT_ROOT' || -w '..')){$ROOT_DIR=catdir($ORIGINAL_CWD,"..","tmp")}else {$ROOT_DIR=File::Temp::tempdir(TMPDIR=>1,CLEANUP=>1);$SYSTEM_TEMP=1}(my$dirname=$0)=~ tr{:\\/.}{_};$TEST_DIR=catdir($ROOT_DIR,$dirname);if (-d $TEST_DIR){remove_tree(_untaint($TEST_DIR),{safe=>0,keep_root=>1 });return}for my$n (1 .. $TRIES){if (!mkdir(_untaint($ROOT_DIR))){confess("Couldn't create $ROOT_DIR: $!")unless $!==EEXIST}$ROOT_DIR=abs_path($ROOT_DIR);if (mkdir _untaint($TEST_DIR)){$TEST_DIR=abs_path($TEST_DIR);return}if ($!!=ENOENT){confess("Couldn't create $TEST_DIR: $!")}if (-e $ROOT_DIR &&!-d _){confess("$ROOT_DIR is not a directory")}select(undef,undef,undef,$DELAY)if$n < $TRIES}warn "Couldn't create $TEST_DIR in $TRIES tries.\n" ."Using a regular tempdir instead.\n";$TEST_DIR=File::Temp::tempdir(TMPDIR=>1,CLEANUP=>1);return}sub _cleanup {return if$ENV{PERL_TEST_TEMPDIR_TINY_NOCLEANUP};if ($ROOT_DIR && -d $ROOT_DIR){if ($SYSTEM_TEMP or not $?){chdir _untaint($ORIGINAL_CWD)or chdir "/" or warn "Can't chdir to '$ORIGINAL_CWD' or '/'. Cleanup might fail.";remove_tree(_untaint($TEST_DIR),{safe=>0 })if -d $TEST_DIR}rmdir _untaint($ROOT_DIR)unless -l $ROOT_DIR}}sub _root_dir {return$ROOT_DIR}END {if ($$==$ORIGINAL_PID){if ($] lt "5.008000"){*Test::TempDir::Tiny::_CLEANER::DESTROY=\&_cleanup;*blob=bless({},'Test::TempDir::Tiny::_CLEANER')}else {require B;push @{B::end_av()->object_2svref},\&_cleanup}}}1;
TEST_TEMPDIR_TINY

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.28';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}my$caller=caller;_subname("${caller}::try {...} "=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map {Try::Tiny::ScopeGuard->_new($_)}@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;my$caller=caller;_subname("${caller}::catch {...} "=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;my$caller=caller;_subname("${caller}::finally {...} "=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BOOLEAN';
  use strict;use warnings;package boolean;our$VERSION='0.46';my ($true,$false);use overload '""'=>sub {${$_[0]}},'!'=>sub {${$_[0]}? $false : $true},fallback=>1;use base 'Exporter';@boolean::EXPORT=qw(true false boolean);@boolean::EXPORT_OK=qw(isTrue isFalse isBoolean);%boolean::EXPORT_TAGS=(all=>[@boolean::EXPORT,@boolean::EXPORT_OK],test=>[qw(isTrue isFalse isBoolean)],);sub import {my@options=grep $_ ne '-truth',@_;$_[0]->truth if@options!=@_;@_=@options;goto&Exporter::import}my ($true_val,$false_val,$bool_vals);BEGIN {my$t=1;my$f=0;$true=do {bless \$t,'boolean'};$false=do {bless \$f,'boolean'};$true_val=overload::StrVal($true);$false_val=overload::StrVal($false);$bool_vals={$true_val=>1,$false_val=>1}}sub CLONE {$true_val=overload::StrVal($true);$false_val=overload::StrVal($false);$bool_vals={$true_val=>1,$false_val=>1}}sub true() {$true}sub false() {$false}sub boolean($) {die "Not enough arguments for boolean::boolean" if scalar(@_)==0;die "Too many arguments for boolean::boolean" if scalar(@_)> 1;return not(defined $_[0])? false : "$_[0]" ? $true : $false}sub isTrue($) {not(defined $_[0])? false : (overload::StrVal($_[0])eq $true_val)? true : false}sub isFalse($) {not(defined $_[0])? false : (overload::StrVal($_[0])eq $false_val)? true : false}sub isBoolean($) {not(defined $_[0])? false : (exists$bool_vals->{overload::StrVal($_[0])})? true : false}sub truth {die "-truth not supported on Perl 5.22 or later" if $] >= 5.021005;&Internals::SvREADONLY(\!!0,0);&Internals::SvREADONLY(\!!1,0);${\!!0}=$false;${\!!1}=$true;&Internals::SvREADONLY(\!!0,1);&Internals::SvREADONLY(\!!1,1)}sub TO_JSON {${$_[0]}? \1 : \0}1;
BOOLEAN

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use Carp qw(croak);
use Docopt;
use App::mimi;

my $opts = docopt();

my $command;
for (qw(check setup migrate fix set)) {
    if ($opts->{$_}) {
        $command = $_;
        last;
    }
}

App::mimi->new(
    dsn               => $opts->{'--dsn'},
    schema            => $opts->{'--schema'},
    initial_schema    => $opts->{'--initial-schema'},
    initial_migration => $opts->{'--initial-migration'},
    dry_run           => $opts->{'--dry-run'},
    verbose           => $opts->{'--verbose'},
    setup             => $opts->{'--setup'},
    migration         => $opts->{'<migration>'}
)->$command;

__END__

=pod

=head1 NAME

mimi - dbi migrations

=head1 SYNOPSIS

  mimi check   --dsn=<dsn>
  mimi migrate --dsn=<dsn> --schema=<directory> [--setup] [--verbose] [--dry-run]
  mimi setup   --dsn=<dsn> [--initial-schema=<file>] [--initial-migration=<migration>] [--schema=<directory>] [--verbose] [--dry-run]
  mimi fix     --dsn=<dsn> [--verbose] [--dry-run]
  mimi set     --dsn=<dsn> <migration> [--verbose] [--dry-run]
  mimi -h | --help

  --dsn=<dsn>           DBI dsn string, 'dbi:SQLite:database.db' for example
  --schema=<directory>  Directory with migrations
  --dry-run             Do nothing, just show what's to be done
  --verbose             Be verbose
  -h --help             Show this screen.

=head1 DESCRIPTION

This is a migration script for small home projects. Despite of being small it's
still robust. This means that all the precautions are made to not to corrupt
your data.

=head2 Safety first

Every command has C<verbose> and C<dry-run> flags. Thus it is easy to check
first what's going to happen.

=head2 Check

    mimi check --dsn 'dbi:SQLite:database.db'

Check what's going on. Are migrations installed? What is the latest migration? Was there an error?

=head2 Setupping your database

    mimi setup --dsn 'dbi:SQLite:database.db'

This creates C<mimi> table in your database. This table is used as a journal for
migrations.

=head2 Migrations

    mimi migrate --dsn 'dbi:SQLite:database.db' --schema sql_files/

This will search C<sql_files> for C<*.sql> files, parse their names that usually
look like C<01add_column.sql>, C<02drop_table.sql> and so on. Then it will try
to find the last migration and run everything with a bigger number.

Using C<--setup> flag will setup migrations first if needed.

=head2 Failures and fixes

Failures do occur. Like you made a mistake in your migration (of course you
should run them on a local machine first!). C<mimi> will die but remember that
last migration was with error and won't let you run next migrations dying with:

    Error: Migrations are dirty. Last error was in migration 1:

        DBD::SQLite::db do failed: near "CREAT": syntax error

    After fixing the problem run <fix> command

After fixing the stuff, you either can C<fix> or C<set> the current migration
number manually:

    mimi fix --dsn '...'
    mimi set --dsn '...' 123

=head2 Additional checks

You will get descriptive errors when trying to do unexpected stuff, like running
migrations on a fresh database or supplying a directory without migration files.

=cut
