#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/mimi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MIMI';
  package App::mimi;use strict;use warnings;our$VERSION='0.03';use Carp qw(croak);use File::Spec;use File::Basename ();use DBI;use App::mimi::db;sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{dsn}=$params{dsn};$self->{schema}=$params{schema};$self->{dry_run}=$params{dry_run};$self->{verbose}=$params{verbose};$self->{migration}=$params{migration};$self->{dbh}=$params{dbh};return$self}sub setup {my$self=shift;my$db=$self->_build_db;die "Error: migrations table already exists\n" if$db->is_prepared;$self->_print("Creating migrations table");$db->prepare unless$self->_is_dry_run;return$self}sub migrate {my$self=shift;die "Error: Schema directory is required\n" unless$self->{schema}&& -d $self->{schema};my@schema_files=glob("$self->{schema}/*.sql");die "Error: No schema *.sql files found in '$self->{schema}'\n" unless@schema_files;my$db=$self->_build_db_prepared;my$last_migration=$db->fetch_last_migration;if ($last_migration && $last_migration->{status}ne 'success'){$last_migration->{error}||= 'Unknown error';die "Error: Migrations are dirty. " ."Last error was in migration $last_migration->{no}:\n\n" ."    $last_migration->{error}\n" ."After fixing the problem run <fix> command\n"}$self->_print("Found last migration $last_migration->{no}")if$last_migration;my@migrations;for my$file (@schema_files){my ($no,$name)=File::Basename::basename($file)=~ /^(\d+)(.*)$/;next unless$no && $name;$no=int($no);next if$last_migration && $no <= $last_migration->{no};my@sql=split /;/,$self->_slurp($file);push@migrations,{file=>$file,no=>$no,name=>$name,sql=>\@sql }}if (@migrations){my$dbh=$self->{dbh};for my$migration (@migrations){$self->_print("Migrating '$migration->{file}'");my$e;if (!$self->_is_dry_run){eval {$dbh->do($_)for @{$migration->{sql}|| []}}or do {$e=$@;$e =~ s{ at .*? line \d+.$}{}}}$self->_print("Creating migration: $migration->{no}");$db->create_migration(no=>$migration->{no},created=>time,status=>$e ? 'error' : 'success',error=>$e)unless$self->_is_dry_run;die "Error: $e\n" if$e}}else {$self->_print("Nothing to migrate")}return$self}sub check {my$self=shift;$self->{verbose}=1;my$db=$self->_build_db;if (!$db->is_prepared){$self->_print('Migrations are not installed')}else {my$last_migration=$db->fetch_last_migration;if (!defined$last_migration){$self->_print('No migrations found')}else {$self->_print(sprintf 'Last migration: %d (%s)',$last_migration->{no},$last_migration->{status});if (my$error=$last_migration->{error}){$self->_print("\n" .$error)}}}}sub fix {my$self=shift;my$db=$self->_build_db_prepared;my$last_migration=$db->fetch_last_migration;if (!$last_migration || $last_migration->{status}eq 'success'){$self->_print('Nothing to fix')}else {$self->_print("Fixing migration $last_migration->{no}");$db->fix_last_migration unless$self->_is_dry_run}}sub set {my$self=shift;my$db=$self->_build_db_prepared;$self->_print("Creating migration $self->{migration}");$db->create_migration(no=>$self->{migration},created=>time,status=>'success')unless$self->_is_dry_run}sub _build_db_prepared {my$self=shift;my$db=$self->_build_db;die "Error: Migrations table not found. Run <setup> command first\n" unless$db->is_prepared;return$db}sub _build_db {my$self=shift;my$dbh=$self->{dbh};if (!$dbh){$dbh=DBI->connect($self->{dsn},'','',{RaiseError=>1,PrintError=>0,PrintWarn=>0});$self->{dbh}=$dbh}return App::mimi::db->new(dbh=>$dbh)}sub _print {my$self=shift;return unless$self->_is_verbose;print 'DRY RUN: ' if$self->_is_dry_run;print @_,"\n"}sub _is_dry_run {$_[0]->{dry_run}}sub _is_verbose {$_[0]->{verbose}|| $_[0]->_is_dry_run}sub _slurp {my$self=shift;my ($file)=@_;open my$fh,'<',$file or croak $!;local $/;<$fh>}1;
APP_MIMI

$fatpacked{"App/mimi/db.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MIMI_DB';
  package App::mimi::db;use strict;use warnings;use Carp qw(croak);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{dbh}=$params{dbh}or croak 'dbh required';$self->{columns}=[qw/no created status error/];return$self}sub is_prepared {my$self=shift;local$SIG{__WARN__}=sub {};my$rv;eval {$rv=$self->{dbh}->do('SELECT 1 FROM mimi LIMIT 1')};return unless$rv;return 1}sub prepare {my$self=shift;my$driver=$self->{dbh}->{Driver}->{Name};if ($driver eq 'SQLite'){$self->{dbh}->do(<<'EOF')}elsif ($driver eq 'Pg'){$self->{dbh}->do(<<'EOF')}}sub fix_last_migration {my$self=shift;my$last_migration=$self->fetch_last_migration;return unless$last_migration;$self->{dbh}->do("UPDATE mimi SET status = 'success', error = '' WHERE id=$last_migration->{id}")or die $!;return$self}sub create_migration {my$self=shift;my (%migration)=@_;$migration{created}||= time;my$columns=join ',',keys%migration;my$values=join ',',map {"'$_'"}values%migration;$self->{dbh}->do("INSERT INTO mimi ($columns) VALUES ($values)")or die $!;return$self}sub fetch_last_migration {my$self=shift;my$sth=$self->{dbh}->prepare('SELECT id, no, created, status, error FROM mimi ORDER BY id DESC LIMIT 1');my$rv=$sth->execute or die $!;my$row=$sth->fetchall_arrayref->[0];return unless$row;my$migration={};for (qw/id no created status error/){$migration->{$_}=shift @$row}return$migration}1;
      CREATE TABLE mimi (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          created INTEGER NOT NULL,
          no INTEGER NOT NULL,
          status VARCHAR(32) NOT NULL,
          error VARCHAR(255)
      );
  EOF
      CREATE TABLE mimi (
          id serial PRIMARY KEY,
          created INTEGER NOT NULL,
          no INTEGER NOT NULL,
          status VARCHAR(32) NOT NULL,
          error VARCHAR(255)
      );
  EOF
APP_MIMI_DB

$fatpacked{"Bundle/DBI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BUNDLE_DBI';
  package Bundle::DBI;use strict;our$VERSION="0.03";1;
BUNDLE_DBI

$fatpacked{"Class/Accessor/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_ACCESSOR_LITE';
  package Class::Accessor::Lite;use strict;our$VERSION='0.03';sub croak {require Carp;Carp::croak(@_)}sub import {shift;my%args=@_;my$pkg=caller(0);my%key_ctor=(rw=>\&_mk_accessors,ro=>\&_mk_ro_accessors,wo=>\&_mk_wo_accessors,);for my$key (sort keys%key_ctor){if (defined$args{$key}){croak("value of the '$key' parameter should be an arrayref")unless ref($args{$key})eq 'ARRAY';$key_ctor{$key}->($pkg,@{$args{$key}})}}_mk_new($pkg)if$args{new};1}sub mk_new_and_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_new($pkg);_mk_accessors($pkg,@properties)}sub mk_new {my$pkg=caller(0);_mk_new($pkg)}sub mk_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_accessors($pkg,@properties)}sub mk_ro_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_ro_accessors($pkg,@properties)}sub mk_wo_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_wo_accessors($pkg,@properties)}sub _mk_new {my$pkg=shift;no strict 'refs';*{$pkg .'::new'}=__m_new($pkg)}sub _mk_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m($n)}}sub _mk_ro_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m_ro($pkg,$n)}}sub _mk_wo_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m_wo($pkg,$n)}}sub __m_new {my$pkg=shift;no strict 'refs';return sub {my$klass=shift;bless {(@_==1 && ref($_[0])eq 'HASH' ? %{$_[0]}: @_),},$klass}}sub __m {my$n=shift;sub {return $_[0]->{$n}if @_==1;return $_[0]->{$n}=$_[1]if @_==2;shift->{$n}=\@_}}sub __m_ro {my ($pkg,$n)=@_;sub {if (@_==1){return $_[0]->{$n}if @_==1}else {my$caller=caller(0);croak("'$caller' cannot access the value of '$n' on objects of class '$pkg'")}}}sub __m_wo {my ($pkg,$n)=@_;sub {if (@_==1){my$caller=caller(0);croak("'$caller' cannot alter the value of '$n' on objects of class '$pkg'")}else {return $_[0]->{$n}=$_[1]if @_==2;shift->{$n}=\@_}}}1;
CLASS_ACCESSOR_LITE

$fatpacked{"DBD/DBM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_DBM';
  require 5.008;use strict;package DBD::DBM;use base qw(DBD::File);use vars qw($VERSION $ATTRIBUTION $drh $methods_already_installed);$VERSION='0.03';$ATTRIBUTION='DBD::DBM by Jens Rehsack';sub driver ($;$) {my ($class,$attr)=@_;return$drh if ($drh);$attr->{Attribution}='DBD::DBM by Jens Rehsack';$drh=$class->SUPER::driver($attr);unless ($methods_already_installed++){DBD::DBM::st->install_method('dbm_schema')}return$drh}sub CLONE {undef$drh}package DBD::DBM::dr;$DBD::DBM::dr::imp_data_size=0;@DBD::DBM::dr::ISA=qw(DBD::File::dr);package DBD::DBM::db;$DBD::DBM::db::imp_data_size=0;@DBD::DBM::db::ISA=qw(DBD::File::db);use Carp qw/carp/;sub validate_STORE_attr {my ($dbh,$attrib,$value)=@_;if ($attrib eq "dbm_ext" or $attrib eq "dbm_lockfile"){(my$newattrib=$attrib)=~ s/^dbm_/f_/g;carp "Attribute '$attrib' is depreciated, use '$newattrib' instead" if ($^W);$attrib=$newattrib}return$dbh->SUPER::validate_STORE_attr($attrib,$value)}sub validate_FETCH_attr {my ($dbh,$attrib)=@_;if ($attrib eq "dbm_ext" or $attrib eq "dbm_lockfile"){(my$newattrib=$attrib)=~ s/^dbm_/f_/g;carp "Attribute '$attrib' is depreciated, use '$newattrib' instead" if ($^W);$attrib=$newattrib}return$dbh->SUPER::validate_FETCH_attr($attrib)}sub set_versions {my$this=$_[0];$this->{dbm_version}=$DBD::DBM::VERSION;return$this->SUPER::set_versions()}sub init_valid_attributes {my$dbh=shift;$dbh->{dbm_valid_attrs}={dbm_type=>1,dbm_mldbm=>1,dbm_cols=>1,dbm_version=>1,dbm_store_metadata=>1,dbm_berkeley_flags=>1,dbm_valid_attrs=>1,dbm_readonly_attrs=>1,dbm_meta=>1,dbm_tables=>1,};$dbh->{dbm_readonly_attrs}={dbm_version=>1,dbm_valid_attrs=>1,dbm_readonly_attrs=>1,dbm_meta=>1,};$dbh->{dbm_meta}="dbm_tables";return$dbh->SUPER::init_valid_attributes()}sub init_default_attributes {my ($dbh,$phase)=@_;$dbh->SUPER::init_default_attributes($phase);$dbh->{f_lockfile}='.lck';return$dbh}sub get_dbm_versions {my ($dbh,$table)=@_;$table ||= '';my$meta;my$class=$dbh->{ImplementorClass};$class =~ s/::db$/::Table/;$table and (undef,$meta)=$class->get_table_meta($dbh,$table,1);$meta or ($meta={}and $class->bootstrap_table_meta($dbh,$meta,$table));my$dver;my$dtype=$meta->{dbm_type};eval {$dver=$meta->{dbm_type}->VERSION();$dtype .= " ($dver)"};if ($meta->{dbm_mldbm}){$dtype .= ' + MLDBM';eval {$dver=MLDBM->VERSION();$dtype .= " ($dver)"};eval {my$ser_class="MLDBM::Serializer::" .$meta->{dbm_mldbm};my$ser_mod=$ser_class;$ser_mod =~ s|::|/|g;$ser_mod .= ".pm";require$ser_mod;$dver=$ser_class->VERSION();$dtype .= ' + ' .$ser_class;$dver and $dtype .= " ($dver)"}}return sprintf("%s using %s",$dbh->{dbm_version},$dtype)}package DBD::DBM::st;$DBD::DBM::st::imp_data_size=0;@DBD::DBM::st::ISA=qw(DBD::File::st);sub FETCH {my ($sth,$attr)=@_;if ($attr eq "NULLABLE"){my@colnames=$sth->sql_get_colnames();$attr eq "NULLABLE" and return [map {0}@colnames ]}return$sth->SUPER::FETCH($attr)}sub dbm_schema {my ($sth,$tname)=@_;return$sth->set_err($DBI::stderr,'No table name supplied!')unless$tname;my$tbl_meta=$sth->{Database}->func($tname,"f_schema","get_sql_engine_meta")or return$sth->set_err($sth->{Database}->err(),$sth->{Database}->errstr());return$tbl_meta->{$tname}->{f_schema}}package DBD::DBM::Statement;@DBD::DBM::Statement::ISA=qw(DBD::File::Statement);package DBD::DBM::Table;use Carp;use Fcntl;@DBD::DBM::Table::ISA=qw(DBD::File::Table);my$dirfext=$^O eq 'VMS' ? '.sdbm_dir' : '.dir';my%reset_on_modify=(dbm_type=>"dbm_tietype",dbm_mldbm=>"dbm_tietype",);__PACKAGE__->register_reset_on_modify(\%reset_on_modify);my%compat_map=((map {$_=>"dbm_$_"}qw(type mldbm store_metadata)),dbm_ext=>'f_ext',dbm_file=>'f_file',dbm_lockfile=>' f_lockfile',);__PACKAGE__->register_compat_map(\%compat_map);sub bootstrap_table_meta {my ($self,$dbh,$meta,$table)=@_;$meta->{dbm_type}||= $dbh->{dbm_type}|| 'SDBM_File';$meta->{dbm_mldbm}||= $dbh->{dbm_mldbm}if ($dbh->{dbm_mldbm});$meta->{dbm_berkeley_flags}||= $dbh->{dbm_berkeley_flags};defined$meta->{f_ext}or $meta->{f_ext}=$dbh->{f_ext};unless (defined($meta->{f_ext})){my$ext;if ($meta->{dbm_type}eq 'SDBM_File' or $meta->{dbm_type}eq 'ODBM_File'){$ext='.pag/r'}elsif ($meta->{dbm_type}eq 'NDBM_File'){if ($^O =~ /bsd/i or lc($^O)eq 'darwin'){$ext='.db/r'}elsif ($^O eq 'SunOS' or $^O eq 'Solaris' or $^O eq 'AIX'){$ext='.pag/r'}}defined($ext)and $meta->{f_ext}=$ext}$self->SUPER::bootstrap_table_meta($dbh,$meta,$table)}sub init_table_meta {my ($self,$dbh,$meta,$table)=@_;$meta->{f_dontopen}=1;unless (defined($meta->{dbm_tietype})){my$tie_type=$meta->{dbm_type};$INC{"$tie_type.pm"}or require "$tie_type.pm";$tie_type eq 'BerkeleyDB' and $tie_type='BerkeleyDB::Hash';if ($meta->{dbm_mldbm}){$INC{"MLDBM.pm"}or require "MLDBM.pm";$meta->{dbm_usedb}=$tie_type;$tie_type='MLDBM'}$meta->{dbm_tietype}=$tie_type}unless (defined($meta->{dbm_store_metadata})){my$store=$dbh->{dbm_store_metadata};defined($store)or $store=1;$meta->{dbm_store_metadata}=$store}unless (defined($meta->{col_names})){defined($dbh->{dbm_cols})and $meta->{col_names}=$dbh->{dbm_cols}}$self->SUPER::init_table_meta($dbh,$meta,$table)}sub open_data {my ($className,$meta,$attrs,$flags)=@_;$className->SUPER::open_data($meta,$attrs,$flags);unless ($flags->{dropMode}){my@tie_args;if ($meta->{dbm_type}eq 'BerkeleyDB'){my$DB_CREATE=BerkeleyDB::DB_CREATE();my$DB_RDONLY=BerkeleyDB::DB_RDONLY();my%tie_flags;if (my$f=$meta->{dbm_berkeley_flags}){defined($f->{DB_CREATE})and $DB_CREATE=delete$f->{DB_CREATE};defined($f->{DB_RDONLY})and $DB_RDONLY=delete$f->{DB_RDONLY};%tie_flags=%$f}my$open_mode=$flags->{lockMode}|| $flags->{createMode}? $DB_CREATE : $DB_RDONLY;@tie_args=(-Filename=>$meta->{f_fqbn},-Flags=>$open_mode,%tie_flags)}else {my$open_mode=O_RDONLY;$flags->{lockMode}and $open_mode=O_RDWR;$flags->{createMode}and $open_mode=O_RDWR | O_CREAT | O_TRUNC;@tie_args=($meta->{f_fqbn},$open_mode,0666)}if ($meta->{dbm_mldbm}){$MLDBM::UseDB=$meta->{dbm_usedb};$MLDBM::Serializer=$meta->{dbm_mldbm}}$meta->{hash}={};my$tie_class=$meta->{dbm_tietype};eval {tie %{$meta->{hash}},$tie_class,@tie_args};$@ and croak "Cannot tie(\%h $tie_class @tie_args): $@";-f $meta->{f_fqfn}or croak("No such file: '" .$meta->{f_fqfn}."'")}unless ($flags->{createMode}){my ($meta_data,$schema,$col_names);if ($meta->{dbm_store_metadata}){$meta_data=$col_names=$meta->{hash}->{"_metadata \0"};if ($meta_data and $meta_data =~ m~<dbd_metadata>(.+)</dbd_metadata>~is){$schema=$col_names=$1;$schema =~ s~.*<schema>(.+)</schema>.*~$1~is;$col_names =~ s~.*<col_names>(.+)</col_names>.*~$1~is}}$col_names ||= $meta->{col_names}|| ['k','v' ];$col_names=[split /,/,$col_names ]if (ref$col_names ne 'ARRAY');if ($meta->{dbm_store_metadata}and not $meta->{hash}->{"_metadata \0"}){$schema or $schema='';$meta->{hash}->{"_metadata \0"}="<dbd_metadata>" ."<schema>$schema</schema>" ."<col_names>" .join(",",@{$col_names})."</col_names>" ."</dbd_metadata>"}$meta->{schema}=$schema;$meta->{col_names}=$col_names}}sub drop ($$) {my ($self,$data)=@_;my$meta=$self->{meta};$meta->{hash}and untie %{$meta->{hash}};$self->SUPER::drop($data);-f $meta->{f_fqbn}.$dirfext and $meta->{f_ext}eq '.pag/r' and unlink($meta->{f_fqbn}.$dirfext);return 1}sub fetch_row ($$) {my ($self,$data)=@_;my$meta=$self->{meta};my@ary=each %{$meta->{hash}};$meta->{dbm_store_metadata}and $ary[0]and $ary[0]eq "_metadata \0" and @ary=each %{$meta->{hash}};my ($key,$val)=@ary;unless ($key){delete$self->{row};return}my@row=(ref($val)eq 'ARRAY')? ($key,@$val): ($key,$val);$self->{row}=@row ? \@row : undef;return wantarray ? @row : \@row}sub insert_new_row ($$$) {my ($self,$data,$row_aryref)=@_;my$meta=$self->{meta};my$ncols=scalar(@{$meta->{col_names}});my$nitems=scalar(@{$row_aryref});$ncols==$nitems or croak "You tried to insert $nitems, but table is created with $ncols columns";my$key=shift @$row_aryref;my$exists;eval {$exists=exists($meta->{hash}->{$key})};$exists and croak "Row with PK '$key' already exists";$meta->{hash}->{$key}=$meta->{dbm_mldbm}? $row_aryref : $row_aryref->[0];return 1}sub push_names ($$$) {my ($self,$data,$row_aryref)=@_;my$meta=$self->{meta};my$ncols=scalar(@$row_aryref);$ncols < 2 and croak "At least 2 columns are required for DBD::DBM tables ...";!$meta->{dbm_mldbm}and $ncols > 2 and croak "Without serializing with MLDBM only 2 columns are supported, you give $ncols";$meta->{col_names}=$row_aryref;return unless$meta->{dbm_store_metadata};my$stmt=$data->{sql_stmt};my$col_names=join(',',@{$row_aryref});my$schema=$data->{Database}->{Statement};$schema =~ s/^[^\(]+\((.+)\)$/$1/s;$schema=$stmt->schema_str()if ($stmt->can('schema_str'));$meta->{hash}->{"_metadata \0"}="<dbd_metadata>" ."<schema>$schema</schema>" ."<col_names>$col_names</col_names>" ."</dbd_metadata>"}sub fetch_one_row ($$;$) {my ($self,$key_only,$key)=@_;my$meta=$self->{meta};$key_only and return$meta->{col_names}->[0];exists$meta->{hash}->{$key}or return;my$val=$meta->{hash}->{$key};$val=(ref($val)eq 'ARRAY')? $val : [$val];my$row=[$key,@$val ];return wantarray ? @{$row}: $row}sub delete_one_row ($$$) {my ($self,$data,$aryref)=@_;my$meta=$self->{meta};delete$meta->{hash}->{$aryref->[0]}}sub update_one_row ($$$) {my ($self,$data,$aryref)=@_;my$meta=$self->{meta};my$key=shift @$aryref;defined$key or return;my$row=(ref($aryref)eq 'ARRAY')? $aryref : [$aryref];$meta->{hash}->{$key}=$meta->{dbm_mldbm}? $row : $row->[0]}sub update_specific_row ($$$$) {my ($self,$data,$aryref,$origary)=@_;my$meta=$self->{meta};my$key=shift @$origary;my$newkey=shift @$aryref;return unless (defined$key);$key eq $newkey or delete$meta->{hash}->{$key};my$row=(ref($aryref)eq 'ARRAY')? $aryref : [$aryref];$meta->{hash}->{$newkey}=$meta->{dbm_mldbm}? $row : $row->[0]}sub DESTROY ($) {my$self=shift;my$meta=$self->{meta};$meta->{hash}and untie %{$meta->{hash}};$self->SUPER::DESTROY()}sub truncate ($$) {return 1}sub seek ($$$$) {return 1}1;
DBD_DBM

$fatpacked{"DBD/ExampleP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_EXAMPLEP';
  {package DBD::ExampleP;use strict;use Symbol;use DBI qw(:sql_types);require File::Spec;our (@EXPORT,$VERSION,@statnames,%statnames,@stattypes,%stattypes,@statprec,%statprec,$drh,);@EXPORT=qw();$VERSION="0.03";@statnames=qw(dev ino mode nlink uid gid rdev size atime mtime ctime blksize blocks name);@statnames{@statnames}=(0 .. @statnames-1);@stattypes=(SQL_INTEGER,SQL_INTEGER,SQL_INTEGER,SQL_INTEGER,SQL_INTEGER,SQL_INTEGER,SQL_INTEGER,SQL_INTEGER,SQL_INTEGER,SQL_INTEGER,SQL_INTEGER,SQL_INTEGER,SQL_INTEGER,SQL_VARCHAR);@stattypes{@statnames}=@stattypes;@statprec=((10)x (@statnames-1),1024);@statprec{@statnames}=@statprec;die unless@statnames==@stattypes;die unless@statprec==@stattypes;$drh=undef;sub driver{return$drh if$drh;my($class,$attr)=@_;$class .= "::dr";($drh)=DBI::_new_drh($class,{'Name'=>'ExampleP','Version'=>$VERSION,'Attribution'=>'DBD Example Perl stub by Tim Bunce',},['example implementors private data '.__PACKAGE__]);$drh}sub CLONE {undef$drh}}{package DBD::ExampleP::dr;$imp_data_size=0;use strict;sub connect {my($drh,$dbname,$user,$auth)=@_;my ($outer,$dbh)=DBI::_new_dbh($drh,{Name=>$dbname,examplep_private_dbh_attrib=>42,});$dbh->{examplep_get_info}={29=>'"',41=>'.',114=>1,};$dbh->STORE('Active',1);return$outer}sub data_sources {return ("dbi:ExampleP:dir=.")}}{package DBD::ExampleP::db;$imp_data_size=0;use strict;sub prepare {my($dbh,$statement)=@_;my@fields;my($fields,$dir)=$statement =~ m/^\s*select\s+(.*?)\s+from\s+(\S*)/i;if (defined$fields and defined$dir){@fields=($fields eq '*')? keys%DBD::ExampleP::statnames : split(/\s*,\s*/,$fields)}else {return$dbh->set_err($DBI::stderr,"Syntax error in select statement (\"$statement\")")unless$statement =~ m/^\s*set\s+/}my ($outer,$sth)=DBI::_new_sth($dbh,{'Statement'=>$statement,examplep_private_sth_attrib=>24,},['example implementors private data '.__PACKAGE__]);my@bad=map {defined$DBD::ExampleP::statnames{$_}? (): $_}@fields;return$dbh->set_err($DBI::stderr,"Unknown field names: @bad")if@bad;$outer->STORE('NUM_OF_FIELDS'=>scalar(@fields));$sth->{examplep_ex_dir}=$dir if defined($dir)&& $dir !~ /\?/;$outer->STORE('NUM_OF_PARAMS'=>($dir)? $dir =~ tr/?/?/ : 0);if (@fields){$outer->STORE('NAME'=>\@fields);$outer->STORE('NULLABLE'=>[(0)x @fields ]);$outer->STORE('SCALE'=>[(0)x @fields ])}$outer}sub table_info {my$dbh=shift;my ($catalog,$schema,$table,$type)=@_;my@types=split(/["']*,["']/,$type || 'TABLE');my%types=map {$_=>$_}@types;my$dh=Symbol::gensym();my$dir=$catalog || File::Spec->curdir();my@list;if ($types{VIEW}){push@list,[undef,"schema","table",'VIEW',undef ];push@list,[undef,"sch-ema","table",'VIEW',undef ];push@list,[undef,"schema","ta-ble",'VIEW',undef ];push@list,[undef,"sch ema","table",'VIEW',undef ];push@list,[undef,"schema","ta ble",'VIEW',undef ]}if ($types{TABLE}){no strict 'refs';opendir($dh,$dir)or return$dbh->set_err(int($!),"Failed to open directory $dir: $!");while (defined(my$item=readdir($dh))){if ($^O eq 'VMS'){next if$item !~ /\.dir$/oi}my$file=File::Spec->catdir($dir,$item);next unless -d $file;my($dev,$ino,$mode,$nlink,$uid)=lstat($file);my$pwnam=undef;push@list,[$dir,$pwnam,$item,'TABLE',undef ]}close($dh)}$dbh->{'dbd_sponge_dbh'}||= DBI->connect("DBI:Sponge:",'','')or return$dbh->set_err($DBI::err,"Failed to connect to DBI::Sponge: $DBI::errstr");my$attr={'rows'=>\@list,'NUM_OF_FIELDS'=>5,'NAME'=>['TABLE_CAT','TABLE_SCHEM','TABLE_NAME','TABLE_TYPE','REMARKS'],'TYPE'=>[DBI::SQL_VARCHAR(),DBI::SQL_VARCHAR(),DBI::SQL_VARCHAR(),DBI::SQL_VARCHAR(),DBI::SQL_VARCHAR()],'NULLABLE'=>[1,1,1,1,1]};my$sdbh=$dbh->{'dbd_sponge_dbh'};my$sth=$sdbh->prepare("SHOW TABLES FROM $dir",$attr)or return$dbh->set_err($sdbh->err(),$sdbh->errstr());$sth}sub type_info_all {my ($dbh)=@_;my$ti=[{TYPE_NAME=>0,DATA_TYPE=>1,COLUMN_SIZE=>2,LITERAL_PREFIX=>3,LITERAL_SUFFIX=>4,CREATE_PARAMS=>5,NULLABLE=>6,CASE_SENSITIVE=>7,SEARCHABLE=>8,UNSIGNED_ATTRIBUTE=>9,FIXED_PREC_SCALE=>10,AUTO_UNIQUE_VALUE=>11,LOCAL_TYPE_NAME=>12,MINIMUM_SCALE=>13,MAXIMUM_SCALE=>14,},['VARCHAR',DBI::SQL_VARCHAR,1024,"'","'",undef,0,1,1,0,0,0,undef,0,0 ],['INTEGER',DBI::SQL_INTEGER,10,"","",undef,0,0,1,0,0,0,undef,0,0 ],];return$ti}sub ping {(shift->FETCH('Active'))? 2 : 0}sub disconnect {shift->STORE(Active=>0);return 1}sub get_info {my ($dbh,$info_type)=@_;return$dbh->{examplep_get_info}->{$info_type}}sub FETCH {my ($dbh,$attrib)=@_;return$INC{"DBD/ExampleP.pm"}if$attrib eq 'example_driver_path';return$dbh->SUPER::FETCH($attrib)}sub STORE {my ($dbh,$attrib,$value)=@_;if ($attrib eq 'examplep_set_err'){$dbh->set_err($value,$value);return}if ($attrib eq 'AutoCommit'){$value=($value)? -901 : -900}return$dbh->{$attrib}=$value if$attrib =~ /^examplep_/;return$dbh->SUPER::STORE($attrib,$value)}sub DESTROY {my$dbh=shift;$dbh->disconnect if$dbh->FETCH('Active');undef}sub examplep_tables {my$dbh=shift;my$re=shift;grep {$_ =~ /$re/}$dbh->tables()}sub parse_trace_flag {my ($h,$name)=@_;return 0x01000000 if$name eq 'foo';return 0x02000000 if$name eq 'bar';return 0x04000000 if$name eq 'baz';return 0x08000000 if$name eq 'boo';return 0x10000000 if$name eq 'bop';return$h->SUPER::parse_trace_flag($name)}sub private_attribute_info {return {example_driver_path=>undef }}}{package DBD::ExampleP::st;$imp_data_size=0;use strict;no strict 'refs';sub bind_param {my($sth,$param,$value,$attribs)=@_;$sth->{'dbd_param'}->[$param-1]=$value;return 1}sub execute {my($sth,@dir)=@_;my$dir;if (@dir){$sth->bind_param($_,$dir[$_-1])or return foreach (1..@dir)}my$dbd_param=$sth->{'dbd_param'}|| [];return$sth->set_err(2,@$dbd_param." values bound when $sth->{NUM_OF_PARAMS} expected")unless @$dbd_param==$sth->{NUM_OF_PARAMS};return 0 unless$sth->{NUM_OF_FIELDS};$dir=$dbd_param->[0]|| $sth->{examplep_ex_dir};return$sth->set_err(2,"No bind parameter supplied")unless defined$dir;$sth->finish;if ($dir =~ /^long_list_(\d+)$/){$sth->{dbd_dir}=[$1 ];$sth->{dbd_datahandle}=undef}else {$sth->{dbd_dir}=$dir;my$sym=Symbol::gensym();opendir($sym,$dir)or return$sth->set_err(2,"opendir($dir): $!");$sth->{dbd_datahandle}=$sym}$sth->STORE(Active=>1);return 1}sub fetch {my$sth=shift;my$dir=$sth->{dbd_dir};my%s;if (ref$dir){my$num=$dir->[0]--;unless ($num > 0){$sth->finish();return}my$time=time;@s{@DBD::ExampleP::statnames}=(2051,1000+$num,0644,2,$>,$),0,1024,$time,$time,$time,512,2,"file$num")}else {my$dh=$sth->{dbd_datahandle}or return$sth->set_err($DBI::stderr,"fetch without successful execute");my$f=readdir($dh);unless ($f){$sth->finish;return}($f)=($f =~ m/^(.*)$/);my$file=File::Spec->catfile($dir,$f);@s{@DBD::ExampleP::statnames }=(lstat($file),$f)}my@new=@s{@{$sth->{NAME}}};return$sth->_set_fbav(\@new)}*fetchrow_arrayref=\&fetch;sub finish {my$sth=shift;closedir($sth->{dbd_datahandle})if$sth->{dbd_datahandle};$sth->{dbd_datahandle}=undef;$sth->{dbd_dir}=undef;$sth->SUPER::finish();return 1}sub FETCH {my ($sth,$attrib)=@_;if ($attrib eq 'TYPE'){return [@DBD::ExampleP::stattypes{@{$sth->FETCH(q{NAME_lc})}}]}elsif ($attrib eq 'PRECISION'){return [@DBD::ExampleP::statprec{@{$sth->FETCH(q{NAME_lc})}}]}elsif ($attrib eq 'ParamValues'){my$dbd_param=$sth->{dbd_param}|| [];my%pv=map {$_=>$dbd_param->[$_-1]}1..@$dbd_param;return \%pv}return$sth->SUPER::FETCH($attrib)}sub STORE {my ($sth,$attrib,$value)=@_;return$sth->{$attrib}=$value if$attrib eq 'NAME' or $attrib eq 'NULLABLE' or $attrib eq 'SCALE' or $attrib eq 'PRECISION';return$sth->SUPER::STORE($attrib,$value)}*parse_trace_flag=\&DBD::ExampleP::db::parse_trace_flag}1;
DBD_EXAMPLEP

$fatpacked{"DBD/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_FILE';
  require 5.008;use strict;use warnings;use DBI ();package DBD::File;use strict;use warnings;use base qw(DBI::DBD::SqlEngine);use Carp;use vars qw(@ISA $VERSION $drh);$VERSION="0.03";$drh=undef;sub driver ($;$) {my ($class,$attr)=@_;$drh->{$class}and return$drh->{$class};$attr ||= {};{no strict "refs";unless ($attr->{Attribution}){$class eq "DBD::File" and $attr->{Attribution}="$class by Jeff Zucker";$attr->{Attribution}||= ${$class ."::ATTRIBUTION"}|| "oops the author of $class forgot to define this"}$attr->{Version}||= ${$class ."::VERSION"};$attr->{Name}or ($attr->{Name}=$class)=~ s/^DBD\:\://}$drh->{$class}=$class->SUPER::driver ($attr);return$drh->{$class}}sub CLONE {undef$drh}package DBD::File::dr;use strict;use warnings;use vars qw(@ISA $imp_data_size);use Carp;@DBD::File::dr::ISA=qw(DBI::DBD::SqlEngine::dr);$DBD::File::dr::imp_data_size=0;sub dsn_quote {my$str=shift;ref$str and return "";defined$str or return "";$str =~ s/([;:\\])/\\$1/g;return$str}sub default_table_source {"DBD::File::TableSource::FileSystem"}sub connect {my ($drh,$dbname,$user,$auth,$attr)=@_;if (my$attr_hash=(DBI->parse_dsn ($dbname))[3]){if (defined$attr_hash->{f_dir}&&!-d $attr_hash->{f_dir}){my$msg="No such directory '$attr_hash->{f_dir}";$drh->set_err (2,$msg);$attr_hash->{RaiseError}and croak$msg;return}}if ($attr and defined$attr->{f_dir}&&!-d $attr->{f_dir}){my$msg="No such directory '$attr->{f_dir}";$drh->set_err (2,$msg);$attr->{RaiseError}and croak$msg;return}return$drh->SUPER::connect ($dbname,$user,$auth,$attr)}sub disconnect_all {}sub DESTROY {undef}package DBD::File::db;use strict;use warnings;use vars qw(@ISA $imp_data_size);use Carp;require File::Spec;require Cwd;use Scalar::Util qw(refaddr);@DBD::File::db::ISA=qw(DBI::DBD::SqlEngine::db);$DBD::File::db::imp_data_size=0;sub data_sources {my ($dbh,$attr,@other)=@_;ref ($attr)eq "HASH" or $attr={};exists$attr->{f_dir}or $attr->{f_dir}=$dbh->{f_dir};exists$attr->{f_dir_search}or $attr->{f_dir_search}=$dbh->{f_dir_search};return$dbh->SUPER::data_sources ($attr,@other)}sub set_versions {my$dbh=shift;$dbh->{f_version}=$DBD::File::VERSION;return$dbh->SUPER::set_versions ()}sub init_valid_attributes {my$dbh=shift;$dbh->{f_valid_attrs}={f_version=>1,f_dir=>1,f_dir_search=>1,f_ext=>1,f_schema=>1,f_lock=>1,f_lockfile=>1,f_encoding=>1,f_valid_attrs=>1,f_readonly_attrs=>1,};$dbh->{f_readonly_attrs}={f_version=>1,f_valid_attrs=>1,f_readonly_attrs=>1,};return$dbh->SUPER::init_valid_attributes ()}sub init_default_attributes {my ($dbh,$phase)=@_;$dbh->SUPER::init_default_attributes ($phase);unless (defined$phase){$phase=defined$dbh->{sql_init_phase};$phase and $phase=$dbh->{sql_init_phase}}if (0==$phase){$dbh->{f_dir}=Cwd::abs_path (File::Spec->curdir ());push @{$dbh->{sql_init_order}{90}},"f_meta";(my$drv_class=$dbh->{ImplementorClass})=~ s/::db$//;my$drv_prefix=DBI->driver_prefix ($drv_class);if (exists$dbh->{$drv_prefix ."meta"}and!$dbh->{sql_engine_in_gofer}){my$attr=$dbh->{$drv_prefix ."meta"};defined$dbh->{f_valid_attrs}{f_meta}and $dbh->{f_valid_attrs}{f_meta}=1;$dbh->{f_meta}=$dbh->{$attr}}}return$dbh}sub validate_FETCH_attr {my ($dbh,$attrib)=@_;$attrib eq "f_meta" and $dbh->{sql_engine_in_gofer}and $attrib="sql_meta";return$dbh->SUPER::validate_FETCH_attr ($attrib)}sub validate_STORE_attr {my ($dbh,$attrib,$value)=@_;if ($attrib eq "f_dir" && defined$value){-d $value or return$dbh->set_err ($DBI::stderr,"No such directory '$value'");File::Spec->file_name_is_absolute ($value)or $value=Cwd::abs_path ($value)}if ($attrib eq "f_ext"){$value eq "" || $value =~ m{^\.\w+(?:/[rR]*)?$} or carp "'$value' doesn't look like a valid file extension attribute\n"}$attrib eq "f_meta" and $dbh->{sql_engine_in_gofer}and $attrib="sql_meta";return$dbh->SUPER::validate_STORE_attr ($attrib,$value)}sub get_f_versions {my ($dbh,$table)=@_;my$class=$dbh->{ImplementorClass};$class =~ s/::db$/::Table/;my$dver;my$dtype="IO::File";eval {$dver=IO::File->VERSION ();$dtype .= " ($dver)"};my$f_encoding;if ($table){my$meta;$table and (undef,$meta)=$class->get_table_meta ($dbh,$table,1);$meta and $meta->{f_encoding}and $f_encoding=$meta->{f_encoding}}$f_encoding ||= $dbh->{f_encoding};$f_encoding and $dtype .= " + " .$f_encoding ." encoding";return sprintf "%s using %s",$dbh->{f_version},$dtype}package DBD::File::st;use strict;use warnings;use vars qw(@ISA $imp_data_size);@DBD::File::st::ISA=qw(DBI::DBD::SqlEngine::st);$DBD::File::st::imp_data_size=0;my%supported_attrs=(TYPE=>1,PRECISION=>1,NULLABLE=>1,);sub FETCH {my ($sth,$attr)=@_;if ($supported_attrs{$attr}){my$stmt=$sth->{sql_stmt};if (exists$sth->{ImplementorClass}&& exists$sth->{sql_stmt}&& $sth->{sql_stmt}->isa ("SQL::Statement")){unless (exists$sth->{f_overall_defs}&& ref$sth->{f_overall_defs}){my$types=$sth->{Database}{Types};unless ($types){if (my$t=$sth->{Database}->type_info_all ()){for my$i (1 .. $#$t){$types->{uc$t->[$i][0]}=$t->[$i][1];$types->{$t->[$i][1]}||= uc$t->[$i][0]}}for ([0,"" ],[1,"CHAR" ],[4,"INTEGER" ],[12,"VARCHAR" ],){$types->{$_->[0]}||= $_->[1];$types->{$_->[1]}||= $_->[0]}$sth->{Database}{Types}=$types}my$all_meta=$sth->{Database}->func ("*","table_defs","get_sql_engine_meta");for my$tbl (keys %$all_meta){my$meta=$all_meta->{$tbl};exists$meta->{table_defs}&& ref$meta->{table_defs}or next;for (keys %{$meta->{table_defs}{columns}}){my$field_info=$meta->{table_defs}{columns}{$_};if (defined$field_info->{data_type}&& $field_info->{data_type}!~ m/^[0-9]+$/){$field_info->{type_name}=uc$field_info->{data_type};$field_info->{data_type}=$types->{$field_info->{type_name}}|| 0}$field_info->{type_name}||= $types->{$field_info->{data_type}}|| "CHAR";$sth->{f_overall_defs}{$_}=$field_info}}}my@colnames=$sth->sql_get_colnames ();$attr eq "TYPE" and return [map {$sth->{f_overall_defs}{$_}{data_type}|| 12}@colnames ];$attr eq "TYPE_NAME" and return [map {$sth->{f_overall_defs}{$_}{type_name}|| "VARCHAR"}@colnames ];$attr eq "PRECISION" and return [map {$sth->{f_overall_defs}{$_}{data_length}|| 0}@colnames ];$attr eq "NULLABLE" and return [map {(grep {$_ eq "NOT NULL"}@{$sth->{f_overall_defs}{$_}{constraints}|| []})? 0 : 1}@colnames ]}}return$sth->SUPER::FETCH ($attr)}package DBD::File::TableSource::FileSystem;use strict;use warnings;use IO::Dir;@DBD::File::TableSource::FileSystem::ISA="DBI::DBD::SqlEngine::TableSource";sub data_sources {my ($class,$drh,$attr)=@_;my$dir=$attr && exists$attr->{f_dir}? $attr->{f_dir}: File::Spec->curdir ();defined$dir or return;unless (-d $dir && -r $dir && -x $dir){$drh->set_err ($DBI::stderr,"Cannot use directory $dir from f_dir");return}my%attrs;$attr and %attrs=%$attr;delete$attrs{f_dir};my$dsn_quote=$drh->{ImplementorClass}->can ("dsn_quote");my$dsnextra=join ";",map {$_ ."=" .&{$dsn_quote}($attrs{$_})}keys%attrs;my@dir=($dir);$attr->{f_dir_search}&& ref$attr->{f_dir_search}eq "ARRAY" and push@dir,grep {-d $_}@{$attr->{f_dir_search}};my@dsns;for$dir (@dir){my$dirh=IO::Dir->new ($dir);unless (defined$dirh){$drh->set_err ($DBI::stderr,"Cannot open directory $dir: $!");return}my ($file,%names,$driver);$driver=$drh->{ImplementorClass}=~ m/^dbd\:\:([^\:]+)\:\:/i ? $1 : "File";while (defined ($file=$dirh->read ())){my$d=File::Spec->catdir ($dir,$file);$file ne File::Spec->updir ()&& -d $d and push@dsns,"DBI:$driver:f_dir=" .&{$dsn_quote}($d).($dsnextra ? ";$dsnextra" : "")}}return@dsns}sub avail_tables {my ($self,$dbh)=@_;my$dir=$dbh->{f_dir};defined$dir or return;my%seen;my@tables;my@dir=($dir);$dbh->{f_dir_search}&& ref$dbh->{f_dir_search}eq "ARRAY" and push@dir,grep {-d $_}@{$dbh->{f_dir_search}};for$dir (@dir){my$dirh=IO::Dir->new ($dir);unless (defined$dirh){$dbh->set_err ($DBI::stderr,"Cannot open directory $dir: $!");return}my$class=$dbh->FETCH ("ImplementorClass");$class =~ s/::db$/::Table/;my ($file,%names);my$schema=exists$dbh->{f_schema}? defined$dbh->{f_schema}&& $dbh->{f_schema}ne "" ? $dbh->{f_schema}: undef : eval {getpwuid ((stat$dir)[4])};while (defined ($file=$dirh->read ())){my ($tbl,$meta)=$class->get_table_meta ($dbh,$file,0,0)or next;$seen{defined$schema ? $schema : "\0"}{$dir}{$tbl}++ or push@tables,[undef,$schema,$tbl,"TABLE","FILE" ]}$dirh->close ()or $dbh->set_err ($DBI::stderr,"Cannot close directory $dir: $!")}return@tables}package DBD::File::DataSource::Stream;use strict;use warnings;use Carp;@DBD::File::DataSource::Stream::ISA="DBI::DBD::SqlEngine::DataSource";my$locking=eval {my$fh;my$nulldevice=File::Spec->devnull ();open$fh,">",$nulldevice or croak "Can't open $nulldevice: $!";flock$fh,0;close$fh;1};sub complete_table_name {my ($self,$meta,$file,$respect_case)=@_;my$tbl=$file;if (!$respect_case and $meta->{sql_identifier_case}==1){$tbl=uc$tbl}elsif (!$respect_case and $meta->{sql_identifier_case}==2){$tbl=lc$tbl}$meta->{f_fqfn}=undef;$meta->{f_fqbn}=undef;$meta->{f_fqln}=undef;$meta->{table_name}=$tbl;return$tbl}sub apply_encoding {my ($self,$meta,$fn)=@_;defined$fn or $fn="file handle " .fileno ($meta->{fh});if (my$enc=$meta->{f_encoding}){binmode$meta->{fh},":encoding($enc)" or croak "Failed to set encoding layer '$enc' on $fn: $!"}else {binmode$meta->{fh}or croak "Failed to set binary mode on $fn: $!"}}sub open_data {my ($self,$meta,$attrs,$flags)=@_;$flags->{dropMode}and croak "Can't drop a table in stream";my$fn="file handle " .fileno ($meta->{f_file});if ($flags->{createMode}|| $flags->{lockMode}){$meta->{fh}=IO::Handle->new_from_fd (fileno ($meta->{f_file}),"w+")or croak "Cannot open $fn for writing: $! (" .($!+0).")"}else {$meta->{fh}=IO::Handle->new_from_fd (fileno ($meta->{f_file}),"r")or croak "Cannot open $fn for reading: $! (" .($!+0).")"}if ($meta->{fh}){$self->apply_encoding ($meta,$fn)}if ($self->can_flock && $meta->{fh}){my$lm=defined$flags->{f_lock}&& $flags->{f_lock}=~ m/^[012]$/ ? $flags->{f_lock}: $flags->{lockMode}? 2 : 1;if ($lm==2){flock$meta->{fh},2 or croak "Cannot obtain exclusive lock on $fn: $!"}elsif ($lm==1){flock$meta->{fh},1 or croak "Cannot obtain shared lock on $fn: $!"}}}sub can_flock {$locking}package DBD::File::DataSource::File;use strict;use warnings;@DBD::File::DataSource::File::ISA="DBD::File::DataSource::Stream";use Carp;my$fn_any_ext_regex=qr/\.[^.]*/;sub complete_table_name {my ($self,$meta,$file,$respect_case,$file_is_table)=@_;$file eq "." || $file eq ".." and return;my ($ext,$req)=("",0);if ($meta->{f_ext}){($ext,my$opt)=split m{/},$meta->{f_ext};if ($ext && $opt){$opt =~ m/r/i and $req=1}}my ($tbl,$basename,$dir,$fn_ext,$user_spec_file,$searchdir);if ($file_is_table and defined$meta->{f_file}){$tbl=$file;($basename,$dir,$fn_ext)=File::Basename::fileparse ($meta->{f_file},$fn_any_ext_regex);$file=$basename .$fn_ext;$user_spec_file=1}else {($basename,$dir,undef)=File::Basename::fileparse ($file,$ext);if ($dir =~ m{^(?:[.][/\\]?|\[\])$} && ref$meta->{f_dir_search}eq "ARRAY"){for my$d ($meta->{f_dir},@{$meta->{f_dir_search}}){my$f=File::Spec->catdir ($d,$file);-f $f or next;$searchdir=Cwd::abs_path ($d);$dir="";last}}$file=$tbl=$basename;$user_spec_file=0}if (!$respect_case and $meta->{sql_identifier_case}==1){$basename=uc$basename;$tbl=uc$tbl}elsif (!$respect_case and $meta->{sql_identifier_case}==2){$basename=lc$basename;$tbl=lc$tbl}unless (defined$searchdir){$searchdir=File::Spec->file_name_is_absolute ($dir)? ($dir =~ s{/$}{},$dir): Cwd::abs_path (File::Spec->catdir ($meta->{f_dir},$dir))}-d$searchdir or croak "-d $searchdir: $!";$searchdir eq $meta->{f_dir}and $dir="";unless ($user_spec_file){$file_is_table and $file="$basename$ext";my$cmpsub;if ($respect_case){$cmpsub=sub {my ($fn,undef,$sfx)=File::Basename::fileparse ($_,$fn_any_ext_regex);$^O eq "VMS" && $sfx eq "." and $sfx="";$fn eq $basename and return (lc$sfx eq lc$ext or!$req &&!$sfx);return 0}}else {$cmpsub=sub {my ($fn,undef,$sfx)=File::Basename::fileparse ($_,$fn_any_ext_regex);$^O eq "VMS" && $sfx eq "." and $sfx="";lc$fn eq lc$basename and return (lc$sfx eq lc$ext or!$req &&!$sfx);return 0}}my@f;{my$dh=IO::Dir->new ($searchdir)or croak "Can't open '$searchdir': $!";@f=sort {length$b <=> length$a}grep {&$cmpsub ($_)}$dh->read ();$dh->close ()or croak "Can't close '$searchdir': $!"}@f > 0 && @f <= 2 and $file=$f[0];!$respect_case && $meta->{sql_identifier_case}==4 and ($tbl=$file)=~ s/$ext$//i;my$tmpfn=$file;if ($ext && $req){$tmpfn =~ s/$ext$//i or return}}my$fqfn=File::Spec->catfile ($searchdir,$file);my$fqbn=File::Spec->catfile ($searchdir,$basename);$meta->{f_fqfn}=$fqfn;$meta->{f_fqbn}=$fqbn;defined$meta->{f_lockfile}&& $meta->{f_lockfile}and $meta->{f_fqln}=$meta->{f_fqbn}.$meta->{f_lockfile};$dir &&!$user_spec_file and $tbl=File::Spec->catfile ($dir,$tbl);$meta->{table_name}=$tbl;return$tbl}sub open_data {my ($self,$meta,$attrs,$flags)=@_;defined$meta->{f_fqfn}&& $meta->{f_fqfn}ne "" or croak "No filename given";my ($fh,$fn);unless ($meta->{f_dontopen}){$fn=$meta->{f_fqfn};if ($flags->{createMode}){-f $meta->{f_fqfn}and croak "Cannot create table $attrs->{table}: Already exists";$fh=IO::File->new ($fn,"a+")or croak "Cannot open $fn for writing: $! (" .($!+0).")"}else {unless ($fh=IO::File->new ($fn,($flags->{lockMode}? "r+" : "r"))){croak "Cannot open $fn: $! (" .($!+0).")"}}$meta->{fh}=$fh;if ($fh){$fh->seek (0,0)or croak "Error while seeking back: $!";$self->apply_encoding ($meta)}}if ($meta->{f_fqln}){$fn=$meta->{f_fqln};if ($flags->{createMode}){-f $fn and croak "Cannot create table lock at '$fn' for $attrs->{table}: Already exists";$fh=IO::File->new ($fn,"a+")or croak "Cannot open $fn for writing: $! (" .($!+0).")"}else {unless ($fh=IO::File->new ($fn,($flags->{lockMode}? "r+" : "r"))){croak "Cannot open $fn: $! (" .($!+0).")"}}$meta->{lockfh}=$fh}if ($self->can_flock && $fh){my$lm=defined$flags->{f_lock}&& $flags->{f_lock}=~ m/^[012]$/ ? $flags->{f_lock}: $flags->{lockMode}? 2 : 1;if ($lm==2){flock$fh,2 or croak "Cannot obtain exclusive lock on $fn: $!"}elsif ($lm==1){flock$fh,1 or croak "Cannot obtain shared lock on $fn: $!"}}}package DBD::File::Statement;use strict;use warnings;@DBD::File::Statement::ISA=qw(DBI::DBD::SqlEngine::Statement);package DBD::File::Table;use strict;use warnings;use Carp;require IO::File;require File::Basename;require File::Spec;require Cwd;require Scalar::Util;@DBD::File::Table::ISA=qw(DBI::DBD::SqlEngine::Table);if (eval {require Params::Util}){Params::Util->import ("_HANDLE")}else {*_HANDLE=sub {defined $_[0]or return;ref $_[0]eq "GLOB" and return $_[0];tied ($_[0])and tied ($_[0])->can ("TIEHANDLE")and return $_[0];Scalar::Util::blessed ($_[0])or return;$_[0]->isa ("IO::Handle")and return $_[0];$_[0]->isa ("Tie::Handle")and return $_[0];$_[0]->isa ("IO::Scalar")and return $_[0];$_[0]->isa ("IO::String")and return $_[0];return}}sub file2table {my ($self,$meta,$file,$file_is_table,$respect_case)=@_;return$meta->{sql_data_source}->complete_table_name ($meta,$file,$respect_case,$file_is_table)}sub bootstrap_table_meta {my ($self,$dbh,$meta,$table,@other)=@_;$self->SUPER::bootstrap_table_meta ($dbh,$meta,$table,@other);exists$meta->{f_dir}or $meta->{f_dir}=$dbh->{f_dir};exists$meta->{f_dir_search}or $meta->{f_dir_search}=$dbh->{f_dir_search};defined$meta->{f_ext}or $meta->{f_ext}=$dbh->{f_ext};defined$meta->{f_encoding}or $meta->{f_encoding}=$dbh->{f_encoding};exists$meta->{f_lock}or $meta->{f_lock}=$dbh->{f_lock};exists$meta->{f_lockfile}or $meta->{f_lockfile}=$dbh->{f_lockfile};defined$meta->{f_schema}or $meta->{f_schema}=$dbh->{f_schema};defined$meta->{f_open_file_needed}or $meta->{f_open_file_needed}=$self->can ("open_file")!=DBD::File::Table->can ("open_file");defined ($meta->{sql_data_source})or $meta->{sql_data_source}=_HANDLE ($meta->{f_file})? "DBD::File::DataSource::Stream" : "DBD::File::DataSource::File"}sub get_table_meta ($$$$;$) {my ($self,$dbh,$table,$file_is_table,$respect_case)=@_;my$meta=$self->SUPER::get_table_meta ($dbh,$table,$respect_case,$file_is_table);$table=$meta->{table_name};return unless$table;return ($table,$meta)}my%reset_on_modify=(f_file=>["f_fqfn","sql_data_source" ],f_dir=>"f_fqfn",f_dir_search=>[],f_ext=>"f_fqfn",f_lockfile=>"f_fqfn",);__PACKAGE__->register_reset_on_modify (\%reset_on_modify);my%compat_map=map {$_=>"f_$_"}qw(file ext lock lockfile);__PACKAGE__->register_compat_map (\%compat_map);sub open_file {my ($className,$meta,$attrs,$flags)=@_;return$className->SUPER::open_data ($meta,$attrs,$flags)}sub open_data {my ($className,$meta,$attrs,$flags)=@_;$meta->{f_open_file_needed}? $className->open_file ($meta,$attrs,$flags): $className->SUPER::open_data ($meta,$attrs,$flags);return}sub drop ($) {my ($self,$data)=@_;my$meta=$self->{meta};$meta->{fh}and $meta->{fh}->close ();$meta->{lockfh}and $meta->{lockfh}->close ();undef$meta->{fh};undef$meta->{lockfh};$meta->{f_fqfn}and unlink$meta->{f_fqfn};$meta->{f_fqln}and unlink$meta->{f_fqln};delete$data->{Database}{sql_meta}{$self->{table}};return 1}sub seek ($$$$) {my ($self,$data,$pos,$whence)=@_;my$meta=$self->{meta};if ($whence==0 && $pos==0){$pos=defined$meta->{first_row_pos}? $meta->{first_row_pos}: 0}elsif ($whence!=2 || $pos!=0){croak "Illegal seek position: pos = $pos, whence = $whence"}$meta->{fh}->seek ($pos,$whence)or croak "Error while seeking in " .$meta->{f_fqfn}.": $!"}sub truncate ($$) {my ($self,$data)=@_;my$meta=$self->{meta};$meta->{fh}->truncate ($meta->{fh}->tell ())or croak "Error while truncating " .$meta->{f_fqfn}.": $!";return 1}sub DESTROY {my$self=shift;my$meta=$self->{meta};$meta->{fh}and $meta->{fh}->close ();$meta->{lockfh}and $meta->{lockfh}->close ();undef$meta->{fh};undef$meta->{lockfh};$self->SUPER::DESTROY()}1;
DBD_FILE

$fatpacked{"DBD/Gofer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_GOFER';
  {package DBD::Gofer;use strict;require DBI;require DBI::Gofer::Request;require DBI::Gofer::Response;require Carp;our$VERSION="0.03";our%xxh_local_store_attrib=map {$_=>1}qw(Active CachedKids Callbacks DbTypeSubclass ErrCount Executed FetchHashKeyName HandleError HandleSetErr InactiveDestroy AutoInactiveDestroy PrintError PrintWarn Profile RaiseError RootClass ShowErrorStatement Taint TaintIn TaintOut TraceLevel Warn dbi_quote_identifier_cache dbi_connect_closure dbi_go_execute_unique);our%xxh_local_store_attrib_if_same_value=map {$_=>1}qw(Username dbi_connect_method);our$drh=undef;our$methods_already_installed;sub driver{return$drh if$drh;DBI->setup_driver('DBD::Gofer');unless ($methods_already_installed++){my$opts={O=>0x0004 };DBD::Gofer::db->install_method('go_dbh_method',$opts);DBD::Gofer::st->install_method('go_sth_method',$opts);DBD::Gofer::st->install_method('go_clone_sth',$opts);DBD::Gofer::db->install_method('go_cache',$opts);DBD::Gofer::st->install_method('go_cache',$opts)}my($class,$attr)=@_;$class .= "::dr";($drh)=DBI::_new_drh($class,{'Name'=>'Gofer','Version'=>$VERSION,'Attribution'=>'DBD Gofer by Tim Bunce',});$drh}sub CLONE {undef$drh}sub go_cache {my$h=shift;$h->{go_cache}=shift if @_;return$h->{go_cache}if defined$h->{go_cache};return$h->{go_transport}->{go_cache}}sub set_err_from_response {my$h=shift;my$response=shift;if (my$warnings=$response->warnings){warn $_ for @$warnings}my ($err,$errstr,$state)=$response->err_errstr_state;$h->set_err($err,$errstr,$state)if defined$err;return undef}sub install_methods_proxy {my ($installed_methods)=@_;while (my ($full_method,$attr)=each %$installed_methods){DBI->_install_method($full_method,"",$attr||{})unless defined &{$full_method};$full_method =~ m/^DBI::(\w\w)::(\w+)$/ or die "Invalid method name '$full_method' for install_method";my ($type,$method)=($1,$2);my$driver_method="DBD::Gofer::${type}::${method}";next if defined &{$driver_method};my$sub;if ($type eq 'db'){$sub=sub {return shift->go_dbh_method(undef,$method,@_)}}else {$sub=sub {shift->set_err($DBI::stderr,"Can't call \$${type}h->$method when using DBD::Gofer");return}}no strict 'refs';*$driver_method=$sub}}}{package DBD::Gofer::dr;$imp_data_size=0;use strict;sub connect_cached {my ($drh,$dsn,$user,$auth,$attr)=@_;$attr ||= {};return$drh->SUPER::connect_cached($dsn,$user,$auth,{(%$attr),go_connect_method=>$attr->{go_connect_method}|| 'connect_cached',})}sub connect {my($drh,$dsn,$user,$auth,$attr)=@_;my$orig_dsn=$dsn;my$remote_dsn=($dsn =~ s/;?\bdsn=(.*)$// && $1)or return$drh->set_err($DBI::stderr,"No dsn= argument in '$orig_dsn'");if ($attr->{go_bypass}){return DBI->connect($remote_dsn,$user,$auth,$attr)}my%go_attr;for my$k (grep {/^go_/}keys %$attr){$go_attr{$k}=delete$attr->{$k}}for my$kv (grep /=/,split /;/,$dsn,-1){my ($k,$v)=split /=/,$kv,2;$go_attr{"go_$k" }=$v}if (not ref$go_attr{go_policy}){my$policy_class=$go_attr{go_policy}|| 'classic';$policy_class="DBD::Gofer::Policy::$policy_class" unless$policy_class =~ /::/;_load_class($policy_class)or return$drh->set_err($DBI::stderr,"Can't load $policy_class: $@");$go_attr{go_policy}=eval {$policy_class->new(\%go_attr)}or return$drh->set_err($DBI::stderr,"Can't instanciate $policy_class: $@")}my$go_policy=$go_attr{go_policy};if ($go_attr{go_cache}and not ref$go_attr{go_cache}){my$cache_class=$go_attr{go_cache};$cache_class="DBI::Util::CacheMemory" if$cache_class eq '1';_load_class($cache_class)or return$drh->set_err($DBI::stderr,"Can't load $cache_class $@");$go_attr{go_cache}=eval {$cache_class->new()}or $drh->set_err(0,"Can't instanciate $cache_class: $@")}my$go_connect_method=delete$go_attr{go_connect_method};my$transport_class=delete$go_attr{go_transport}or return$drh->set_err($DBI::stderr,"No transport= argument in '$orig_dsn'");$transport_class="DBD::Gofer::Transport::$transport_class" unless$transport_class =~ /::/;_load_class($transport_class)or return$drh->set_err($DBI::stderr,"Can't load $transport_class: $@");my$go_transport=eval {$transport_class->new(\%go_attr)}or return$drh->set_err($DBI::stderr,"Can't instanciate $transport_class: $@");my$request_class="DBI::Gofer::Request";my$go_request=eval {my$go_attr={%$attr };if ($user){$go_attr->{Username}=$user;$go_attr->{Password}=$auth}delete @{$go_attr}{qw(Profile HandleError HandleSetErr Callbacks)};delete @{$go_attr}{qw(RootClass DbTypeSubclass)};$go_connect_method ||= $go_policy->connect_method($remote_dsn,$go_attr)|| 'connect';$request_class->new({dbh_connect_call=>[$go_connect_method,$remote_dsn,$user,$auth,$go_attr ],})}or return$drh->set_err($DBI::stderr,"Can't instanciate $request_class: $@");my ($dbh,$dbh_inner)=DBI::_new_dbh($drh,{'Name'=>$dsn,'USER'=>$user,go_transport=>$go_transport,go_request=>$go_request,go_policy=>$go_policy,});$dbh->STORE(Active=>0);my$skip_connect_check=$go_policy->skip_connect_check($attr,$dbh);if (not $skip_connect_check){if (not $dbh->go_dbh_method(undef,'ping')){return undef if$dbh->err;return$dbh->set_err($DBI::stderr,"ping failed")}}return$dbh}sub _load_class {my$class=shift;(my$pm=$class)=~ s{::}{/}g;$pm .= ".pm";return 1 if eval {require$pm};delete$INC{$pm};undef}}{package DBD::Gofer::db;$imp_data_size=0;use strict;use Carp qw(carp croak);my%dbh_local_store_attrib=%DBD::Gofer::xxh_local_store_attrib;sub connected {shift->STORE(Active=>1)}sub go_dbh_method {my$dbh=shift;my$meta=shift;my$request=$dbh->{go_request};$request->init_request([wantarray,@_ ],$dbh);++$dbh->{go_request_count};my$go_policy=$dbh->{go_policy};my$dbh_attribute_update=$go_policy->dbh_attribute_update();$request->dbh_attributes($go_policy->dbh_attribute_list())if$dbh_attribute_update eq 'every' or $dbh->{go_request_count}==1;$request->dbh_last_insert_id_args($meta->{go_last_insert_id_args})if$meta->{go_last_insert_id_args};my$transport=$dbh->{go_transport}or return$dbh->set_err($DBI::stderr,"Not connected (no transport)");local$transport->{go_cache}=$dbh->{go_cache}if defined$dbh->{go_cache};my ($response,$retransmit_sub)=$transport->transmit_request($request);$response ||= $transport->receive_response($request,$retransmit_sub);$dbh->{go_response}=$response or die "No response object returned by $transport";die "response '$response' returned by $transport is not a response object" unless UNIVERSAL::isa($response,"DBI::Gofer::Response");if (my$dbh_attributes=$response->dbh_attributes){if (my$installed_methods=delete$dbh_attributes->{dbi_installed_methods}){DBD::Gofer::install_methods_proxy($installed_methods)if$dbh->{go_request_count}==1}$dbh->{$_}=$dbh_attributes->{$_}for keys %$dbh_attributes}my$rv=$response->rv;if (my$resultset_list=$response->sth_resultsets){my$sth=$dbh->prepare(undef,{go_skip_prepare_check=>1 });(tied %$sth)->{go_response}=$response;$sth->more_results;$rv=[$sth ]}elsif (!$rv){$rv=[]}DBD::Gofer::set_err_from_response($dbh,$response);return (wantarray)? @$rv : $rv->[0]}for my$method (qw(tables table_info column_info primary_key_info foreign_key_info statistics_info data_sources type_info_all get_info parse_trace_flags parse_trace_flag func)){my$policy_name="cache_$method";my$super_name="SUPER::$method";my$sub=sub {my$dbh=shift;my$rv;if ($dbh->{dbi_default_methods}{$method}&& $dbh->{go_policy}->skip_default_methods()){$dbh->trace_msg("    !! $method: using local default as remote method is also default\n");return$dbh->$super_name(@_)}my$cache;my$cache_key;if (my$cache_it=$dbh->{go_policy}->$policy_name(undef,$dbh,@_)){$cache=$dbh->{go_meta_cache}||= {};$cache_key=sprintf "%s_wa%d(%s)",$policy_name,wantarray||0,join(",\t",map {!ref($_)? DBI::neat($_,1e6): ref($_)eq 'ARRAY' ? DBI::neat_list($_,1e6,",\001"): ref($_)eq 'HASH' ? do {my@k=sort keys %$_;DBI::neat_list([@k,@{$_}{@k}],1e6,",\002")}: do {warn "unhandled argument type ($_)";$_}}@_);if ($rv=$cache->{$cache_key}){$dbh->trace_msg("$method(@_) returning previously cached value ($cache_key)\n",4);my@cache_rv=@$rv;$cache_rv[0]=$cache_rv[0]->go_clone_sth if UNIVERSAL::isa($cache_rv[0],'DBI::st');return (wantarray)? @cache_rv : $cache_rv[0]}}$rv=[(wantarray)? ($dbh->go_dbh_method(undef,$method,@_)): scalar$dbh->go_dbh_method(undef,$method,@_)];if ($cache){$dbh->trace_msg("$method(@_) caching return value ($cache_key)\n",4);my@cache_rv=@$rv;$cache->{$cache_key}=\@cache_rv unless UNIVERSAL::isa($cache_rv[0],'DBI::st')}return (wantarray)? @$rv : $rv->[0]};no strict 'refs';*$method=$sub}for my$method (qw(quote quote_identifier)){my$policy_name="locally_$method";my$super_name="SUPER::$method";my$sub=sub {my$dbh=shift;if ($dbh->{dbi_default_methods}{$method}&& $dbh->{go_policy}->skip_default_methods()){$dbh->trace_msg("    !! $method: using local default as remote method is also default\n");return$dbh->$super_name(@_)}my$locally=$dbh->{go_policy}->$policy_name($dbh,@_);if ($locally){return$locally->($dbh,@_)if ref$locally eq 'CODE';return$dbh->$super_name(@_)}return$dbh->go_dbh_method(undef,$method,@_)};no strict 'refs';*$method=$sub}for my$method (qw(begin_work commit rollback)){no strict 'refs';*$method=sub {return shift->set_err($DBI::stderr,"$method not available with DBD::Gofer")}}sub do {my ($dbh,$sql,$attr,@args)=@_;delete$dbh->{Statement};$dbh->{Statement}=$sql;my$meta={go_last_insert_id_args=>$attr->{go_last_insert_id_args}};return$dbh->go_dbh_method($meta,'do',$sql,$attr,@args)}sub ping {my$dbh=shift;return$dbh->set_err('',"can't ping while not connected")unless$dbh->SUPER::FETCH('Active');my$skip_ping=$dbh->{go_policy}->skip_ping();return ($skip_ping)? 1 : $dbh->go_dbh_method(undef,'ping',@_)}sub last_insert_id {my$dbh=shift;my$response=$dbh->{go_response}or return undef;return$response->last_insert_id}sub FETCH {my ($dbh,$attrib)=@_;if ($attrib =~ m/^[a-z]/ && $attrib !~ /^go_/){my$value=$dbh->go_dbh_method(undef,'FETCH',$attrib);$dbh->{$attrib}=$value;return$dbh->{$attrib}=$value}return$dbh->SUPER::FETCH($attrib)}sub STORE {my ($dbh,$attrib,$value)=@_;if ($attrib eq 'AutoCommit'){croak "Can't enable transactions when using DBD::Gofer" if!$value;return$dbh->SUPER::STORE($attrib=>($value)? -901 : -900)}return$dbh->SUPER::STORE($attrib=>$value)if$dbh_local_store_attrib{$attrib}or $attrib =~ /^private_/ or not $dbh->FETCH('Active');return$dbh->SUPER::STORE($attrib=>$value)if$DBD::Gofer::xxh_local_store_attrib_if_same_value{$attrib}&& do {my$crnt=$dbh->FETCH($attrib);local $^W;(defined($value)^ defined($crnt))? 0 : $value eq $crnt};carp("Can't alter \$dbh->{$attrib} after handle created with DBD::Gofer")if$dbh->FETCH('Warn');return$dbh->set_err($DBI::stderr,"Can't alter \$dbh->{$attrib} after handle created with DBD::Gofer")}sub disconnect {my$dbh=shift;$dbh->{go_transport}=undef;$dbh->STORE(Active=>0)}sub prepare {my ($dbh,$statement,$attr)=@_;return$dbh->set_err($DBI::stderr,"Can't prepare when disconnected")unless$dbh->FETCH('Active');$attr={%$attr }if$attr;my$policy=delete($attr->{go_policy})|| $dbh->{go_policy};my$lii_args=delete$attr->{go_last_insert_id_args};my$go_prepare=delete($attr->{go_prepare_method})|| $dbh->{go_prepare_method}|| $policy->prepare_method($dbh,$statement,$attr)|| 'prepare';my$go_cache=delete$attr->{go_cache};$attr=undef if$attr and not %$attr;my ($sth,$sth_inner)=DBI::_new_sth($dbh,{Statement=>$statement,go_prepare_call=>[0,$go_prepare,$statement,$attr ],go_request=>$dbh->{go_request},go_transport=>$dbh->{go_transport},go_policy=>$policy,go_last_insert_id_args=>$lii_args,go_cache=>$go_cache,});$sth->STORE(Active=>0);my$skip_prepare_check=$policy->skip_prepare_check($attr,$dbh,$statement,$attr,$sth);if (not $skip_prepare_check){$sth->go_sth_method()or return undef}return$sth}sub prepare_cached {my ($dbh,$sql,$attr,$if_active)=@_;$attr ||= {};return$dbh->SUPER::prepare_cached($sql,{%$attr,go_prepare_method=>$attr->{go_prepare_method}|| 'prepare_cached',},$if_active)}*go_cache=\&DBD::Gofer::go_cache}{package DBD::Gofer::st;$imp_data_size=0;use strict;my%sth_local_store_attrib=(%DBD::Gofer::xxh_local_store_attrib,NUM_OF_FIELDS=>1);sub go_sth_method {my ($sth,$meta)=@_;if (my$ParamValues=$sth->{ParamValues}){my$ParamAttr=$sth->{ParamAttr};my@params=reverse sort keys %$ParamValues;if (@params > 9 && ($sth->{Database}{go_dsn}||'')=~ /dbi:Sybase/){warn "Sybase param binding order hack in use";@params=sort {$b <=> $a}@params}for my$p (@params){unshift @{$sth->{go_method_calls}},['bind_param',$p,$ParamValues->{$p},$ParamAttr->{$p}]}}my$dbh=$sth->{Database}or die "panic";++$dbh->{go_request_count};my$request=$sth->{go_request};$request->init_request($sth->{go_prepare_call},$sth);$request->sth_method_calls(delete$sth->{go_method_calls})if$sth->{go_method_calls};$request->sth_result_attr({});$request->dbh_last_insert_id_args($meta->{go_last_insert_id_args})if$meta->{go_last_insert_id_args};my$go_policy=$sth->{go_policy};my$dbh_attribute_update=$go_policy->dbh_attribute_update();$request->dbh_attributes($go_policy->dbh_attribute_list())if$dbh_attribute_update eq 'every' or $dbh->{go_request_count}==1;my$transport=$sth->{go_transport}or return$sth->set_err($DBI::stderr,"Not connected (no transport)");local$transport->{go_cache}=$sth->{go_cache}if defined$sth->{go_cache};my ($response,$retransmit_sub)=$transport->transmit_request($request);$response ||= $transport->receive_response($request,$retransmit_sub);$sth->{go_response}=$response or die "No response object returned by $transport";$dbh->{go_response}=$response;if (my$dbh_attributes=$response->dbh_attributes){$dbh->{$_}=$dbh_attributes->{$_}for keys %$dbh_attributes;$dbh->{go_dbh_attributes_fetched}=$dbh_attributes}my$rv=$response->rv;if ($response->sth_resultsets){$sth->more_results}else {$sth->STORE(Active=>0);$sth->{go_rows}=$rv}DBD::Gofer::set_err_from_response($sth,$response);return$rv}sub bind_param {my ($sth,$param,$value,$attr)=@_;$sth->{ParamValues}{$param}=$value;$sth->{ParamAttr}{$param}=$attr if defined$attr;return 1}sub execute {my$sth=shift;$sth->bind_param($_,$_[$_-1])for (1..@_);push @{$sth->{go_method_calls}},['execute' ];my$meta={go_last_insert_id_args=>$sth->{go_last_insert_id_args}};return$sth->go_sth_method($meta)}sub more_results {my$sth=shift;$sth->finish;my$response=$sth->{go_response}or do {$sth->trace_msg("    No response object present",3);return};my$resultset_list=$response->sth_resultsets or return$sth->set_err($DBI::stderr,"No sth_resultsets");my$meta=shift @$resultset_list or return undef;my ($rowset,$err,$errstr,$state)=delete @{$meta}{qw(rowset err errstr state)};my$NUM_OF_FIELDS=delete$meta->{NUM_OF_FIELDS};$sth->STORE('NUM_OF_FIELDS',$NUM_OF_FIELDS);$sth->{$_}=$meta->{$_}for keys %$meta;if (($NUM_OF_FIELDS||0)> 0){$sth->{go_rows}=($rowset)? @$rowset : -1;$sth->{go_current_rowset}=$rowset;$sth->{go_current_rowset_err}=[$err,$errstr,$state ]if defined$err;$sth->STORE(Active=>1)if$rowset}return$sth}sub go_clone_sth {my ($sth1)=@_;my$sth2=$sth1->{Database}->prepare($sth1->{Statement},{go_skip_prepare_check=>1 });$sth2->STORE($_,$sth1->{$_})for qw(NUM_OF_FIELDS Active);my$sth2_inner=tied %$sth2;$sth2_inner->{$_}=$sth1->{$_}for qw(NUM_OF_PARAMS FetchHashKeyName);die "not fully implemented yet";return$sth2}sub fetchrow_arrayref {my ($sth)=@_;my$resultset=$sth->{go_current_rowset}|| do {my$rowset_err=$sth->{go_current_rowset_err}|| [1,'no result set (did execute fail)' ];return$sth->set_err(@$rowset_err)};return$sth->_set_fbav(shift @$resultset)if @$resultset;$sth->finish;return undef}*fetch=\&fetchrow_arrayref;sub fetchall_arrayref {my ($sth,$slice,$max_rows)=@_;my$resultset=$sth->{go_current_rowset}|| do {my$rowset_err=$sth->{go_current_rowset_err}|| [1,'no result set (did execute fail)' ];return$sth->set_err(@$rowset_err)};my$mode=ref($slice)|| 'ARRAY';return$sth->SUPER::fetchall_arrayref($slice,$max_rows)if ref($slice)or defined$max_rows;$sth->finish;return$resultset}sub rows {return shift->{go_rows}}sub STORE {my ($sth,$attrib,$value)=@_;return$sth->SUPER::STORE($attrib=>$value)if$sth_local_store_attrib{$attrib}or $attrib =~ /^private_/;my$msg="Altering \$sth->{$attrib} won't affect proxied handle";Carp::carp($msg)if$sth->FETCH('Warn');$sth->SUPER::STORE($attrib=>$value);return$sth->set_err($DBI::stderr,$msg)}sub execute_array {my$sth=shift;my$attr=shift;$sth->bind_param_array($_,$_[$_-1])for (1..@_);push @{$sth->{go_method_calls}},['execute_array',$attr ];return$sth->go_sth_method($attr)}*go_cache=\&DBD::Gofer::go_cache}1;
DBD_GOFER

$fatpacked{"DBD/Gofer/Policy/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_GOFER_POLICY_BASE';
  package DBD::Gofer::Policy::Base;use strict;use warnings;use Carp;our$VERSION="0.03";our$AUTOLOAD;my%policy_defaults=(connect_method=>'connect',prepare_method=>'prepare',skip_connect_check=>0,skip_default_methods=>0,skip_prepare_check=>0,skip_ping=>0,dbh_attribute_update=>'every',dbh_attribute_list=>['*'],locally_quote=>0,locally_quote_identifier=>0,cache_parse_trace_flags=>1,cache_parse_trace_flag=>1,cache_data_sources=>1,cache_type_info_all=>1,cache_tables=>0,cache_table_info=>0,cache_column_info=>0,cache_primary_key_info=>0,cache_foreign_key_info=>0,cache_statistics_info=>0,cache_get_info=>0,cache_func=>0,);my$base_policy_file=$INC{"DBD/Gofer/Policy/Base.pm"};__PACKAGE__->create_policy_subs(\%policy_defaults);sub create_policy_subs {my ($class,$policy_defaults)=@_;while (my ($policy_name,$policy_default)=each %$policy_defaults){my$policy_attr_name="go_$policy_name";my$sub=sub {return (ref $_[1]&& exists $_[1]->{$policy_attr_name})? $_[1]->{$policy_attr_name}: $policy_default};no strict 'refs';*{$class .'::' .$policy_name}=$sub}}sub AUTOLOAD {carp "Unknown policy name $AUTOLOAD used";no strict 'refs';*$AUTOLOAD=sub {undef};return undef}sub new {my ($class,$args)=@_;my$policy={};bless$policy,$class}sub DESTROY {};1;
DBD_GOFER_POLICY_BASE

$fatpacked{"DBD/Gofer/Policy/classic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_GOFER_POLICY_CLASSIC';
  package DBD::Gofer::Policy::classic;use strict;use warnings;our$VERSION="0.03";use base qw(DBD::Gofer::Policy::Base);__PACKAGE__->create_policy_subs({connect_method=>'connect_cached',prepare_method=>'',skip_connect_check=>0,skip_prepare_check=>1,skip_default_methods=>1,skip_ping=>1,dbh_attribute_update=>'first',cache_get_info=>1,});1;
DBD_GOFER_POLICY_CLASSIC

$fatpacked{"DBD/Gofer/Policy/pedantic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_GOFER_POLICY_PEDANTIC';
  package DBD::Gofer::Policy::pedantic;use strict;use warnings;our$VERSION="0.03";use base qw(DBD::Gofer::Policy::Base);1;
DBD_GOFER_POLICY_PEDANTIC

$fatpacked{"DBD/Gofer/Policy/rush.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_GOFER_POLICY_RUSH';
  package DBD::Gofer::Policy::rush;use strict;use warnings;our$VERSION="0.03";use base qw(DBD::Gofer::Policy::Base);__PACKAGE__->create_policy_subs({connect_method=>'connect_cached',prepare_method=>'',skip_connect_check=>1,skip_prepare_check=>1,skip_default_methods=>1,skip_ping=>1,dbh_attribute_update=>'none',cache_tables=>1,cache_table_info=>1,cache_column_info=>1,cache_primary_key_info=>1,cache_foreign_key_info=>1,cache_statistics_info=>1,cache_get_info=>1,});1;
DBD_GOFER_POLICY_RUSH

$fatpacked{"DBD/Gofer/Transport/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_GOFER_TRANSPORT_BASE';
  package DBD::Gofer::Transport::Base;use strict;use warnings;use base qw(DBI::Gofer::Transport::Base);our$VERSION="0.03";__PACKAGE__->mk_accessors(qw(trace go_dsn go_url go_policy go_timeout go_retry_hook go_retry_limit go_cache cache_hit cache_miss cache_store));__PACKAGE__->mk_accessors_using(make_accessor_autoviv_hashref=>qw(meta));sub new {my ($class,$args)=@_;$args->{$_}=0 for (qw(cache_hit cache_miss cache_store));$args->{keep_meta_frozen}||= 1 if$args->{go_cache};return$class->SUPER::new($args)}sub _init_trace {$ENV{DBD_GOFER_TRACE}|| 0}sub new_response {my$self=shift;return DBI::Gofer::Response->new(@_)}sub transmit_request {my ($self,$request)=@_;my$trace=$self->trace;my$response;my ($go_cache,$request_cache_key);if ($go_cache=$self->{go_cache}){$request_cache_key =$request->{meta}{request_cache_key}=$self->get_cache_key_for_request($request);if ($request_cache_key){my$frozen_response=eval {$go_cache->get($request_cache_key)};if ($frozen_response){$self->_dump("cached response found for ".ref($request),$request)if$trace;$response=$self->thaw_response($frozen_response);$self->trace_msg("transmit_request is returning a response from cache $go_cache\n")if$trace;++$self->{cache_hit};return$response}warn $@ if $@;++$self->{cache_miss};$self->trace_msg("transmit_request cache miss\n")if$trace}}my$to=$self->go_timeout;my$transmit_sub=sub {$self->trace_msg("transmit_request\n")if$trace;local$SIG{ALRM}=sub {die "TIMEOUT\n"}if$to;my$response=eval {local$SIG{PIPE}=sub {my$extra=($! eq "Broken pipe")? "" : " ($!)";die "Unable to send request: Broken pipe$extra\n"};alarm($to)if$to;$self->transmit_request_by_transport($request)};alarm(0)if$to;if ($@){return$self->transport_timedout("transmit_request",$to)if $@ eq "TIMEOUT\n";return$self->new_response({err=>1,errstr=>$@ })}return$response};$response=$self->_transmit_request_with_retries($request,$transmit_sub);if ($response){my$frozen_response=delete$response->{meta}{frozen};$self->_store_response_in_cache($frozen_response,$request_cache_key)if$request_cache_key}$self->trace_msg("transmit_request is returning a response itself\n")if$trace && $response;return$response unless wantarray;return ($response,$transmit_sub)}sub _transmit_request_with_retries {my ($self,$request,$transmit_sub)=@_;my$response;do {$response=$transmit_sub->()}while ($response && $self->response_needs_retransmit($request,$response));return$response}sub receive_response {my ($self,$request,$retransmit_sub)=@_;my$to=$self->go_timeout;my$receive_sub=sub {$self->trace_msg("receive_response\n");local$SIG{ALRM}=sub {die "TIMEOUT\n"}if$to;my$response=eval {alarm($to)if$to;$self->receive_response_by_transport($request)};alarm(0)if$to;if ($@){return$self->transport_timedout("receive_response",$to)if $@ eq "TIMEOUT\n";return$self->new_response({err=>1,errstr=>$@ })}return$response};my$response;do {$response=$receive_sub->();if ($self->response_needs_retransmit($request,$response)){$response=$self->_transmit_request_with_retries($request,$retransmit_sub);$response ||= $receive_sub->()}}while ($self->response_needs_retransmit($request,$response));if ($response){my$frozen_response=delete$response->{meta}{frozen};my$request_cache_key=$request->{meta}{request_cache_key};$self->_store_response_in_cache($frozen_response,$request_cache_key)if$request_cache_key && $self->{go_cache}}return$response}sub response_retry_preference {my ($self,$request,$response)=@_;if (my$go_retry_hook=$self->go_retry_hook){my$retry=$go_retry_hook->($request,$response,$self);$self->trace_msg(sprintf "go_retry_hook returned %s\n",(defined$retry)? $retry : 'undef');return$retry if defined$retry}return 0 if$response->executed_flag_set;return 1 if ($response->errstr || '')=~ m/induced by DBI_GOFER_RANDOM/;return 1 if$request->is_idempotent;return undef}sub response_needs_retransmit {my ($self,$request,$response)=@_;my$err=$response->err or return 0;my$retry=$self->response_retry_preference($request,$response);if (!$retry){$self->trace_msg("response_needs_retransmit: response not suitable for retry\n");return 0}my$retry_limit=$self->go_retry_limit;if (!$retry_limit){$self->trace_msg("response_needs_retransmit: retries disabled (retry_limit not set)\n");return 0}my$request_meta=$request->meta;my$retry_count=$request_meta->{retry_count}|| 0;if ($retry_count >= $retry_limit){$self->trace_msg("response_needs_retransmit: $retry_count is too many retries\n");$response->errstr(sprintf "%s (after %d retries by gofer)",$response->errstr,$retry_count);return 0}++$retry_count;$self->trace_msg("response_needs_retransmit: retry $retry_count\n");if (ref$retry eq 'CODE'){$retry->($retry_count,$retry_limit)and warn "should return false"}++$request_meta->{retry_count};++$self->meta->{request_retry_count};return 1}sub transport_timedout {my ($self,$method,$timeout)=@_;$timeout ||= $self->go_timeout;return$self->new_response({err=>1,errstr=>"DBD::Gofer $method timed-out after $timeout seconds" })}sub get_cache_key_for_request {my ($self,$request)=@_;return undef if not $request->is_idempotent;my$key=$self->freeze_request($request,undef,1);return$key}sub _store_response_in_cache {my ($self,$frozen_response,$request_cache_key)=@_;my$go_cache=$self->{go_cache}or return;warn "No meta frozen in response" if!$frozen_response;warn "No request_cache_key" if!$request_cache_key;if ($frozen_response && $request_cache_key){$self->trace_msg("receive_response added response to cache $go_cache\n");eval {$go_cache->set($request_cache_key,$frozen_response)};warn $@ if $@;++$self->{cache_store}}}1;
DBD_GOFER_TRANSPORT_BASE

$fatpacked{"DBD/Gofer/Transport/corostream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_GOFER_TRANSPORT_COROSTREAM';
  package DBD::Gofer::Transport::corostream;use strict;use warnings;use Carp;use Coro::Select;use Coro;use Coro::Handle;use base qw(DBD::Gofer::Transport::stream);sub start_pipe_command {local$ENV{DBI_PUREPERL}=$ENV{DBI_PUREPERL_COROCHILD};my$connection=shift->SUPER::start_pipe_command(@_);return$connection}1;
DBD_GOFER_TRANSPORT_COROSTREAM

$fatpacked{"DBD/Gofer/Transport/null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_GOFER_TRANSPORT_NULL';
  package DBD::Gofer::Transport::null;use strict;use warnings;use base qw(DBD::Gofer::Transport::Base);use DBI::Gofer::Execute;our$VERSION="0.03";__PACKAGE__->mk_accessors(qw(pending_response transmit_count));my$executor=DBI::Gofer::Execute->new();sub transmit_request_by_transport {my ($self,$request)=@_;$self->transmit_count(($self->transmit_count()||0)+ 1);my$frozen_request=$self->freeze_request($request);my$response=$executor->execute_request($self->thaw_request($frozen_request,undef,1));$self->pending_response($response);return undef}sub receive_response_by_transport {my$self=shift;my$response=$self->pending_response;my$frozen_response=$self->freeze_response($response,undef,1);return$self->thaw_response($frozen_response)}1;
DBD_GOFER_TRANSPORT_NULL

$fatpacked{"DBD/Gofer/Transport/pipeone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_GOFER_TRANSPORT_PIPEONE';
  package DBD::Gofer::Transport::pipeone;use strict;use warnings;use Carp;use Fcntl;use IO::Select;use IPC::Open3 qw(open3);use Symbol qw(gensym);use base qw(DBD::Gofer::Transport::Base);our$VERSION="0.03";__PACKAGE__->mk_accessors(qw(connection_info go_perl));sub new {my ($self,$args)=@_;$args->{go_perl}||= do {($INC{"blib.pm"})? [$^X,'-Mblib' ]: [$^X ]};if (not ref$args->{go_perl}){$args->{go_perl}=[split /\s{2,}/,$args->{go_perl}]}return$self->SUPER::new($args)}sub nonblock {my$fh=shift;my$flags=fcntl($fh,F_GETFL,0)or croak "Can't get flags for filehandle $fh: $!";fcntl($fh,F_SETFL,$flags | O_NONBLOCK)or croak "Can't make filehandle $fh nonblocking: $!"}sub start_pipe_command {my ($self,$cmd)=@_;$cmd=[$cmd ]unless ref$cmd eq 'ARRAY';local$ENV{DBI_TRACE};local$ENV{DBI_AUTOPROXY};local$ENV{DBI_PROFILE};my ($wfh,$rfh,$efh)=(gensym,gensym,gensym);my$pid=open3($wfh,$rfh,$efh,@$cmd)or die "error starting @$cmd: $!\n";if ($self->trace){$self->trace_msg(sprintf("Started pid $pid: @$cmd {fd: w%d r%d e%d, ppid=$$}\n",fileno$wfh,fileno$rfh,fileno$efh),0)}nonblock($rfh);nonblock($efh);my$ios=IO::Select->new($rfh,$efh);return {cmd=>$cmd,pid=>$pid,wfh=>$wfh,rfh=>$rfh,efh=>$efh,ios=>$ios,}}sub cmd_as_string {my$self=shift;my$connection_info=$self->connection_info;return join " ",map {(m/^[-:\w]*$/)? $_ : "'$_'"}@{$connection_info->{cmd}}}sub transmit_request_by_transport {my ($self,$request)=@_;my$frozen_request=$self->freeze_request($request);my$cmd=[@{$self->go_perl},qw(-MDBI::Gofer::Transport::pipeone -e run_one_stdio)];my$info=$self->start_pipe_command($cmd);my$wfh=delete$info->{wfh};local $\;print$wfh $frozen_request or warn "error writing to @$cmd: $!\n";close$wfh or die "error closing pipe to @$cmd: $!\n";$self->connection_info($info);return}sub read_response_from_fh {my ($self,$fh_actions)=@_;my$trace=$self->trace;my$info=$self->connection_info || die;my ($ios)=@{$info}{qw(ios)};my$errors=0;my$complete;die "No handles to read response from" unless$ios->count;while ($ios->count){my@readable=$ios->can_read();for my$fh (@readable){local $_;my$actions=$fh_actions->{$fh}|| die "panic: no action for $fh";my$rv=sysread($fh,$_='',1024*31);unless ($rv){my$action;unless (defined$rv){$self->trace_msg("error on handle $fh: $!\n")if$trace >= 4;$action=$actions->{error}|| $actions->{eof};++$errors}else {$action=$actions->{eof};$self->trace_msg("eof on handle $fh\n")if$trace >= 4}if ($action->($fh)){$self->trace_msg("removing $fh from handle set\n")if$trace >= 4;$ios->remove($fh)}next}$actions->{read}->($fh)&& ++$complete}last if$complete}return$errors}sub receive_response_by_transport {my$self=shift;my$info=$self->connection_info || die;my ($pid,$rfh,$efh,$ios,$cmd)=@{$info}{qw(pid rfh efh ios cmd)};my$frozen_response;my$stderr_msg;$self->read_response_from_fh({$efh=>{error=>sub {warn "error reading response stderr: $!";1},eof=>sub {warn "eof on stderr" if 0;1},read=>sub {$stderr_msg .= $_;0},},$rfh=>{error=>sub {warn "error reading response: $!";1},eof=>sub {warn "eof on stdout" if 0;1},read=>sub {$frozen_response .= $_;0},},});waitpid$info->{pid},0 or warn "waitpid: $!";die ref($self)." command (@$cmd) failed: $stderr_msg" if not $frozen_response;my$response=$self->thaw_response($frozen_response);if ($stderr_msg){$response->add_err(0,$stderr_msg,undef,$self->trace)unless$stderr_msg =~ /^Using .*blib/ && "@$cmd" =~ /-Mblib/}return$response}1;
DBD_GOFER_TRANSPORT_PIPEONE

$fatpacked{"DBD/Gofer/Transport/stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_GOFER_TRANSPORT_STREAM';
  package DBD::Gofer::Transport::stream;use strict;use warnings;use Carp;use base qw(DBD::Gofer::Transport::pipeone);our$VERSION="0.03";__PACKAGE__->mk_accessors(qw(go_persist));my$persist_all=5;my%persist;sub _connection_key {my ($self)=@_;return join "~",$self->go_url||"",@{$self->go_perl || []}}sub _connection_get {my ($self)=@_;my$persist=$self->go_persist;$persist=$persist_all if not defined$persist;my$key=($persist)? $self->_connection_key : '';if ($persist{$key}&& $self->_connection_check($persist{$key})){$self->trace_msg("reusing persistent connection $key\n",0)if$self->trace >= 1;return$persist{$key}}my$connection=$self->_make_connection;if ($key){%persist=()if keys%persist > $persist_all;$persist{$key}=$connection}return$connection}sub _connection_check {my ($self,$connection)=@_;$connection ||= $self->connection_info;my$pid=$connection->{pid};my$ok=(kill 0,$pid);$self->trace_msg("_connection_check: $ok (pid $$)\n",0)if$self->trace;return$ok}sub _connection_kill {my ($self)=@_;my$connection=$self->connection_info;my ($pid,$wfh,$rfh,$efh)=@{$connection}{qw(pid wfh rfh efh)};$self->trace_msg("_connection_kill: closing write handle\n",0)if$self->trace;close$wfh;delete$persist{$self->_connection_key };$self->connection_info(undef);return}sub _make_connection {my ($self)=@_;my$go_perl=$self->go_perl;my$cmd=[@$go_perl,qw(-MDBI::Gofer::Transport::stream -e run_stdio_hex)];if (my$url=$self->go_url){die "Only 'ssh:user\@host' style url supported by this transport" unless$url =~ s/^ssh://;my$ssh=$url;my$setup_env=join "||",map {"source $_ 2>/dev/null"}qw(.bash_profile .bash_login .profile);my$setup=$setup_env.q{; exec "$@"};$cmd->[0]='perl' if "@$go_perl" eq $^X;unshift @$cmd,qw(ssh -xq),split(' ',$ssh),qw(bash -c),$setup}$self->trace_msg("new connection: @$cmd\n",0)if$self->trace;my$connection=$self->start_pipe_command($cmd);return$connection}sub transmit_request_by_transport {my ($self,$request)=@_;my$trace=$self->trace;my$connection=$self->connection_info || do {my$con=$self->_connection_get;$self->connection_info($con);$con};my$encoded_request=unpack("H*",$self->freeze_request($request));$encoded_request .= "\015\012";my$wfh=$connection->{wfh};$self->trace_msg(sprintf("transmit_request_by_transport: to fh %s fd%d\n",$wfh,fileno($wfh)),0)if$trace >= 4;local $\;$wfh->print($encoded_request)or do {my$err=$!;$self->_connection_kill;die "Error sending request: $err"};$self->trace_msg("Request sent: $encoded_request\n",0)if$trace >= 4;return undef}sub receive_response_by_transport {my$self=shift;my$trace=$self->trace;$self->trace_msg("receive_response_by_transport: awaiting response\n",0)if$trace >= 4;my$connection=$self->connection_info || die;my ($pid,$rfh,$efh,$cmd)=@{$connection}{qw(pid rfh efh cmd)};my$errno=0;my$encoded_response;my$stderr_msg;$self->read_response_from_fh({$efh=>{error=>sub {warn "error reading response stderr: $!";$errno||=$!;1},eof=>sub {warn "eof reading efh" if$trace >= 4;1},read=>sub {$stderr_msg .= $_;0},},$rfh=>{error=>sub {warn "error reading response: $!";$errno||=$!;1},eof=>sub {warn "eof reading rfh" if$trace >= 4;1},read=>sub {$encoded_response .= $_;($encoded_response=~s/\015\012$//)? 1 : 0},},});if (not $encoded_response){my@msg;push@msg,"error while reading response: $errno" if$errno;if ($stderr_msg){chomp$stderr_msg;push@msg,sprintf "error reported by \"%s\" (pid %d%s): %s",$self->cmd_as_string,$pid,((kill 0,$pid)? "" : ", exited"),$stderr_msg}die join(", ","No response received",@msg)."\n"}$self->trace_msg("Response received: $encoded_response\n",0)if$trace >= 4;$self->trace_msg("Gofer stream stderr message: $stderr_msg\n",0)if$stderr_msg && $trace;my$frozen_response=pack("H*",$encoded_response);my$response=$self->thaw_response($frozen_response);if ($stderr_msg){$response->add_err(0,$stderr_msg,undef,$trace)unless$stderr_msg =~ /^Using .*blib/ && "@$cmd" =~ /-Mblib/}return$response}sub transport_timedout {my$self=shift;$self->_connection_kill;return$self->SUPER::transport_timedout(@_)}1;
DBD_GOFER_TRANSPORT_STREAM

$fatpacked{"DBD/NullP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_NULLP';
  use strict;{package DBD::NullP;require DBI;require Carp;our@EXPORT=qw();our$VERSION="0.03";our$drh=undef;sub driver{return$drh if$drh;my($class,$attr)=@_;$class .= "::dr";($drh)=DBI::_new_drh($class,{'Name'=>'NullP','Version'=>$VERSION,'Attribution'=>'DBD Example Null Perl stub by Tim Bunce',},[qw'example implementors private data']);$drh}sub CLONE {undef$drh}}{package DBD::NullP::dr;our$imp_data_size=0;use strict;sub connect {my$dbh=shift->SUPER::connect(@_)or return;$dbh->STORE(Active=>1);$dbh}sub DESTROY {undef}}{package DBD::NullP::db;our$imp_data_size=0;use strict;use Carp qw(croak);sub get_info {my ($dbh,$type)=@_;if ($type==29){return '"'}return}sub table_info {my ($dbh,$catalog,$schema,$table,$type)=@_;my ($outer,$sth)=DBI::_new_sth($dbh,{'Statement'=>'tables',});if (defined($type)&& $type eq '%' && grep {defined($_)&& $_ eq ''}($catalog,$schema,$table)){$outer->{dbd_nullp_data}=[[undef,undef,undef,'TABLE',undef],[undef,undef,undef,'VIEW',undef],[undef,undef,undef,'ALIAS',undef]]}elsif (defined($catalog)&& $catalog eq '%' && grep {defined($_)&& $_ eq ''}($schema,$table)){$outer->{dbd_nullp_data}=[['catalog1',undef,undef,undef,undef],['catalog2',undef,undef,undef,undef]]}else {$outer->{dbd_nullp_data}=[['catalog','schema','table1','TABLE']];$outer->{dbd_nullp_data}=[['catalog','schema','table2','TABLE']];$outer->{dbd_nullp_data}=[['catalog','schema','table3','TABLE']]}$outer->STORE(NUM_OF_FIELDS=>5);$sth->STORE(Active=>1);return$outer}sub prepare {my ($dbh,$statement)=@_;my ($outer,$sth)=DBI::_new_sth($dbh,{'Statement'=>$statement,});return$outer}sub FETCH {my ($dbh,$attrib)=@_;return$dbh->SUPER::FETCH($attrib)}sub STORE {my ($dbh,$attrib,$value)=@_;if ($attrib eq 'AutoCommit'){Carp::croak("Can't disable AutoCommit")unless$value;$value=($value)? -901 : -900}elsif ($attrib eq 'nullp_set_err'){$dbh->set_err($value,$value)}return$dbh->SUPER::STORE($attrib,$value)}sub ping {1}sub disconnect {shift->STORE(Active=>0)}}{package DBD::NullP::st;our$imp_data_size=0;use strict;sub bind_param {my ($sth,$param,$value,$attr)=@_;$sth->{ParamValues}{$param}=$value;$sth->{ParamAttr}{$param}=$attr if defined$attr;return 1}sub execute {my$sth=shift;$sth->bind_param($_,$_[$_-1])for (1..@_);if ($sth->{Statement}=~ m/^ \s* SELECT \s+/xmsi){$sth->STORE(NUM_OF_FIELDS=>1);$sth->{NAME}=["fieldname" ];my$params=$sth->{ParamValues}|| {};$sth->{dbd_nullp_data}=[@{$params}{sort keys %$params }];$sth->STORE(Active=>1)}elsif ($sth->{Statement}=~ m/^ \s* SLEEP \s+ (\S+) /xmsi){my$secs=$1;if (eval {require Time::HiRes;defined&Time::HiRes::sleep}){Time::HiRes::sleep($secs)}else {sleep$secs}}elsif ($sth->{Statement}=~ m/^ \s* ERROR \s+ (\d+) \s* (.*) /xmsi){return$sth->set_err($1,$2)}1}sub fetchrow_arrayref {my$sth=shift;my$data=shift @{$sth->{dbd_nullp_data}};if (!$data ||!@$data){$sth->finish;return undef}return$sth->_set_fbav($data)}*fetch=\&fetchrow_arrayref;sub FETCH {my ($sth,$attrib)=@_;return$sth->SUPER::FETCH($attrib)}sub STORE {my ($sth,$attrib,$value)=@_;return$sth->SUPER::STORE($attrib,$value)}}1;
DBD_NULLP

$fatpacked{"DBD/Proxy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_PROXY';
  use strict;use Carp;require DBI;DBI->require_version(1.0201);use RPC::PlClient 0.2000;{package DBD::Proxy::RPC::PlClient;@DBD::Proxy::RPC::PlClient::ISA=qw(RPC::PlClient);sub Call {my$self=shift;if ($self->{debug}){my ($rpcmeth,$obj,$method,@args)=@_;local $^W;Carp::carp("Server $rpcmeth $method(@args)")}return$self->SUPER::Call(@_)}}package DBD::Proxy;use vars qw($VERSION $drh %ATTR);$VERSION="0.03";$drh=undef;%ATTR=('Warn'=>'local','Active'=>'local','Kids'=>'local','CachedKids'=>'local','PrintError'=>'local','RaiseError'=>'local','HandleError'=>'local','TraceLevel'=>'cached','CompatMode'=>'local',);sub driver ($$) {if (!$drh){my($class,$attr)=@_;$class .= "::dr";$drh=DBI::_new_drh($class,{'Name'=>'Proxy','Version'=>$VERSION,'Attribution'=>'DBD::Proxy by Jochen Wiedmann',});$drh->STORE(CompatMode=>1)}$drh}sub CLONE {undef$drh}sub proxy_set_err {my ($h,$errmsg)=@_;my ($err,$state)=($errmsg =~ s/ \[err=(.*?),state=(.*?)\]//)? ($1,$2): (1,' ' x 5);return$h->set_err($err,$errmsg,$state)}package DBD::Proxy::dr;$DBD::Proxy::dr::imp_data_size=0;sub connect ($$;$$) {my($drh,$dsn,$user,$auth,$attr)=@_;my($dsnOrig)=$dsn;my%attr=%$attr;my ($var,$val);while (length($dsn)){if ($dsn =~ /^dsn=(.*)/){$attr{'dsn'}=$1;last}if ($dsn =~ /^(.*?);(.*)/){$var=$1;$dsn=$2}else {$var=$dsn;$dsn=''}if ($var =~ /^(.*?)=(.*)/){$var=$1;$val=$2;$attr{$var}=$val}}my$err='';if (!defined($attr{'hostname'})){$err .= " Missing hostname."}if (!defined($attr{'port'})){$err .= " Missing port."}if (!defined($attr{'dsn'})){$err .= " Missing remote dsn."}my$cipherRef=undef;if ($attr{'cipher'}){$cipherRef=eval {$attr{'cipher'}->new(pack('H*',$attr{'key'}))};if ($@){$err .= " Cannot create cipher object: $@."}}my$userCipherRef=undef;if ($attr{'userkey'}){my$cipher=$attr{'usercipher'}|| $attr{'cipher'};$userCipherRef=eval {$cipher->new(pack('H*',$attr{'userkey'}))};if ($@){$err .= " Cannot create usercipher object: $@."}}return DBD::Proxy::proxy_set_err($drh,$err)if$err;my%client_opts=('peeraddr'=>$attr{'hostname'},'peerport'=>$attr{'port'},'socket_proto'=>'tcp','application'=>$attr{dsn},'user'=>$user || '','password'=>$auth || '','version'=>$DBD::Proxy::VERSION,'cipher'=>$cipherRef,'debug'=>$attr{debug}|| 0,'timeout'=>$attr{timeout}|| undef,'logfile'=>$attr{logfile}|| undef);while (my($var,$val)=each%attr){if ($var =~ s/^proxy_rpc_//){$client_opts{$var}=$val}}my($client,$msg)=eval {DBD::Proxy::RPC::PlClient->new(%client_opts)};return DBD::Proxy::proxy_set_err($drh,"Cannot log in to DBI::ProxyServer: $@")if $@;return DBD::Proxy::proxy_set_err($drh,"Constructor didn't return a handle: $msg")unless ($msg =~ /^((?:\w+|\:\:)+)=(\w+)/);$msg=RPC::PlClient::Object->new($1,$client,$msg);my$max_proto_ver;my ($server_ver_str)=eval {$client->Call('Version')};if ($@){$max_proto_ver=1}else {my ($server_ver_num)=$server_ver_str =~ /^DBI::ProxyServer\s+([\d\.]+)/;$max_proto_ver=$server_ver_num >= 0.3 ? 2 : 1}my$req_proto_ver;if (exists$attr{proxy_lazy_prepare}){$req_proto_ver=($attr{proxy_lazy_prepare}==0)? 2 : 1;return DBD::Proxy::proxy_set_err($drh,"DBI::ProxyServer does not support synchronous statement preparation.")if$max_proto_ver < $req_proto_ver}if ($userCipherRef){$client->{'cipher'}=$userCipherRef}my$this=DBI::_new_dbh($drh,{'Name'=>$dsnOrig,'proxy_dbh'=>$msg,'proxy_client'=>$client,'RowCacheSize'=>$attr{'RowCacheSize'}|| 20,'proxy_proto_ver'=>$req_proto_ver || 1 });for$var (keys%attr){if ($var =~ /proxy_/){$this->{$var}=$attr{$var}}}$this->SUPER::STORE('Active'=>1);$this}sub DESTROY {undef}package DBD::Proxy::db;$DBD::Proxy::db::imp_data_size=0;sub commit;sub rollback;sub ping;use vars qw(%ATTR $AUTOLOAD);%ATTR=(%DBD::Proxy::ATTR,RowCacheSize=>'inherited','FetchHashKeyName'=>'cached',Statement=>'local',Driver=>'local',dbi_connect_closure=>'local',Username=>'local',);sub AUTOLOAD {my$method=$AUTOLOAD;$method =~ s/(.*::(.*)):://;my$class=$1;my$type=$2;my%expand=('method'=>$method,'class'=>$class,'type'=>$type,'call'=>"$method(\@_)",);my$method_code=q{
          package ~class~;
          sub ~method~ {
              my $h = shift;
              local $@;
              my @result = wantarray
                  ? eval {        $h->{'proxy_~type~h'}->~call~ }
                  : eval { scalar $h->{'proxy_~type~h'}->~call~ };
              return DBD::Proxy::proxy_set_err($h, $@) if $@;
              return wantarray ? @result : $result[0];
          }
      };$method_code =~ s/\~(\w+)\~/$expand{$1}/eg;local$SIG{__DIE__}='DEFAULT';my$err=do {local $@;eval$method_code.2;$@};die$err if$err;goto &$AUTOLOAD}sub DESTROY {my$dbh=shift;local $@ if $@;$dbh->disconnect if$dbh->SUPER::FETCH('Active')}sub connected {}sub disconnect ($) {my ($dbh)=@_;my$rdbh=$dbh->{'proxy_dbh'};if ($rdbh){local$SIG{__DIE__}='DEFAULT';local $@;eval {$rdbh->disconnect()};DBD::Proxy::proxy_set_err($dbh,$@)if $@}$dbh->{proxy_client}->{socket}=undef;$dbh->SUPER::STORE('Active'=>0);1}sub STORE ($$$) {my($dbh,$attr,$val)=@_;my$type=$ATTR{$attr}|| 'remote';if ($attr eq 'TraceLevel'){warn("TraceLevel $val");my$pc=$dbh->{proxy_client}|| die;$pc->{logfile}||= 1;$pc->{debug}=($val && $val >= 4);$pc->Debug("$pc debug enabled")if$pc->{debug}}if ($attr =~ /^proxy_/ || $type eq 'inherited'){$dbh->{$attr}=$val;return 1}if ($type eq 'remote' || $type eq 'cached'){local$SIG{__DIE__}='DEFAULT';local $@;my$result=eval {$dbh->{'proxy_dbh'}->STORE($attr=>$val)};return DBD::Proxy::proxy_set_err($dbh,$@)if $@;$dbh->SUPER::STORE($attr=>$val)if$type eq 'cached';return$result}return$dbh->SUPER::STORE($attr=>$val)}sub FETCH ($$) {my($dbh,$attr)=@_;my$type=$ATTR{$attr}|| 'remote';if ($attr =~ /^proxy_/ || $type eq 'inherited' || $type eq 'cached'){return$dbh->{$attr}}return$dbh->SUPER::FETCH($attr)unless$type eq 'remote';local$SIG{__DIE__}='DEFAULT';local $@;my$result=eval {$dbh->{'proxy_dbh'}->FETCH($attr)};return DBD::Proxy::proxy_set_err($dbh,$@)if $@;return$result}sub prepare ($$;$) {my($dbh,$stmt,$attr)=@_;my$sth=DBI::_new_sth($dbh,{'Statement'=>$stmt,'proxy_attr'=>$attr,'proxy_cache_only'=>0,'proxy_params'=>[],});my$proto_ver=$dbh->{'proxy_proto_ver'};if ($proto_ver > 1){$sth->{'proxy_attr_cache'}={cache_filled=>0};my$rdbh=$dbh->{'proxy_dbh'};local$SIG{__DIE__}='DEFAULT';local $@;my$rsth=eval {$rdbh->prepare($sth->{'Statement'},$sth->{'proxy_attr'},undef,$proto_ver)};return DBD::Proxy::proxy_set_err($sth,$@)if $@;return DBD::Proxy::proxy_set_err($sth,"Constructor didn't return a handle: $rsth")unless ($rsth =~ /^((?:\w+|\:\:)+)=(\w+)/);my$client=$dbh->{'proxy_client'};$rsth=RPC::PlClient::Object->new($1,$client,$rsth);$sth->{'proxy_sth'}=$rsth;$sth->{'RowCacheSize'}=1 if$stmt =~ /\bfor\s+update\b/i;$sth->SUPER::STORE(Active=>1)}$sth}sub quote {my$dbh=shift;my$proxy_quote=$dbh->{proxy_quote}|| 'remote';return$dbh->SUPER::quote(@_)if$proxy_quote eq 'local' && @_==1;local$SIG{__DIE__}='DEFAULT';local $@;my$result=eval {$dbh->{'proxy_dbh'}->quote(@_)};return DBD::Proxy::proxy_set_err($dbh,$@)if $@;return$result}sub table_info {my$dbh=shift;my$rdbh=$dbh->{'proxy_dbh'};local$SIG{__DIE__}='DEFAULT';local $@;my($numFields,$names,$types,@rows)=eval {$rdbh->table_info(@_)};return DBD::Proxy::proxy_set_err($dbh,$@)if $@;my ($sth,$inner)=DBI::_new_sth($dbh,{'Statement'=>"SHOW TABLES",'proxy_params'=>[],'proxy_data'=>\@rows,'proxy_attr_cache'=>{'NUM_OF_PARAMS'=>0,'NUM_OF_FIELDS'=>$numFields,'NAME'=>$names,'TYPE'=>$types,'cache_filled'=>1 },'proxy_cache_only'=>1,});$sth->SUPER::STORE('NUM_OF_FIELDS'=>$numFields);$inner->{NAME}=$names;$inner->{TYPE}=$types;$sth->SUPER::STORE('Active'=>1);$sth->{'proxy_rows'}=@rows;return$sth}sub tables {my$dbh=shift;return$dbh->SUPER::tables(@_)}sub type_info_all {my$dbh=shift;local$SIG{__DIE__}='DEFAULT';local $@;my$result=eval {$dbh->{'proxy_dbh'}->type_info_all(@_)};return DBD::Proxy::proxy_set_err($dbh,$@)if $@;return$result}package DBD::Proxy::st;$DBD::Proxy::st::imp_data_size=0;use vars qw(%ATTR);%ATTR=(%DBD::Proxy::ATTR,'Database'=>'local','RowsInCache'=>'local','RowCacheSize'=>'inherited','NULLABLE'=>'cache_only','NAME'=>'cache_only','TYPE'=>'cache_only','PRECISION'=>'cache_only','SCALE'=>'cache_only','NUM_OF_FIELDS'=>'cache_only','NUM_OF_PARAMS'=>'cache_only');*AUTOLOAD=\&DBD::Proxy::db::AUTOLOAD;sub execute ($@) {my$sth=shift;my$params=@_ ? \@_ : $sth->{'proxy_params'};undef$sth->{'proxy_data'};undef$sth->{'proxy_rows'};my$rsth=$sth->{proxy_sth};my$dbh=$sth->FETCH('Database');my$proto_ver=$dbh->{proxy_proto_ver};my ($numRows,@outData);local$SIG{__DIE__}='DEFAULT';local $@;if ($proto_ver > 1){($numRows,@outData)=eval {$rsth->execute($params,$proto_ver)};return DBD::Proxy::proxy_set_err($sth,$@)if $@;unless ($sth->{proxy_attr_cache}->{cache_filled}){my ($numFields,$numParams,$names,$types)=splice(@outData,0,4);$sth->{'proxy_attr_cache'}={'NUM_OF_FIELDS'=>$numFields,'NUM_OF_PARAMS'=>$numParams,'NAME'=>$names,'cache_filled'=>1 };$sth->SUPER::STORE('NUM_OF_FIELDS'=>$numFields);$sth->SUPER::STORE('NUM_OF_PARAMS'=>$numParams)}}else {if ($rsth){($numRows,@outData)=eval {$rsth->execute($params,$proto_ver)};return DBD::Proxy::proxy_set_err($sth,$@)if $@}else {my$rdbh=$dbh->{'proxy_dbh'};($rsth,@outData)=eval {$rdbh->prepare($sth->{'Statement'},$sth->{'proxy_attr'},$params,$proto_ver)};return DBD::Proxy::proxy_set_err($sth,$@)if $@;return DBD::Proxy::proxy_set_err($sth,"Constructor didn't return a handle: $rsth")unless ($rsth =~ /^((?:\w+|\:\:)+)=(\w+)/);my$client=$dbh->{'proxy_client'};$rsth=RPC::PlClient::Object->new($1,$client,$rsth);my ($numFields,$numParams,$names,$types)=splice(@outData,0,4);$sth->{'proxy_sth'}=$rsth;$sth->{'proxy_attr_cache'}={'NUM_OF_FIELDS'=>$numFields,'NUM_OF_PARAMS'=>$numParams,'NAME'=>$names };$sth->SUPER::STORE('NUM_OF_FIELDS'=>$numFields);$sth->SUPER::STORE('NUM_OF_PARAMS'=>$numParams);$numRows=shift@outData}}$sth->SUPER::STORE('Active'=>1)if$sth->FETCH('NUM_OF_FIELDS');$sth->{'proxy_rows'}=$numRows;if (@outData){for my$p (@$params){if (ref($p->[0])){my$ref=shift@outData;${$p->[0]}=$$ref}}}$sth->{'proxy_rows'}|| '0E0'}sub fetch ($) {my$sth=shift;my$data=$sth->{'proxy_data'};$sth->{'proxy_rows'}=0 unless defined$sth->{'proxy_rows'};if(!$data ||!@$data){return undef unless$sth->SUPER::FETCH('Active');my$rsth=$sth->{'proxy_sth'};if (!$rsth){die "Attempt to fetch row without execute"}my$num_rows=$sth->FETCH('RowCacheSize')|| 20;local$SIG{__DIE__}='DEFAULT';local $@;my@rows=eval {$rsth->fetch($num_rows)};return DBD::Proxy::proxy_set_err($sth,$@)if $@;unless (@rows==$num_rows){undef$sth->{'proxy_data'};$sth->SUPER::STORE(Active=>0)}return undef unless@rows;$sth->{'proxy_data'}=$data=[@rows]}my$row=shift @$data;$sth->SUPER::STORE(Active=>0)if ($sth->{proxy_cache_only}and!@$data);$sth->{'proxy_rows'}++;return$sth->_set_fbav($row)}*fetchrow_arrayref=\&fetch;sub rows ($) {my$rows=shift->{'proxy_rows'};return (defined$rows)? $rows : -1}sub finish ($) {my($sth)=@_;return 1 unless$sth->SUPER::FETCH('Active');my$rsth=$sth->{'proxy_sth'};$sth->SUPER::STORE('Active'=>0);return 0 unless$rsth;my$no_finish=exists($sth->{'proxy_no_finish'})? $sth->{'proxy_no_finish'}: $sth->FETCH('Database')->{'proxy_no_finish'};unless ($no_finish){local$SIG{__DIE__}='DEFAULT';local $@;my$result=eval {$rsth->finish()};return DBD::Proxy::proxy_set_err($sth,$@)if $@;return$result}1}sub STORE ($$$) {my($sth,$attr,$val)=@_;my$type=$ATTR{$attr}|| 'remote';if ($attr =~ /^proxy_/ || $type eq 'inherited'){$sth->{$attr}=$val;return 1}if ($type eq 'cache_only'){return 0}if ($type eq 'remote' || $type eq 'cached'){my$rsth=$sth->{'proxy_sth'}or return undef;local$SIG{__DIE__}='DEFAULT';local $@;my$result=eval {$rsth->STORE($attr=>$val)};return DBD::Proxy::proxy_set_err($sth,$@)if ($@);return$result if$type eq 'remote'}return$sth->SUPER::STORE($attr=>$val)}sub FETCH ($$) {my($sth,$attr)=@_;if ($attr =~ /^proxy_/){return$sth->{$attr}}my$type=$ATTR{$attr}|| 'remote';if ($type eq 'inherited'){if (exists($sth->{$attr})){return$sth->{$attr}}return$sth->FETCH('Database')->{$attr}}if ($type eq 'cache_only' && exists($sth->{'proxy_attr_cache'}->{$attr})){return$sth->{'proxy_attr_cache'}->{$attr}}if ($type ne 'local'){my$rsth=$sth->{'proxy_sth'}or return undef;local$SIG{__DIE__}='DEFAULT';local $@;my$result=eval {$rsth->FETCH($attr)};return DBD::Proxy::proxy_set_err($sth,$@)if $@;return$result}elsif ($attr eq 'RowsInCache'){my$data=$sth->{'proxy_data'};$data ? @$data : 0}else {$sth->SUPER::FETCH($attr)}}sub bind_param ($$$@) {my$sth=shift;my$param=shift;$sth->{'proxy_params'}->[$param-1]=[@_]}*bind_param_inout=\&bind_param;sub DESTROY {my$sth=shift;$sth->finish if$sth->SUPER::FETCH('Active')}1;
DBD_PROXY

$fatpacked{"DBD/Sponge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBD_SPONGE';
  use strict;{package DBD::Sponge;require DBI;require Carp;our@EXPORT=qw();our$VERSION="0.03";our$drh=undef;my$methods_already_installed;sub driver{return$drh if$drh;DBD::Sponge::db->install_method("sponge_test_installed_method")unless$methods_already_installed++;my($class,$attr)=@_;$class .= "::dr";($drh)=DBI::_new_drh($class,{'Name'=>'Sponge','Version'=>$VERSION,'Attribution'=>"DBD::Sponge $VERSION (fake cursor driver) by Tim Bunce",});$drh}sub CLONE {undef$drh}}{package DBD::Sponge::dr;our$imp_data_size=0}{package DBD::Sponge::db;our$imp_data_size=0;use strict;sub prepare {my($dbh,$statement,$attribs)=@_;my$rows=delete$attribs->{'rows'}or return$dbh->set_err($DBI::stderr,"No rows attribute supplied to prepare");my ($outer,$sth)=DBI::_new_sth($dbh,{'Statement'=>$statement,'rows'=>$rows,(map {exists$attribs->{$_}? ($_=>$attribs->{$_}): ()}qw(execute_hook)),});if (my$behave_like=$attribs->{behave_like}){$outer->{$_}=$behave_like->{$_}foreach (qw(RaiseError PrintError HandleError ShowErrorStatement))}if ($statement =~ /^\s*insert\b/){$sth->{is_insert}=1;my$NUM_OF_PARAMS=$attribs->{NUM_OF_PARAMS}or return$dbh->set_err($DBI::stderr,"NUM_OF_PARAMS not specified for INSERT statement");$sth->STORE('NUM_OF_PARAMS'=>$attribs->{NUM_OF_PARAMS})}else {my$numFields;if ($attribs->{'NUM_OF_FIELDS'}){$numFields=$attribs->{'NUM_OF_FIELDS'}}elsif ($attribs->{'NAME'}){$numFields=@{$attribs->{NAME}}}elsif ($attribs->{'TYPE'}){$numFields=@{$attribs->{TYPE}}}elsif (my$firstrow=$rows->[0]){$numFields=scalar @$firstrow}else {return$dbh->set_err($DBI::stderr,'Cannot determine NUM_OF_FIELDS')}$sth->STORE('NUM_OF_FIELDS'=>$numFields);$sth->{NAME}=$attribs->{NAME}|| [map {"col$_"}1..$numFields ];$sth->{TYPE}=$attribs->{TYPE}|| [(DBI::SQL_VARCHAR())x $numFields ];$sth->{PRECISION}=$attribs->{PRECISION}|| [map {length($sth->{NAME}->[$_])}0..$numFields -1 ];$sth->{SCALE}=$attribs->{SCALE}|| [(0)x $numFields ];$sth->{NULLABLE}=$attribs->{NULLABLE}|| [(2)x $numFields ]}$outer}sub type_info_all {my ($dbh)=@_;my$ti=[{TYPE_NAME=>0,DATA_TYPE=>1,PRECISION=>2,LITERAL_PREFIX=>3,LITERAL_SUFFIX=>4,CREATE_PARAMS=>5,NULLABLE=>6,CASE_SENSITIVE=>7,SEARCHABLE=>8,UNSIGNED_ATTRIBUTE=>9,MONEY=>10,AUTO_INCREMENT=>11,LOCAL_TYPE_NAME=>12,MINIMUM_SCALE=>13,MAXIMUM_SCALE=>14,},['VARCHAR',DBI::SQL_VARCHAR(),undef,"'","'",undef,0,1,1,0,0,0,undef,0,0 ],];return$ti}sub FETCH {my ($dbh,$attrib)=@_;return 1 if$attrib eq 'AutoCommit';return$dbh->SUPER::FETCH($attrib)}sub STORE {my ($dbh,$attrib,$value)=@_;if ($attrib eq 'AutoCommit'){return 1 if$value;Carp::croak("Can't disable AutoCommit")}return$dbh->SUPER::STORE($attrib,$value)}sub sponge_test_installed_method {my ($dbh,@args)=@_;return$dbh->set_err(42,"not enough parameters")unless@args >= 2;return \@args}}{package DBD::Sponge::st;our$imp_data_size=0;use strict;sub execute {my$sth=shift;$sth->{ParamValues}=(@_)? {map {$_=>$_[$_-1]}1..@_ }: undef;if (my$hook=$sth->{execute_hook}){&$hook($sth,@_)or return}if ($sth->{is_insert}){my$row;$row=(@_)? [@_ ]: die "bind_param not supported yet" ;my$NUM_OF_PARAMS=$sth->{NUM_OF_PARAMS};return$sth->set_err($DBI::stderr,@$row." values bound (@$row) but $NUM_OF_PARAMS expected")if @$row!=$NUM_OF_PARAMS;{local $^W;$sth->trace_msg("inserting (@$row)\n")}push @{$sth->{rows}},$row}else {$sth->STORE(Active=>1)}return 1}sub fetch {my ($sth)=@_;my$row=shift @{$sth->{'rows'}};unless ($row){$sth->STORE(Active=>0);return undef}return$sth->_set_fbav($row)}*fetchrow_arrayref=\&fetch;sub FETCH {my ($sth,$attrib)=@_;return$sth->SUPER::FETCH($attrib)}sub STORE {my ($sth,$attrib,$value)=@_;return$sth->SUPER::STORE($attrib,$value)}}1;
DBD_SPONGE

$fatpacked{"DBI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI';
  package DBI;require 5.008_001;BEGIN {our$XS_VERSION=our$VERSION="0.03";$VERSION=eval$VERSION}use Carp();use DynaLoader ();use Exporter ();BEGIN {@ISA=qw(Exporter DynaLoader);@EXPORT=();@EXPORT_OK=qw(%DBI %DBI_methods hash);%EXPORT_TAGS=(sql_types=>[qw(SQL_GUID SQL_WLONGVARCHAR SQL_WVARCHAR SQL_WCHAR SQL_BIGINT SQL_BIT SQL_TINYINT SQL_LONGVARBINARY SQL_VARBINARY SQL_BINARY SQL_LONGVARCHAR SQL_UNKNOWN_TYPE SQL_ALL_TYPES SQL_CHAR SQL_NUMERIC SQL_DECIMAL SQL_INTEGER SQL_SMALLINT SQL_FLOAT SQL_REAL SQL_DOUBLE SQL_DATETIME SQL_DATE SQL_INTERVAL SQL_TIME SQL_TIMESTAMP SQL_VARCHAR SQL_BOOLEAN SQL_UDT SQL_UDT_LOCATOR SQL_ROW SQL_REF SQL_BLOB SQL_BLOB_LOCATOR SQL_CLOB SQL_CLOB_LOCATOR SQL_ARRAY SQL_ARRAY_LOCATOR SQL_MULTISET SQL_MULTISET_LOCATOR SQL_TYPE_DATE SQL_TYPE_TIME SQL_TYPE_TIMESTAMP SQL_TYPE_TIME_WITH_TIMEZONE SQL_TYPE_TIMESTAMP_WITH_TIMEZONE SQL_INTERVAL_YEAR SQL_INTERVAL_MONTH SQL_INTERVAL_DAY SQL_INTERVAL_HOUR SQL_INTERVAL_MINUTE SQL_INTERVAL_SECOND SQL_INTERVAL_YEAR_TO_MONTH SQL_INTERVAL_DAY_TO_HOUR SQL_INTERVAL_DAY_TO_MINUTE SQL_INTERVAL_DAY_TO_SECOND SQL_INTERVAL_HOUR_TO_MINUTE SQL_INTERVAL_HOUR_TO_SECOND SQL_INTERVAL_MINUTE_TO_SECOND) ],sql_cursor_types=>[qw(SQL_CURSOR_FORWARD_ONLY SQL_CURSOR_KEYSET_DRIVEN SQL_CURSOR_DYNAMIC SQL_CURSOR_STATIC SQL_CURSOR_TYPE_DEFAULT) ],utils=>[qw(neat neat_list $neat_maxlen dump_results looks_like_number data_string_diff data_string_desc data_diff sql_type_cast DBIstcf_DISCARD_STRING DBIstcf_STRICT) ],profile=>[qw(dbi_profile dbi_profile_merge dbi_profile_merge_nodes dbi_time) ],);$DBI::dbi_debug=0;$DBI::neat_maxlen=1000;$DBI::stderr=2_000_000_000;if ($ENV{DBI_PUREPERL}){eval {bootstrap DBI$XS_VERSION}if$ENV{DBI_PUREPERL}==1;require DBI::PurePerl if $@ or $ENV{DBI_PUREPERL}>= 2;$DBI::PurePerl ||= 0}else {bootstrap DBI$XS_VERSION}$EXPORT_TAGS{preparse_flags}=[grep {/^DBIpp_\w\w_/}keys %{__PACKAGE__."::"}];Exporter::export_ok_tags(keys%EXPORT_TAGS)}for (qw(trace_msg set_err parse_trace_flag parse_trace_flags)){no strict;*$_=\&{"DBD::_::common::$_"}}use strict;DBI->trace(split /=/,$ENV{DBI_TRACE},2)if$ENV{DBI_TRACE};$DBI::connect_via ||= "connect";if ($INC{'Apache/DBI.pm'}&& $ENV{MOD_PERL}){$DBI::connect_via="Apache::DBI::connect";DBI->trace_msg("DBI connect via $DBI::connect_via in $INC{'Apache/DBI.pm'}\n")}my$HAS_WEAKEN=eval {require Scalar::Util;Scalar::Util::weaken(\my$test);1};%DBI::installed_drh=();sub installed_drivers {%DBI::installed_drh}%DBI::installed_methods=();sub installed_methods {%DBI::installed_methods}tie$DBI::err,'DBI::var','*err';tie$DBI::state,'DBI::var','"state';tie$DBI::lasth,'DBI::var','!lasth';tie$DBI::errstr,'DBI::var','&errstr';tie$DBI::rows,'DBI::var','&rows';sub DBI::var::TIESCALAR{my$var=$_[1];bless \$var,'DBI::var'}sub DBI::var::STORE {Carp::croak("Can't modify \$DBI::${$_[0]} special variable")}my$dbd_prefix_registry={ad_=>{class=>'DBD::AnyData',},ad2_=>{class=>'DBD::AnyData2',},ado_=>{class=>'DBD::ADO',},amzn_=>{class=>'DBD::Amazon',},best_=>{class=>'DBD::BestWins',},csv_=>{class=>'DBD::CSV',},cubrid_=>{class=>'DBD::cubrid',},db2_=>{class=>'DBD::DB2',},dbi_=>{class=>'DBI',},dbm_=>{class=>'DBD::DBM',},df_=>{class=>'DBD::DF',},examplep_=>{class=>'DBD::ExampleP',},f_=>{class=>'DBD::File',},file_=>{class=>'DBD::TextFile',},go_=>{class=>'DBD::Gofer',},ib_=>{class=>'DBD::InterBase',},ing_=>{class=>'DBD::Ingres',},ix_=>{class=>'DBD::Informix',},jdbc_=>{class=>'DBD::JDBC',},mo_=>{class=>'DBD::MO',},monetdb_=>{class=>'DBD::monetdb',},msql_=>{class=>'DBD::mSQL',},mvsftp_=>{class=>'DBD::MVS_FTPSQL',},mysql_=>{class=>'DBD::mysql',},multi_=>{class=>'DBD::Multi' },mx_=>{class=>'DBD::Multiplex',},neo_=>{class=>'DBD::Neo4p',},nullp_=>{class=>'DBD::NullP',},odbc_=>{class=>'DBD::ODBC',},ora_=>{class=>'DBD::Oracle',},pg_=>{class=>'DBD::Pg',},pgpp_=>{class=>'DBD::PgPP',},plb_=>{class=>'DBD::Plibdata',},po_=>{class=>'DBD::PO',},proxy_=>{class=>'DBD::Proxy',},ram_=>{class=>'DBD::RAM',},rdb_=>{class=>'DBD::RDB',},sapdb_=>{class=>'DBD::SAP_DB',},snmp_=>{class=>'DBD::SNMP',},solid_=>{class=>'DBD::Solid',},spatialite_=>{class=>'DBD::Spatialite',},sponge_=>{class=>'DBD::Sponge',},sql_=>{class=>'DBI::DBD::SqlEngine',},sqlite_=>{class=>'DBD::SQLite',},syb_=>{class=>'DBD::Sybase',},sys_=>{class=>'DBD::Sys',},tdat_=>{class=>'DBD::Teradata',},tmpl_=>{class=>'DBD::Template',},tmplss_=>{class=>'DBD::TemplateSS',},tree_=>{class=>'DBD::TreeData',},tuber_=>{class=>'DBD::Tuber',},uni_=>{class=>'DBD::Unify',},vt_=>{class=>'DBD::Vt',},wmi_=>{class=>'DBD::WMI',},x_=>{},xbase_=>{class=>'DBD::XBase',},xl_=>{class=>'DBD::Excel',},yaswi_=>{class=>'DBD::Yaswi',},};my%dbd_class_registry=map {$dbd_prefix_registry->{$_}->{class}=>{prefix=>$_ }}grep {exists$dbd_prefix_registry->{$_}->{class}}keys %{$dbd_prefix_registry};sub dump_dbd_registry {require Data::Dumper;local$Data::Dumper::Sortkeys=1;local$Data::Dumper::Indent=1;print Data::Dumper->Dump([$dbd_prefix_registry],[qw($dbd_prefix_registry)])}my$keeperr={O=>0x0004 };%DBI::DBI_methods=(common=>{'DESTROY'=>{O=>0x004|0x10000 },'CLEAR'=>$keeperr,'EXISTS'=>$keeperr,'FETCH'=>{O=>0x0404 },'FETCH_many'=>{O=>0x0404 },'FIRSTKEY'=>$keeperr,'NEXTKEY'=>$keeperr,'STORE'=>{O=>0x0418 | 0x4 },'DELETE'=>{O=>0x0404 },can=>{O=>0x0100 },debug=>{U=>[1,2,'[$debug_level]'],O=>0x0004 },dump_handle=>{U=>[1,3,'[$message [, $level]]'],O=>0x0004 },err=>$keeperr,errstr=>$keeperr,state=>$keeperr,func=>{O=>0x0006 },parse_trace_flag=>{U=>[2,2,'$name'],O=>0x0404,T=>8 },parse_trace_flags=>{U=>[2,2,'$flags'],O=>0x0404,T=>8 },private_data=>{U=>[1,1],O=>0x0004 },set_err=>{U=>[3,6,'$err, $errmsg [, $state, $method, $rv]'],O=>0x0010 },trace=>{U=>[1,3,'[$trace_level, [$filename]]'],O=>0x0004 },trace_msg=>{U=>[2,3,'$message_text [, $min_level ]' ],O=>0x0004,T=>8 },swap_inner_handle=>{U=>[2,3,'$h [, $allow_reparent ]']},private_attribute_info=>{},visit_child_handles=>{U=>[2,3,'$coderef [, $info ]'],O=>0x0404,T=>4 },},dr=>{'connect'=>{U=>[1,5,'[$db [,$user [,$passwd [,\%attr]]]]'],H=>3,O=>0x8000,T=>0x200 },'connect_cached'=>{U=>[1,5,'[$db [,$user [,$passwd [,\%attr]]]]'],H=>3,O=>0x8000,T=>0x200 },'disconnect_all'=>{U=>[1,1],O=>0x0800,T=>0x200 },data_sources=>{U=>[1,2,'[\%attr]' ],O=>0x0800,T=>0x200 },default_user=>{U=>[3,4,'$user, $pass [, \%attr]' ],T=>0x200 },dbixs_revision=>$keeperr,},db=>{data_sources=>{U=>[1,2,'[\%attr]' ],O=>0x0200 },take_imp_data=>{U=>[1,1],O=>0x10000 },clone=>{U=>[1,2,'[\%attr]'],T=>0x200 },connected=>{U=>[1,0],O=>0x0004,T=>0x200,H=>3 },begin_work=>{U=>[1,2,'[ \%attr ]'],O=>0x0400,T=>0x1000 },commit=>{U=>[1,1],O=>0x0480|0x0800,T=>0x1000 },rollback=>{U=>[1,1],O=>0x0480|0x0800,T=>0x1000 },'do'=>{U=>[2,0,'$statement [, \%attr [, @bind_params ] ]'],O=>0x3200 },last_insert_id=>{U=>[5,6,'$catalog, $schema, $table_name, $field_name [, \%attr ]'],O=>0x2800 },preparse=>{},prepare=>{U=>[2,3,'$statement [, \%attr]'],O=>0xA200 },prepare_cached=>{U=>[2,4,'$statement [, \%attr [, $if_active ] ]'],O=>0xA200 },selectrow_array=>{U=>[2,0,'$statement [, \%attr [, @bind_params ] ]'],O=>0x2000 },selectrow_arrayref=>{U=>[2,0,'$statement [, \%attr [, @bind_params ] ]'],O=>0x2000 },selectrow_hashref=>{U=>[2,0,'$statement [, \%attr [, @bind_params ] ]'],O=>0x2000 },selectall_arrayref=>{U=>[2,0,'$statement [, \%attr [, @bind_params ] ]'],O=>0x2000 },selectall_array=>{U=>[2,0,'$statement [, \%attr [, @bind_params ] ]'],O=>0x2000 },selectall_hashref=>{U=>[3,0,'$statement, $keyfield [, \%attr [, @bind_params ] ]'],O=>0x2000 },selectcol_arrayref=>{U=>[2,0,'$statement [, \%attr [, @bind_params ] ]'],O=>0x2000 },ping=>{U=>[1,1],O=>0x0404 },disconnect=>{U=>[1,1],O=>0x0400|0x0800|0x10000,T=>0x200 },quote=>{U=>[2,3,'$string [, $data_type ]' ],O=>0x0430,T=>2 },quote_identifier=>{U=>[2,6,'$name [, ...] [, \%attr ]' ],O=>0x0430,T=>2 },rows=>$keeperr,tables=>{U=>[1,6,'$catalog, $schema, $table, $type [, \%attr ]' ],O=>0x2200 },table_info=>{U=>[1,6,'$catalog, $schema, $table, $type [, \%attr ]' ],O=>0x2200|0x8800 },column_info=>{U=>[5,6,'$catalog, $schema, $table, $column [, \%attr ]'],O=>0x2200|0x8800 },primary_key_info=>{U=>[4,5,'$catalog, $schema, $table [, \%attr ]' ],O=>0x2200|0x8800 },primary_key=>{U=>[4,5,'$catalog, $schema, $table [, \%attr ]' ],O=>0x2200 },foreign_key_info=>{U=>[7,8,'$pk_catalog, $pk_schema, $pk_table, $fk_catalog, $fk_schema, $fk_table [, \%attr ]' ],O=>0x2200|0x8800 },statistics_info=>{U=>[6,7,'$catalog, $schema, $table, $unique_only, $quick, [, \%attr ]' ],O=>0x2200|0x8800 },type_info_all=>{U=>[1,1],O=>0x2200|0x0800 },type_info=>{U=>[1,2,'$data_type'],O=>0x2200 },get_info=>{U=>[2,2,'$info_type'],O=>0x2200|0x0800 },},st=>{bind_col=>{U=>[3,4,'$column, \\$var [, \%attr]']},bind_columns=>{U=>[2,0,'\\$var1 [, \\$var2, ...]']},bind_param=>{U=>[3,4,'$parameter, $var [, \%attr]']},bind_param_inout=>{U=>[4,5,'$parameter, \\$var, $maxlen, [, \%attr]']},execute=>{U=>[1,0,'[@args]'],O=>0x1040 },bind_param_array=>{U=>[3,4,'$parameter, $var [, \%attr]']},bind_param_inout_array=>{U=>[4,5,'$parameter, \\@var, $maxlen, [, \%attr]']},execute_array=>{U=>[2,0,'\\%attribs [, @args]'],O=>0x1040|0x4000 },execute_for_fetch=>{U=>[2,3,'$fetch_sub [, $tuple_status]'],O=>0x1040|0x4000 },fetch=>undef,fetchrow_arrayref=>undef,fetchrow_hashref=>undef,fetchrow_array=>undef,fetchrow=>undef,fetchall_arrayref=>{U=>[1,3,'[ $slice [, $max_rows]]']},fetchall_hashref=>{U=>[2,2,'$key_field']},blob_read=>{U=>[4,5,'$field, $offset, $len [, \\$buf [, $bufoffset]]']},blob_copy_to_file=>{U=>[3,3,'$field, $filename_or_handleref']},dump_results=>{U=>[1,5,'$maxfieldlen, $linesep, $fieldsep, $filehandle']},more_results=>{U=>[1,1]},finish=>{U=>[1,1]},cancel=>{U=>[1,1],O=>0x0800 },rows=>$keeperr,_get_fbav=>undef,_set_fbav=>{T=>6 },},);while (my ($class,$meths)=each%DBI::DBI_methods){my$ima_trace=0+($ENV{DBI_IMA_TRACE}||0);while (my ($method,$info)=each %$meths){my$fullmeth="DBI::${class}::$method";if (($DBI::dbi_debug & 0xF)==15){my$O=$info->{O}||0;printf "0x%04x %-20s\n",$O,$fullmeth unless$ima_trace &&!($O & $ima_trace)}DBI->_install_method($fullmeth,'DBI.pm',$info)}}{package DBI::common;@DBI::dr::ISA=('DBI::common');@DBI::db::ISA=('DBI::common');@DBI::st::ISA=('DBI::common')}END {return unless defined&DBI::trace_msg;local ($!,$?);DBI->trace_msg(sprintf("    -- DBI::END (\$\@: %s, \$!: %s)\n",$@||'',$!||''),2);$DBI::PERL_ENDING=$DBI::PERL_ENDING=1;DBI->disconnect_all()if%DBI::installed_drh}sub CLONE {_clone_dbis()unless$DBI::PurePerl;DBI->trace_msg("CLONE DBI for new thread\n");while (my ($driver,$drh)=each%DBI::installed_drh){no strict 'refs';next if defined &{"DBD::${driver}::CLONE"};warn("$driver has no driver CLONE() function so is unsafe threaded\n")}%DBI::installed_drh=()}sub parse_dsn {my ($class,$dsn)=@_;$dsn =~ s/^(dbi):(\w*?)(?:\((.*?)\))?://i or return;my ($scheme,$driver,$attr,$attr_hash)=(lc($1),$2,$3);$driver ||= $ENV{DBI_DRIVER}|| '';$attr_hash={split /\s*=>?\s*|\s*,\s*/,$attr,-1 }if$attr;return ($scheme,$driver,$attr,$attr_hash,$dsn)}sub visit_handles {my ($class,$code,$outer_info)=@_;$outer_info={}if not defined$outer_info;my%drh=DBI->installed_drivers;for my$h (values%drh){my$child_info=$code->($h,$outer_info)or next;$h->visit_child_handles($code,$child_info)}return$outer_info}sub connect_cached {my ($class,$dsn,$user,$pass,$attr)=@_;my$dbi_connect_method=($DBI::connect_via eq "Apache::DBI::connect")? 'Apache::DBI::connect' : 'connect_cached';$attr={$attr ? %$attr : (),dbi_connect_method=>$dbi_connect_method,};return$class->connect($dsn,$user,$pass,$attr)}sub connect {my$class=shift;my ($dsn,$user,$pass,$attr,$old_driver)=my@orig_args=@_;my$driver;if ($attr and!ref($attr)){Carp::carp("DBI->connect using 'old-style' syntax is deprecated and will be an error in future versions");($old_driver,$attr)=($attr,$old_driver)}my$connect_meth=$attr->{dbi_connect_method};$connect_meth ||= $DBI::connect_via;$dsn ||= $ENV{DBI_DSN}|| $ENV{DBI_DBNAME}|| '' unless$old_driver;if ($DBI::dbi_debug){local $^W=0;pop @_ if$connect_meth ne 'connect';my@args=@_;$args[2]='****';DBI->trace_msg("    -> $class->$connect_meth(".join(", ",@args).")\n")}Carp::croak('Usage: $class->connect([$dsn [,$user [,$passwd [,\%attr]]]])')if (ref$old_driver or ($attr and not ref$attr)or ref$pass);$dsn =~ s/^dbi:(\w*?)(?:\((.*?)\))?://i or '' =~ /()/;my$driver_attrib_spec=$2 || '';$driver=$old_driver || $1 || $ENV{DBI_DRIVER}or Carp::croak("Can't connect to data source '$dsn' " ."because I can't work out what driver to use " ."(it doesn't seem to contain a 'dbi:driver:' prefix " ."and the DBI_DRIVER env var is not set)");my$proxy;if ($ENV{DBI_AUTOPROXY}&& $driver ne 'Proxy' && $driver ne 'Sponge' && $driver ne 'Switch'){my$dbi_autoproxy=$ENV{DBI_AUTOPROXY};$proxy='Proxy';if ($dbi_autoproxy =~ s/^dbi:(\w*?)(?:\((.*?)\))?://i){$proxy=$1;$driver_attrib_spec=join ",",($driver_attrib_spec)? $driver_attrib_spec : (),($2)? $2 : ()}$dsn="$dbi_autoproxy;dsn=dbi:$driver:$dsn";$driver=$proxy;DBI->trace_msg("       DBI_AUTOPROXY: dbi:$driver($driver_attrib_spec):$dsn\n")}local$ENV{DBI_AUTOPROXY}if$ENV{DBI_AUTOPROXY};my%attributes;if ($old_driver){%attributes=%$attr if$attr}else {%attributes=(PrintError=>1,AutoCommit=>1,ref$attr ? %$attr : (),$driver_attrib_spec ? (split /\s*=>?\s*|\s*,\s*/,$driver_attrib_spec,-1): (),)}$attr=\%attributes;my$drh=$DBI::installed_drh{$driver}|| $class->install_driver($driver)or die "panic: $class->install_driver($driver) failed";$user=$attr->{Username}if defined$attr->{Username};$pass=$attr->{Password}if defined$attr->{Password};delete$attr->{Password};if (!(defined$user && defined$pass)){($user,$pass)=$drh->default_user($user,$pass,$attr)}$attr->{Username}=$user;my$connect_closure=sub {my ($old_dbh,$override_attr)=@_;my$dbh;unless ($dbh=$drh->$connect_meth($dsn,$user,$pass,$attr)){$user='' if!defined$user;$dsn='' if!defined$dsn;my$errstr=$DBI::errstr;$errstr='(no error string)' if!defined$errstr;my$msg="$class connect('$dsn','$user',...) failed: $errstr";DBI->trace_msg("       $msg\n");unless ($attr->{HandleError}&& $attr->{HandleError}->($msg,$drh,$dbh)){Carp::croak($msg)if$attr->{RaiseError};Carp::carp ($msg)if$attr->{PrintError}}$!=0;return$dbh}my$apply={($override_attr)? (%$attr,%$override_attr): %$attr };my$rebless_class=$apply->{RootClass}|| ($class ne 'DBI' ? $class : '');if ($rebless_class){no strict 'refs';if ($apply->{RootClass}){delete$apply->{RootClass};DBI::_load_class($rebless_class,0)}unless (@{"$rebless_class\::db::ISA"}&& @{"$rebless_class\::st::ISA"}){Carp::carp("DBI subclasses '$rebless_class\::db' and ::st are not setup, RootClass ignored");$rebless_class=undef;$class='DBI'}else {$dbh->{RootClass}=$rebless_class;DBI::_set_isa([$rebless_class],'DBI');DBI::_rebless($dbh,$rebless_class)}}if (%$apply){if ($apply->{DbTypeSubclass}){my$DbTypeSubclass=delete$apply->{DbTypeSubclass};DBI::_rebless_dbtype_subclass($dbh,$rebless_class||$class,$DbTypeSubclass)}my$a;for$a (qw(Profile RaiseError PrintError AutoCommit)){next unless exists$apply->{$a};$dbh->{$a}=delete$apply->{$a}}while (my ($a,$v)=each %$apply){eval {$dbh->{$a}=$v};warn $@ if $@}}$dbh->connected(@orig_args);DBI->trace_msg("    <- connect= $dbh\n")if$DBI::dbi_debug & 0xF;return$dbh};my$dbh=&$connect_closure(undef,undef);$dbh->{dbi_connect_closure}=$connect_closure if$dbh;return$dbh}sub disconnect_all {keys%DBI::installed_drh;while (my ($name,$drh)=each%DBI::installed_drh){$drh->disconnect_all()if ref$drh}}sub disconnect {Carp::croak("DBI->disconnect is not a DBI method (read the DBI manual)")}sub install_driver {my$class=shift;my($driver,$attr)=@_;my$drh;$driver ||= $ENV{DBI_DRIVER}|| '';$driver=$1 if$driver =~ s/^DBI:(.*?)://i;Carp::croak("usage: $class->install_driver(\$driver [, \%attr])")unless ($driver and @_<=3);return$drh if$drh=$DBI::installed_drh{$driver};$class->trace_msg("    -> $class->install_driver($driver" .") for $^O perl=$] pid=$$ ruid=$< euid=$>\n")if$DBI::dbi_debug & 0xF;my$driver_class="DBD::$driver";eval qq{package			# hide from PAUSE
  		DBI::_firesafe;		# just in case
  	    require $driver_class;	# load the driver
      };if ($@){my$err=$@;my$advice="";if ($err =~ /Can't find loadable object/){$advice="Perhaps DBD::$driver was statically linked into a new perl binary." ."\nIn which case you need to use that new perl binary." ."\nOr perhaps only the .pm file was installed but not the shared object file."}elsif ($err =~ /Can't locate.*?DBD\/$driver\.pm in \@INC/){my@drv=$class->available_drivers(1);$advice="Perhaps the DBD::$driver perl module hasn't been fully installed,\n" ."or perhaps the capitalisation of '$driver' isn't right.\n" ."Available drivers: ".join(", ",@drv)."."}elsif ($err =~ /Can't load .*? for module DBD::/){$advice="Perhaps a required shared library or dll isn't installed where expected"}elsif ($err =~ /Can't locate .*? in \@INC/){$advice="Perhaps a module that DBD::$driver requires hasn't been fully installed"}Carp::croak("install_driver($driver) failed: $err$advice\n")}if ($DBI::dbi_debug & 0xF){no strict 'refs';(my$driver_file=$driver_class)=~ s/::/\//g;my$dbd_ver=${"$driver_class\::VERSION"}|| "undef";$class->trace_msg("       install_driver: $driver_class version $dbd_ver" ." loaded from $INC{qq($driver_file.pm)}\n")}$class->setup_driver($driver_class);$drh=eval {$driver_class->driver($attr || {})};unless ($drh && ref$drh &&!$@){my$advice="";$@ ||= "$driver_class->driver didn't return a handle";$advice="\nPerhaps the capitalisation of DBD '$driver' isn't right." if $@ =~ /locate object method/;Carp::croak("$driver_class initialisation failed: $@$advice")}$DBI::installed_drh{$driver}=$drh;$class->trace_msg("    <- install_driver= $drh\n")if$DBI::dbi_debug & 0xF;$drh}*driver=\&install_driver;sub setup_driver {my ($class,$driver_class)=@_;my$h_type;for$h_type (qw(dr db st)){my$h_class=$driver_class."::$h_type";no strict 'refs';push @{"${h_class}::ISA"},"DBD::_::$h_type" unless UNIVERSAL::isa($h_class,"DBD::_::$h_type");my$mem_class="DBD::_mem::$h_type";push @{"${h_class}_mem::ISA"},$mem_class unless UNIVERSAL::isa("${h_class}_mem",$mem_class)or $DBI::PurePerl}}sub _rebless {my$dbh=shift;my ($outer,$inner)=DBI::_handles($dbh);my$class=shift(@_).'::db';bless$inner=>$class;bless$outer=>$class}sub _set_isa {my ($classes,$topclass)=@_;my$trace=DBI->trace_msg("       _set_isa([@$classes])\n");for my$suffix ('::db','::st'){my$previous=$topclass || 'DBI';for my$class (@$classes){my$base_class=$previous.$suffix;my$sub_class=$class.$suffix;my$sub_class_isa="${sub_class}::ISA";no strict 'refs';if (@$sub_class_isa){DBI->trace_msg("       $sub_class_isa skipped (already set to @$sub_class_isa)\n")if$trace}else {@$sub_class_isa=($base_class)unless @$sub_class_isa;DBI->trace_msg("       $sub_class_isa = $base_class\n")if$trace}$previous=$class}}}sub _rebless_dbtype_subclass {my ($dbh,$rootclass,$DbTypeSubclass)=@_;my@hierarchy=DBI::_dbtype_names($dbh,$DbTypeSubclass);$_=$rootclass.'::'.$_ foreach (@hierarchy);DBI::_load_class($_,1)foreach (reverse@hierarchy);DBI::_set_isa(\@hierarchy,$rootclass);DBI::_rebless($dbh,$hierarchy[0])}sub _dbtype_names {my ($dbh,$DbTypeSubclass)=@_;if ($DbTypeSubclass && $DbTypeSubclass ne '1' && ref$DbTypeSubclass ne 'CODE'){my@dbtypes=split /\s*,\s*/,$DbTypeSubclass;$dbh->trace_msg("    DbTypeSubclass($DbTypeSubclass)=@dbtypes (explicit)\n");return@dbtypes}my$driver=$dbh->{Driver}->{Name};if ($driver eq 'Proxy'){($driver)=$dbh->{proxy_client}->{application}=~ /^DBI:(.+?):/i or die "Can't determine driver name from proxy"}my@dbtypes=(ucfirst($driver));if ($driver eq 'ODBC' || $driver eq 'ADO'){my$_dbtype_name_regexp='Oracle';my%_dbtype_name_map=('Microsoft SQL Server'=>'MSSQL','SQL Server'=>'Sybase','Adaptive Server Anywhere'=>'ASAny','ADABAS D'=>'AdabasD',);my$name;$name=$dbh->func(17,'GetInfo')if$driver eq 'ODBC';$name=$dbh->{ado_conn}->Properties->Item('DBMS Name')->Value if$driver eq 'ADO';die "Can't determine driver name! ($DBI::errstr)\n" unless$name;my$dbtype;if ($_dbtype_name_map{$name}){$dbtype=$_dbtype_name_map{$name}}else {if ($name =~ /($_dbtype_name_regexp)/){$dbtype=lc($1)}else {$dbtype=lc($name)}$dbtype =~ s/\b(\w)/\U$1/g;$dbtype =~ s/\W+/_/g}push@dbtypes,'ODBC' if$driver eq 'ADO';unshift@dbtypes,$dbtype}@dbtypes=&$DbTypeSubclass($dbh,\@dbtypes)if (ref$DbTypeSubclass eq 'CODE');$dbh->trace_msg("    DbTypeSubclass($DbTypeSubclass)=@dbtypes\n");return@dbtypes}sub _load_class {my ($load_class,$missing_ok)=@_;DBI->trace_msg("    _load_class($load_class, $missing_ok)\n",2);no strict 'refs';return 1 if @{"$load_class\::ISA"};(my$module=$load_class)=~ s!::!/!g;DBI->trace_msg("    _load_class require $module\n",2);eval {require "$module.pm"};return 1 unless $@;return 0 if$missing_ok && $@ =~ /^Can't locate \Q$module.pm\E/;die $@}sub init_rootclass {return 1}*internal=\&DBD::Switch::dr::driver;sub driver_prefix {my ($class,$driver)=@_;return$dbd_class_registry{$driver}->{prefix}if exists$dbd_class_registry{$driver};return}sub available_drivers {my($quiet)=@_;my(@drivers,$d,$f);local(*DBI::DIR,$@);my(%seen_dir,%seen_dbd);my$haveFileSpec=eval {require File::Spec};for$d (@INC){chomp($d);my$dbd_dir=($haveFileSpec ? File::Spec->catdir($d,'DBD'): "$d/DBD");next unless -d $dbd_dir;next if$seen_dir{$d};$seen_dir{$d}=1;opendir(DBI::DIR,$dbd_dir)|| Carp::carp "opendir $dbd_dir: $!\n";for$f (readdir(DBI::DIR)){next unless$f =~ s/\.pm$//;next if$f eq 'NullP';if ($seen_dbd{$f}){Carp::carp "DBD::$f in $d is hidden by DBD::$f in $seen_dbd{$f}\n" unless$quiet}else {push(@drivers,$f)}$seen_dbd{$f}=$d}closedir(DBI::DIR)}return wantarray ? sort@drivers : @drivers}sub installed_versions {my ($class,$quiet)=@_;my%error;my%version;for my$driver ($class->available_drivers($quiet)){next if$DBI::PurePerl && grep {-d "$_/auto/DBD/$driver"}@INC;my$drh=eval {local$SIG{__WARN__}=sub {};$class->install_driver($driver)};($error{"DBD::$driver"}=$@),next if $@;no strict 'refs';my$vers=${"DBD::$driver" .'::VERSION'};$version{"DBD::$driver"}=$vers || '?'}if (wantarray){return map {m/^DBD::(\w+)/ ? ($1): ()}sort keys%version}$version{"DBI"}=$DBI::VERSION;$version{"DBI::PurePerl"}=$DBI::PurePerl::VERSION if$DBI::PurePerl;if (!defined wantarray){require Config;$version{OS}="$^O\t($Config::Config{osvers})";$version{Perl}="$]\t($Config::Config{archname})";$version{$_}=(($error{$_}=~ s/ \(\@INC.*//s),$error{$_})for keys%error;printf "  %-16s: %s\n",$_,$version{$_}for reverse sort keys%version}return \%version}sub data_sources {my ($class,$driver,@other)=@_;my$drh=$class->install_driver($driver);my@ds=$drh->data_sources(@other);return@ds}sub neat_list {my ($listref,$maxlen,$sep)=@_;$maxlen=0 unless defined$maxlen;$sep=", " unless defined$sep;join($sep,map {neat($_,$maxlen)}@$listref)}sub dump_results {my ($sth,$maxlen,$lsep,$fsep,$fh)=@_;return 0 unless$sth;$maxlen ||= 35;$lsep ||= "\n";$fh ||= \*STDOUT;my$rows=0;my$ref;while($ref=$sth->fetch){print$fh $lsep if$rows++ and $lsep;my$str=neat_list($ref,$maxlen,$fsep);print$fh $str}print$fh "\n$rows rows".($DBI::err ? " ($DBI::err: $DBI::errstr)" : "")."\n";$rows}sub data_diff {my ($a,$b,$logical)=@_;my$diff=data_string_diff($a,$b);return "" if$logical and!$diff;my$a_desc=data_string_desc($a);my$b_desc=data_string_desc($b);return "" if!$diff and $a_desc eq $b_desc;$diff ||= "Strings contain the same sequence of characters" if length($a);$diff .= "\n" if$diff;return "a: $a_desc\nb: $b_desc\n$diff"}sub data_string_diff {my ($a,$b)=@_;unless (defined$a and defined$b){return "" if!defined$a and!defined$b;return "String a is undef, string b has ".length($b)." characters" if!defined$a;return "String b is undef, string a has ".length($a)." characters" if!defined$b}require utf8;*utf8::is_utf8=sub {(DBI::neat(shift)=~/^"/)}unless defined&utf8::is_utf8;my@a_chars=(utf8::is_utf8($a))? unpack("U*",$a): unpack("C*",$a);my@b_chars=(utf8::is_utf8($b))? unpack("U*",$b): unpack("C*",$b);my$i=0;while (@a_chars && @b_chars){++$i,shift(@a_chars),shift(@b_chars),next if$a_chars[0]==$b_chars[0];my@desc=map {$_ > 255 ? sprintf("\\x{%04X}",$_): chr($_)=~ /[[:cntrl:]]/ ? sprintf("\\x%02X",$_): chr($_)}($a_chars[0],$b_chars[0]);for my$c (@desc){next unless$c =~ m/\\x\{08(..)}/;$c .= "='" .chr(hex($1))."'"}return sprintf "Strings differ at index $i: a[$i]=$desc[0], b[$i]=$desc[1]"}return "String a truncated after $i characters" if@b_chars;return "String b truncated after $i characters" if@a_chars;return ""}sub data_string_desc {my ($a)=@_;require bytes;require utf8;*utf8::is_utf8=sub {(DBI::neat(shift)=~/^"/)}unless defined&utf8::is_utf8;*utf8::valid=sub {1}unless defined&utf8::valid;my$utf8=sprintf "UTF8 %s%s",utf8::is_utf8($a)? "on" : "off",utf8::valid($a||'')? "" : " but INVALID encoding";return "$utf8, undef" unless defined$a;my$is_ascii=$a =~ m/^[\000-\177]*$/;return sprintf "%s, %s, %d characters %d bytes",$utf8,$is_ascii ? "ASCII" : "non-ASCII",length($a),bytes::length($a)}sub connect_test_perf {my($class,$dsn,$dbuser,$dbpass,$attr)=@_;Carp::croak("connect_test_perf needs hash ref as fourth arg")unless ref$attr;my$loops ||= $attr->{dbi_loops}|| 5;my$par ||= $attr->{dbi_par}|| 1;my$verb ||= $attr->{dbi_verb}|| 1;my$meth ||= $attr->{dbi_meth}|| 'connect';print "$dsn: testing $loops sets of $par connections:\n";require "FileHandle.pm";local $|=1;my$drh=$class->install_driver($dsn)or Carp::croak("Can't install $dsn driver\n");$drh->connect($dsn,$dbuser,$dbpass)or Carp::croak("connect failed: $DBI::errstr");my$t1=dbi_time();my$loop;for$loop (1..$loops){my@cons;print "Connecting... " if$verb;for (1..$par){print "$_ ";push@cons,($drh->connect($dsn,$dbuser,$dbpass)or Carp::croak("connect failed: $DBI::errstr\n"))}print "\nDisconnecting...\n" if$verb;for (@cons){$_->disconnect or warn "disconnect failed: $DBI::errstr"}}my$t2=dbi_time();my$td=$t2 - $t1;printf "$meth %d and disconnect them, %d times: %.4fs / %d = %.4fs\n",$par,$loops,$td,$loops*$par,$td/($loops*$par);return$td}sub err {$DBI::err}sub errstr {$DBI::errstr}*DBI::dr::TIEHASH=\&DBI::st::TIEHASH;*DBI::db::TIEHASH=\&DBI::st::TIEHASH;our$shared_profile;sub _new_drh {my ($class,$initial_attr,$imp_data)=@_;my ($h_state_store,$h_err_store,$h_errstr_store)=(undef,undef,'');my$attr={'State'=>\$h_state_store,'Err'=>\$h_err_store,'Errstr'=>\$h_errstr_store,'TraceLevel'=>0,FetchHashKeyName=>'NAME',%$initial_attr,};my ($h,$i)=_new_handle('DBI::dr','',$attr,$imp_data,$class);if (($ENV{DBI_PROFILE}&&!$DBI::PurePerl)|| $shared_profile){if (!$shared_profile){$h->{Profile}=$ENV{DBI_PROFILE};$shared_profile=$h->{Profile}}else {$h->{Profile}=$shared_profile}}return$h unless wantarray;($h,$i)}sub _new_dbh {my ($drh,$attr,$imp_data)=@_;my$imp_class=$drh->{ImplementorClass}or Carp::croak("DBI _new_dbh: $drh has no ImplementorClass");substr($imp_class,-4,4)='::db';my$app_class=ref$drh;substr($app_class,-4,4)='::db';$attr->{Err}||= \my$err;$attr->{Errstr}||= \my$errstr;$attr->{State}||= \my$state;_new_handle($app_class,$drh,$attr,$imp_data,$imp_class)}sub _new_sth {my ($dbh,$attr,$imp_data)=@_;my$imp_class=$dbh->{ImplementorClass}or Carp::croak("DBI _new_sth: $dbh has no ImplementorClass");substr($imp_class,-4,4)='::st';my$app_class=ref$dbh;substr($app_class,-4,4)='::st';_new_handle($app_class,$dbh,$attr,$imp_data,$imp_class)}{package DBD::Switch::dr;DBI->setup_driver('DBD::Switch');$DBD::Switch::dr::imp_data_size=0;$DBD::Switch::dr::imp_data_size=0;my$drh;sub driver {return$drh if$drh;my$inner;($drh,$inner)=DBI::_new_drh('DBD::Switch::dr',{'Name'=>'Switch','Version'=>$DBI::VERSION,'Attribution'=>"DBI $DBI::VERSION by Tim Bunce",});Carp::croak("DBD::Switch init failed!")unless ($drh && $inner);return$drh}sub CLONE {undef$drh}sub FETCH {my($drh,$key)=@_;return DBI->trace if$key eq 'DebugDispatch';return undef if$key eq 'DebugLog';return$drh->DBD::_::dr::FETCH($key);undef}sub STORE {my($drh,$key,$value)=@_;if ($key eq 'DebugDispatch'){DBI->trace($value)}elsif ($key eq 'DebugLog'){DBI->trace(-1,$value)}else {$drh->DBD::_::dr::STORE($key,$value)}}}{package DBD::_::common;use strict;sub FIRSTKEY {}sub NEXTKEY {}sub EXISTS {defined($_[0]->FETCH($_[1]))}sub CLEAR {Carp::carp "Can't CLEAR $_[0] (DBI)"}sub FETCH_many {my$h=shift;return map {scalar$h->FETCH($_)}@_}*dump_handle=\&DBI::dump_handle;sub install_method {my ($class,$method,$attr)=@_;Carp::croak("Class '$class' must begin with DBD:: and end with ::db or ::st")unless$class =~ /^DBD::(\w+)::(dr|db|st)$/;my ($driver,$subtype)=($1,$2);Carp::croak("invalid method name '$method'")unless$method =~ m/^([a-z][a-z0-9]*_)\w+$/;my$prefix=$1;my$reg_info=$dbd_prefix_registry->{$prefix};Carp::carp("method name prefix '$prefix' is not associated with a registered driver")unless$reg_info;my$full_method="DBI::${subtype}::$method";$DBI::installed_methods{$full_method}=$attr;my (undef,$filename,$line)=caller;my%attr=%{$attr||{}};DBI->_install_method("DBI::${subtype}::$method","$filename at line $line",\%attr)}sub parse_trace_flags {my ($h,$spec)=@_;my$level=0;my$flags=0;my@unknown;for my$word (split /\s*[|&,]\s*/,$spec){if (DBI::looks_like_number($word)&& $word <= 0xF && $word >= 0){$level=$word}elsif ($word eq 'ALL'){$flags=0x7FFFFFFF;last}elsif (my$flag=$h->parse_trace_flag($word)){$flags |= $flag}else {push@unknown,$word}}if (@unknown && (ref$h ? $h->FETCH('Warn'): 1)){Carp::carp("$h->parse_trace_flags($spec) ignored unknown trace flags: ".join(" ",map {DBI::neat($_)}@unknown))}$flags |= $level;return$flags}sub parse_trace_flag {my ($h,$name)=@_;return 0x00000100 if$name eq 'SQL';return 0x00000200 if$name eq 'CON';return 0x00000400 if$name eq 'ENC';return 0x00000800 if$name eq 'DBD';return 0x00001000 if$name eq 'TXN';return}sub private_attribute_info {return undef}sub visit_child_handles {my ($h,$code,$info)=@_;$info={}if not defined$info;for my$ch (@{$h->{ChildHandles}|| []}){next unless$ch;my$child_info=$code->($ch,$info)or next;$ch->visit_child_handles($code,$child_info)}return$info}}{package DBD::_::dr;@DBD::_::dr::ISA=qw(DBD::_::common);use strict;sub default_user {my ($drh,$user,$pass,$attr)=@_;$user=$ENV{DBI_USER}unless defined$user;$pass=$ENV{DBI_PASS}unless defined$pass;return ($user,$pass)}sub connect {my ($drh,$dsn,$user,$auth)=@_;my ($this)=DBI::_new_dbh($drh,{'Name'=>$dsn,});$this}sub connect_cached {my$drh=shift;my ($dsn,$user,$auth,$attr)=@_;my$cache=$drh->{CachedKids}||= {};my$key=do {local $^W;join "!\001",$dsn,$user,$auth,DBI::_concat_hash_sorted($attr,"=\001",",\001",0,0)};my$dbh=$cache->{$key};$drh->trace_msg(sprintf("    connect_cached: key '$key', cached dbh $dbh\n",DBI::neat($key),DBI::neat($dbh)))if (($DBI::dbi_debug & 0xF)>= 4);my$cb=$attr->{Callbacks};if ($dbh && $dbh->FETCH('Active')&& eval {$dbh->ping}){if ($cb and $cb=$cb->{"connect_cached.reused"}){local $_="connect_cached.reused";$cb->($dbh,$dsn,$user,$auth,$attr)}return$dbh}if ($cb and (my$new_cb=$cb->{"connect_cached.new"})){local $_="connect_cached.new";$new_cb->($dbh,$dsn,$user,$auth,$attr)}$dbh=$drh->connect(@_);$cache->{$key}=$dbh;if ($cb and (my$conn_cb=$cb->{"connect_cached.connected"})){local $_="connect_cached.connected";$conn_cb->($dbh,$dsn,$user,$auth,$attr)}return$dbh}}{package DBD::_::db;@DBD::_::db::ISA=qw(DBD::_::common);use strict;sub clone {my ($old_dbh,$attr)=@_;my$closure=$old_dbh->{dbi_connect_closure}or return$old_dbh->set_err($DBI::stderr,"Can't clone handle");unless ($attr){keys %$old_dbh;while (my ($k,$v)=each %$old_dbh){next if ref$v && ref$v ne 'CODE';$attr->{$k}=$v}$attr->{$_}=$old_dbh->FETCH($_)for (qw(AutoCommit ChopBlanks InactiveDestroy AutoInactiveDestroy LongTruncOk PrintError PrintWarn Profile RaiseError ShowErrorStatement TaintIn TaintOut))}my$new_dbh=&$closure($old_dbh,$attr);unless ($new_dbh){my$drh=$old_dbh->{Driver};return$old_dbh->set_err($drh->err,$drh->errstr,$drh->state)}$new_dbh->{dbi_connect_closure}=$closure;return$new_dbh}sub quote_identifier {my ($dbh,@id)=@_;my$attr=(@id > 3 && ref($id[-1]))? pop@id : undef;my$info=$dbh->{dbi_quote_identifier_cache}||= [$dbh->get_info(29)|| '"',$dbh->get_info(41)|| '.',$dbh->get_info(114)|| 1,];my$quote=$info->[0];for (@id){next unless defined;s/$quote/$quote$quote/g;$_=qq{$quote$_$quote}}my$catalog=(@id >= 3)? shift@id : undef;my$quoted_id=join '.',grep {defined}@id;if ($catalog){if ($quoted_id){$quoted_id=($info->[2]==2)? $quoted_id .$info->[1].$catalog : $catalog .$info->[1].$quoted_id}else {$quoted_id=$catalog}}return$quoted_id}sub quote {my ($dbh,$str,$data_type)=@_;return "NULL" unless defined$str;unless ($data_type){$str =~ s/'/''/g;return "'$str'"}my$dbi_literal_quote_cache=$dbh->{'dbi_literal_quote_cache'}||= [{},{}];my ($prefixes,$suffixes)=@$dbi_literal_quote_cache;my$lp=$prefixes->{$data_type};my$ls=$suffixes->{$data_type};if (!defined$lp ||!defined$ls){my$ti=$dbh->type_info($data_type);$lp=$prefixes->{$data_type}=$ti ? $ti->{LITERAL_PREFIX}|| "" : "'";$ls=$suffixes->{$data_type}=$ti ? $ti->{LITERAL_SUFFIX}|| "" : "'"}return$str unless$lp || $ls;$str =~ s/$lp/$lp$lp/g if$lp && $lp eq $ls && ($lp eq "'" || $lp eq '"');return "$lp$str$ls"}sub rows {-1}sub do {my($dbh,$statement,$attr,@params)=@_;my$sth=$dbh->prepare($statement,$attr)or return undef;$sth->execute(@params)or return undef;my$rows=$sth->rows;($rows==0)? "0E0" : $rows}sub _do_selectrow {my ($method,$dbh,$stmt,$attr,@bind)=@_;my$sth=((ref$stmt)? $stmt : $dbh->prepare($stmt,$attr))or return undef;$sth->execute(@bind)or return undef;my$row=$sth->$method()and $sth->finish;return$row}sub selectrow_hashref {return _do_selectrow('fetchrow_hashref',@_)}sub selectrow_arrayref {return _do_selectrow('fetchrow_arrayref',@_)}sub selectrow_array {my$row=_do_selectrow('fetchrow_arrayref',@_)or return;return$row->[0]unless wantarray;return @$row}sub selectall_array {return @{shift->selectall_arrayref(@_)|| []}}sub selectall_arrayref {my ($dbh,$stmt,$attr,@bind)=@_;my$sth=(ref$stmt)? $stmt : $dbh->prepare($stmt,$attr)or return;$sth->execute(@bind)|| return;my$slice=$attr->{Slice};if (!$slice and $slice=$attr->{Columns}){if (ref$slice eq 'ARRAY'){$slice=[@{$attr->{Columns}}];for (@$slice){$_--}}}my$rows=$sth->fetchall_arrayref($slice,my$MaxRows=$attr->{MaxRows});$sth->finish if defined$MaxRows;return$rows}sub selectall_hashref {my ($dbh,$stmt,$key_field,$attr,@bind)=@_;my$sth=(ref$stmt)? $stmt : $dbh->prepare($stmt,$attr);return unless$sth;$sth->execute(@bind)|| return;return$sth->fetchall_hashref($key_field)}sub selectcol_arrayref {my ($dbh,$stmt,$attr,@bind)=@_;my$sth=(ref$stmt)? $stmt : $dbh->prepare($stmt,$attr);return unless$sth;$sth->execute(@bind)|| return;my@columns=($attr->{Columns})? @{$attr->{Columns}}: (1);my@values=(undef)x @columns;my$idx=0;for (@columns){$sth->bind_col($_,\$values[$idx++])|| return}my@col;if (my$max=$attr->{MaxRows}){push@col,@values while 0 < $max-- && $sth->fetch}else {push@col,@values while$sth->fetch}return \@col}sub prepare_cached {my ($dbh,$statement,$attr,$if_active)=@_;my$cache=$dbh->{CachedKids}||= {};my$key=do {local $^W;join "!\001",$statement,DBI::_concat_hash_sorted($attr,"=\001",",\001",0,0)};my$sth=$cache->{$key};if ($sth){return$sth unless$sth->FETCH('Active');Carp::carp("prepare_cached($statement) statement handle $sth still Active")unless ($if_active ||= 0);$sth->finish if$if_active <= 1;return$sth if$if_active <= 2}$sth=$dbh->prepare($statement,$attr);$cache->{$key}=$sth if$sth;return$sth}sub ping {my$dbh=shift;($dbh->FETCH('Active'))? "0 but true" : 0}sub begin_work {my$dbh=shift;return$dbh->set_err($DBI::stderr,"Already in a transaction")unless$dbh->FETCH('AutoCommit');$dbh->STORE('AutoCommit',0);$dbh->STORE('BegunWork',1);return 1}sub primary_key {my ($dbh,@args)=@_;my$sth=$dbh->primary_key_info(@args)or return;my ($row,@col);push@col,$row->[3]while ($row=$sth->fetch);Carp::croak("primary_key method not called in list context")unless wantarray;return@col}sub tables {my ($dbh,@args)=@_;my$sth=$dbh->table_info(@args[0,1,2,3,4])or return;my$tables=$sth->fetchall_arrayref or return;my@tables;if (defined($args[3])&& $args[3]eq '%' && grep {defined($_)&& $_ eq ''}@args[0,1,2]){@tables=map {$_->[3]}@$tables}elsif ($dbh->get_info(29)){@tables=map {$dbh->quote_identifier(@{$_}[0,1,2])}@$tables}else {@tables=map {my$name=$_->[2];if ($_->[1]){my$schema=$_->[1];my$quote=($schema eq uc($schema))? '' : '"';$name="$quote$schema$quote.$name"}$name}@$tables}return@tables}sub type_info {my ($dbh,$data_type)=@_;my$idx_hash;my$tia=$dbh->{dbi_type_info_row_cache};if ($tia){$idx_hash=$dbh->{dbi_type_info_idx_cache}}else {my$temp=$dbh->type_info_all;return unless$temp && @$temp;$tia=$dbh->{dbi_type_info_row_cache}=[@$temp ];$idx_hash=$dbh->{dbi_type_info_idx_cache}=shift @$tia}my$dt_idx=$idx_hash->{DATA_TYPE}|| $idx_hash->{data_type};Carp::croak("type_info_all returned non-standard DATA_TYPE index value ($dt_idx != 1)")if$dt_idx && $dt_idx!=1;my@ti;my@data_type_list=(ref$data_type)? @$data_type : ($data_type);for$data_type (@data_type_list){if (defined($data_type)&& $data_type!=DBI::SQL_ALL_TYPES()){push@ti,grep {$_->[$dt_idx]==$data_type}@$tia}else {push@ti,@$tia}last if@ti}my$idx_fields=keys %$idx_hash;my@idx_names=map {uc($_)}keys %$idx_hash;my@idx_values=values %$idx_hash;Carp::croak "type_info_all result has $idx_fields keys but ".(@{$ti[0]})." fields" if@ti && @{$ti[0]}!=$idx_fields;my@out=map {my%h;@h{@idx_names}=@{$_}[@idx_values ];\%h}@ti;return$out[0]unless wantarray;return@out}sub data_sources {my ($dbh,@other)=@_;my$drh=$dbh->{Driver};return$drh->data_sources(@other)}}{package DBD::_::st;@DBD::_::st::ISA=qw(DBD::_::common);use strict;sub bind_param {Carp::croak("Can't bind_param, not implement by driver")}sub bind_param_array {my$sth=shift;my ($p_id,$value_array,$attr)=@_;return$sth->set_err($DBI::stderr,"Value for parameter $p_id must be a scalar or an arrayref, not a ".ref($value_array))if defined$value_array and ref$value_array and ref$value_array ne 'ARRAY';return$sth->set_err($DBI::stderr,"Can't use named placeholder '$p_id' for non-driver supported bind_param_array")unless DBI::looks_like_number($p_id);return$sth->set_err($DBI::stderr,"Placeholder '$p_id' is out of range")if$p_id <= 0;my$hash_of_arrays=$sth->{ParamArrays}||= {};$$hash_of_arrays{$p_id}=$value_array;return$sth->bind_param($p_id,undef,$attr)if$attr;1}sub bind_param_inout_array {my$sth=shift;my ($p_num,$value_array,$attr)=@_;$sth->bind_param_array($p_num,$value_array,$attr);return$sth->set_err($DBI::stderr,"bind_param_inout_array not supported")}sub bind_columns {my$sth=shift;my$fields=$sth->FETCH('NUM_OF_FIELDS')|| 0;if ($fields <= 0 &&!$sth->{Active}){return$sth->set_err($DBI::stderr,"Statement has no result columns to bind" ." (perhaps you need to successfully call execute first, or again)")}my$attr;$attr=shift if!defined $_[0]or ref($_[0])eq 'HASH';my$idx=0;$sth->bind_col(++$idx,shift,$attr)or return while (@_ and $idx < $fields);return$sth->set_err($DBI::stderr,"bind_columns called with ".($idx+@_)." values but $fields are needed")if @_ or $idx!=$fields;return 1}sub execute_array {my$sth=shift;my ($attr,@array_of_arrays)=@_;my$NUM_OF_PARAMS=$sth->FETCH('NUM_OF_PARAMS');my$tuple_sts=$attr->{ArrayTupleStatus};return$sth->set_err($DBI::stderr,"ArrayTupleStatus attribute must be an arrayref")if$tuple_sts and ref$tuple_sts ne 'ARRAY';if (@array_of_arrays){$sth->{ParamArrays}={};return$sth->set_err($DBI::stderr,@array_of_arrays." bind values supplied but $NUM_OF_PARAMS expected")if defined ($NUM_OF_PARAMS)&& @array_of_arrays!=$NUM_OF_PARAMS;$sth->bind_param_array($_,$array_of_arrays[$_-1])or return foreach (1..@array_of_arrays)}my$fetch_tuple_sub;if ($fetch_tuple_sub=$attr->{ArrayTupleFetch}){return$sth->set_err($DBI::stderr,"Can't use both ArrayTupleFetch and explicit bind values")if@array_of_arrays;if (UNIVERSAL::isa($fetch_tuple_sub,'DBI::st')){my$fetch_sth=$fetch_tuple_sub;return$sth->set_err($DBI::stderr,"ArrayTupleFetch sth is not Active, need to execute() it first")unless$fetch_sth->{Active};my$NUM_OF_FIELDS=$fetch_sth->{NUM_OF_FIELDS};return$sth->set_err($DBI::stderr,"$NUM_OF_FIELDS columns from ArrayTupleFetch sth but $NUM_OF_PARAMS expected")if defined($NUM_OF_FIELDS)&& defined($NUM_OF_PARAMS)&& $NUM_OF_FIELDS!=$NUM_OF_PARAMS;$fetch_tuple_sub=sub {$fetch_sth->fetchrow_arrayref}}elsif (!UNIVERSAL::isa($fetch_tuple_sub,'CODE')){return$sth->set_err($DBI::stderr,"ArrayTupleFetch '$fetch_tuple_sub' is not a code ref or statement handle")}}else {my$NUM_OF_PARAMS_given=keys %{$sth->{ParamArrays}|| {}};return$sth->set_err($DBI::stderr,"$NUM_OF_PARAMS_given bind values supplied but $NUM_OF_PARAMS expected")if defined($NUM_OF_PARAMS)&& $NUM_OF_PARAMS!=$NUM_OF_PARAMS_given;my$maxlen;my%hash_of_arrays=%{$sth->{ParamArrays}};for (keys(%hash_of_arrays)){my$ary=$hash_of_arrays{$_};next unless ref$ary eq 'ARRAY';$maxlen=@$ary if!$maxlen || @$ary > $maxlen}$maxlen=1 unless defined$maxlen;my@bind_ids=1..keys(%hash_of_arrays);my$tuple_idx=0;$fetch_tuple_sub=sub {return if$tuple_idx >= $maxlen;my@tuple=map {my$a=$hash_of_arrays{$_};ref($a)? $a->[$tuple_idx]: $a}@bind_ids;++$tuple_idx;return \@tuple}}return$sth->execute_for_fetch($fetch_tuple_sub,$tuple_sts)}sub execute_for_fetch {my ($sth,$fetch_tuple_sub,$tuple_status)=@_;($tuple_status)? @$tuple_status=(): $tuple_status=[];my$rc_total=0;my$err_count;while (my$tuple=&$fetch_tuple_sub()){if (my$rc=$sth->execute(@$tuple)){push @$tuple_status,$rc;$rc_total=($rc >= 0 && $rc_total >= 0)? $rc_total + $rc : -1}else {$err_count++;push @$tuple_status,[$sth->err,$sth->errstr,$sth->state ]}}my$tuples=@$tuple_status;return$sth->set_err($DBI::stderr,"executing $tuples generated $err_count errors")if$err_count;$tuples ||= "0E0";return$tuples unless wantarray;return ($tuples,$rc_total)}sub fetchall_arrayref {my ($sth,$slice,$max_rows)=@_;return undef if$max_rows and not $sth->FETCH('Active');my$mode=ref($slice)|| 'ARRAY';my@rows;if ($mode eq 'ARRAY'){my$row;if ($slice && @$slice){$max_rows=-1 unless defined$max_rows;push@rows,[@{$row}[@$slice]]while($max_rows-- and $row=$sth->fetch)}elsif (defined$max_rows){push@rows,[@$row ]while($max_rows-- and $row=$sth->fetch)}else {push@rows,[@$row ]while($row=$sth->fetch)}return \@rows}my%row;if ($mode eq 'REF' && ref($$slice)eq 'HASH'){keys %$$slice;while (my ($idx,$name)=each %$$slice){$sth->bind_col($idx+1,\$row{$name})}}elsif ($mode eq 'HASH'){if (keys %$slice){my$name2idx=$sth->FETCH('NAME_lc_hash');while (my ($name,$unused)=each %$slice){my$idx=$name2idx->{lc$name};return$sth->set_err($DBI::stderr,"Invalid column name '$name' for slice")if not defined$idx;$sth->bind_col($idx+1,\$row{$name})}}else {my@column_names=@{$sth->FETCH($sth->FETCH('FetchHashKeyName'))};return []if!@column_names;$sth->bind_columns(\(@row{@column_names}))}}else {return$sth->set_err($DBI::stderr,"fetchall_arrayref($mode) invalid")}if (not defined$max_rows){push@rows,{%row }while ($sth->fetch)}else {push@rows,{%row }while ($max_rows-- and $sth->fetch)}return \@rows}sub fetchall_hashref {my ($sth,$key_field)=@_;my$hash_key_name=$sth->{FetchHashKeyName}|| 'NAME';my$names_hash=$sth->FETCH("${hash_key_name}_hash");my@key_fields=(ref$key_field)? @$key_field : ($key_field);my@key_indexes;my$num_of_fields=$sth->FETCH('NUM_OF_FIELDS');for (@key_fields){my$index=$names_hash->{$_};$index=$_ - 1 if!defined$index && DBI::looks_like_number($_)&& $_>=1 && $_ <= $num_of_fields;return$sth->set_err($DBI::stderr,"Field '$_' does not exist (not one of @{[keys %$names_hash]})")unless defined$index;push@key_indexes,$index}my$rows={};my$NAME=$sth->FETCH($hash_key_name);my@row=(undef)x $num_of_fields;$sth->bind_columns(\(@row));while ($sth->fetch){my$ref=$rows;$ref=$ref->{$row[$_]}||= {}for@key_indexes;@{$ref}{@$NAME}=@row}return$rows}*dump_results=\&DBI::dump_results;sub blob_copy_to_file {my($self,$field,$filename_or_handleref,$blocksize)=@_;my$fh=$filename_or_handleref;my($len,$buf)=(0,"");$blocksize ||= 512;local(*FH);unless(ref$fh){open(FH,">$fh")|| return undef;$fh=\*FH}while(defined($self->blob_read($field,$len,$blocksize,\$buf))){print$fh $buf;$len += length$buf}close(FH);$len}sub more_results {shift->{syb_more_results}}}unless ($DBI::PurePerl){{@DBD::_mem::dr::ISA=qw(DBD::_mem::common)}{@DBD::_mem::db::ISA=qw(DBD::_mem::common)}{@DBD::_mem::st::ISA=qw(DBD::_mem::common)}}1;
DBI

$fatpacked{"DBI/Changes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_CHANGES';
  
DBI_CHANGES

$fatpacked{"DBI/Const/GetInfo/ANSI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_CONST_GETINFO_ANSI';
  use strict;package DBI::Const::GetInfo::ANSI;our (%InfoTypes,%ReturnTypes,%ReturnValues,);my$VERSION="0.03";%InfoTypes=(SQL_ALTER_TABLE=>86,SQL_CATALOG_NAME=>10003,SQL_COLLATING_SEQUENCE=>10004,SQL_CURSOR_COMMIT_BEHAVIOR=>23,SQL_CURSOR_SENSITIVITY=>10001,SQL_DATA_SOURCE_NAME=>2,SQL_DATA_SOURCE_READ_ONLY=>25,SQL_DBMS_NAME=>17,SQL_DBMS_VERSION=>18,SQL_DEFAULT_TRANSACTION_ISOLATION=>26,SQL_DESCRIBE_PARAMETER=>10002,SQL_FETCH_DIRECTION=>8,SQL_GETDATA_EXTENSIONS=>81,SQL_IDENTIFIER_CASE=>28,SQL_INTEGRITY=>73,SQL_MAXIMUM_CATALOG_NAME_LENGTH=>34,SQL_MAXIMUM_COLUMNS_IN_GROUP_BY=>97,SQL_MAXIMUM_COLUMNS_IN_ORDER_BY=>99,SQL_MAXIMUM_COLUMNS_IN_SELECT=>100,SQL_MAXIMUM_COLUMNS_IN_TABLE=>101,SQL_MAXIMUM_COLUMN_NAME_LENGTH=>30,SQL_MAXIMUM_CONCURRENT_ACTIVITIES=>1,SQL_MAXIMUM_CURSOR_NAME_LENGTH=>31,SQL_MAXIMUM_DRIVER_CONNECTIONS=>0,SQL_MAXIMUM_IDENTIFIER_LENGTH=>10005,SQL_MAXIMUM_SCHEMA_NAME_LENGTH=>32,SQL_MAXIMUM_STMT_OCTETS=>20000,SQL_MAXIMUM_STMT_OCTETS_DATA=>20001,SQL_MAXIMUM_STMT_OCTETS_SCHEMA=>20002,SQL_MAXIMUM_TABLES_IN_SELECT=>106,SQL_MAXIMUM_TABLE_NAME_LENGTH=>35,SQL_MAXIMUM_USER_NAME_LENGTH=>107,SQL_NULL_COLLATION=>85,SQL_ORDER_BY_COLUMNS_IN_SELECT=>90,SQL_OUTER_JOIN_CAPABILITIES=>115,SQL_SCROLL_CONCURRENCY=>43,SQL_SEARCH_PATTERN_ESCAPE=>14,SQL_SERVER_NAME=>13,SQL_SPECIAL_CHARACTERS=>94,SQL_TRANSACTION_CAPABLE=>46,SQL_TRANSACTION_ISOLATION_OPTION=>72,SQL_USER_NAME=>47);%ReturnTypes=(SQL_ALTER_TABLE=>'SQLUINTEGER bitmask' ,SQL_CATALOG_NAME=>'SQLCHAR' ,SQL_COLLATING_SEQUENCE=>'SQLCHAR' ,SQL_CURSOR_COMMIT_BEHAVIOR=>'SQLUSMALLINT' ,SQL_CURSOR_SENSITIVITY=>'SQLUINTEGER' ,SQL_DATA_SOURCE_NAME=>'SQLCHAR' ,SQL_DATA_SOURCE_READ_ONLY=>'SQLCHAR' ,SQL_DBMS_NAME=>'SQLCHAR' ,SQL_DBMS_VERSION=>'SQLCHAR' ,SQL_DEFAULT_TRANSACTION_ISOLATION=>'SQLUINTEGER' ,SQL_DESCRIBE_PARAMETER=>'SQLCHAR' ,SQL_FETCH_DIRECTION=>'SQLUINTEGER bitmask' ,SQL_GETDATA_EXTENSIONS=>'SQLUINTEGER bitmask' ,SQL_IDENTIFIER_CASE=>'SQLUSMALLINT' ,SQL_INTEGRITY=>'SQLCHAR' ,SQL_MAXIMUM_CATALOG_NAME_LENGTH=>'SQLUSMALLINT' ,SQL_MAXIMUM_COLUMNS_IN_GROUP_BY=>'SQLUSMALLINT' ,SQL_MAXIMUM_COLUMNS_IN_ORDER_BY=>'SQLUSMALLINT' ,SQL_MAXIMUM_COLUMNS_IN_SELECT=>'SQLUSMALLINT' ,SQL_MAXIMUM_COLUMNS_IN_TABLE=>'SQLUSMALLINT' ,SQL_MAXIMUM_COLUMN_NAME_LENGTH=>'SQLUSMALLINT' ,SQL_MAXIMUM_CONCURRENT_ACTIVITIES=>'SQLUSMALLINT' ,SQL_MAXIMUM_CURSOR_NAME_LENGTH=>'SQLUSMALLINT' ,SQL_MAXIMUM_DRIVER_CONNECTIONS=>'SQLUSMALLINT' ,SQL_MAXIMUM_IDENTIFIER_LENGTH=>'SQLUSMALLINT' ,SQL_MAXIMUM_SCHEMA_NAME_LENGTH=>'SQLUSMALLINT' ,SQL_MAXIMUM_STMT_OCTETS=>'SQLUSMALLINT' ,SQL_MAXIMUM_STMT_OCTETS_DATA=>'SQLUSMALLINT' ,SQL_MAXIMUM_STMT_OCTETS_SCHEMA=>'SQLUSMALLINT' ,SQL_MAXIMUM_TABLES_IN_SELECT=>'SQLUSMALLINT' ,SQL_MAXIMUM_TABLE_NAME_LENGTH=>'SQLUSMALLINT' ,SQL_MAXIMUM_USER_NAME_LENGTH=>'SQLUSMALLINT' ,SQL_NULL_COLLATION=>'SQLUSMALLINT' ,SQL_ORDER_BY_COLUMNS_IN_SELECT=>'SQLCHAR' ,SQL_OUTER_JOIN_CAPABILITIES=>'SQLUINTEGER bitmask' ,SQL_SCROLL_CONCURRENCY=>'SQLUINTEGER bitmask' ,SQL_SEARCH_PATTERN_ESCAPE=>'SQLCHAR' ,SQL_SERVER_NAME=>'SQLCHAR' ,SQL_SPECIAL_CHARACTERS=>'SQLCHAR' ,SQL_TRANSACTION_CAPABLE=>'SQLUSMALLINT' ,SQL_TRANSACTION_ISOLATION_OPTION=>'SQLUINTEGER bitmask' ,SQL_USER_NAME=>'SQLCHAR');$ReturnValues{SQL_ALTER_TABLE}={SQL_AT_ADD_COLUMN=>0x00000001,SQL_AT_DROP_COLUMN=>0x00000002,SQL_AT_ALTER_COLUMN=>0x00000004,SQL_AT_ADD_CONSTRAINT=>0x00000008,SQL_AT_DROP_CONSTRAINT=>0x00000010 };$ReturnValues{SQL_CURSOR_COMMIT_BEHAVIOR}={SQL_CB_DELETE=>0,SQL_CB_CLOSE=>1,SQL_CB_PRESERVE=>2 };$ReturnValues{SQL_FETCH_DIRECTION}={SQL_FD_FETCH_NEXT=>0x00000001,SQL_FD_FETCH_FIRST=>0x00000002,SQL_FD_FETCH_LAST=>0x00000004,SQL_FD_FETCH_PRIOR=>0x00000008,SQL_FD_FETCH_ABSOLUTE=>0x00000010,SQL_FD_FETCH_RELATIVE=>0x00000020 };$ReturnValues{SQL_GETDATA_EXTENSIONS}={SQL_GD_ANY_COLUMN=>0x00000001,SQL_GD_ANY_ORDER=>0x00000002 };$ReturnValues{SQL_IDENTIFIER_CASE}={SQL_IC_UPPER=>1,SQL_IC_LOWER=>2,SQL_IC_SENSITIVE=>3,SQL_IC_MIXED=>4 };$ReturnValues{SQL_NULL_COLLATION}={SQL_NC_HIGH=>1,SQL_NC_LOW=>2 };$ReturnValues{SQL_OUTER_JOIN_CAPABILITIES}={SQL_OUTER_JOIN_LEFT=>0x00000001,SQL_OUTER_JOIN_RIGHT=>0x00000002,SQL_OUTER_JOIN_FULL=>0x00000004,SQL_OUTER_JOIN_NESTED=>0x00000008,SQL_OUTER_JOIN_NOT_ORDERED=>0x00000010,SQL_OUTER_JOIN_INNER=>0x00000020,SQL_OUTER_JOIN_ALL_COMPARISON_OPS=>0x00000040 };$ReturnValues{SQL_SCROLL_CONCURRENCY}={SQL_SCCO_READ_ONLY=>0x00000001,SQL_SCCO_LOCK=>0x00000002,SQL_SCCO_OPT_ROWVER=>0x00000004,SQL_SCCO_OPT_VALUES=>0x00000008 };$ReturnValues{SQL_TRANSACTION_ACCESS_MODE}={SQL_TRANSACTION_READ_ONLY=>0x00000001,SQL_TRANSACTION_READ_WRITE=>0x00000002 };$ReturnValues{SQL_TRANSACTION_CAPABLE}={SQL_TC_NONE=>0,SQL_TC_DML=>1,SQL_TC_ALL=>2,SQL_TC_DDL_COMMIT=>3,SQL_TC_DDL_IGNORE=>4 };$ReturnValues{SQL_TRANSACTION_ISOLATION}={SQL_TRANSACTION_READ_UNCOMMITTED=>0x00000001,SQL_TRANSACTION_READ_COMMITTED=>0x00000002,SQL_TRANSACTION_REPEATABLE_READ=>0x00000004,SQL_TRANSACTION_SERIALIZABLE=>0x00000008 };1;
DBI_CONST_GETINFO_ANSI

$fatpacked{"DBI/Const/GetInfo/ODBC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_CONST_GETINFO_ODBC';
  use strict;package DBI::Const::GetInfo::ODBC;our (%InfoTypes,%ReturnTypes,%ReturnValues,);my$VERSION="0.03";%InfoTypes=(SQL_ACCESSIBLE_PROCEDURES=>20,SQL_ACCESSIBLE_TABLES=>19,SQL_ACTIVE_CONNECTIONS=>0,SQL_ACTIVE_ENVIRONMENTS=>116,SQL_ACTIVE_STATEMENTS=>1,SQL_AGGREGATE_FUNCTIONS=>169,SQL_ALTER_DOMAIN=>117,SQL_ALTER_TABLE=>86,SQL_ASYNC_MODE=>10021,SQL_BATCH_ROW_COUNT=>120,SQL_BATCH_SUPPORT=>121,SQL_BOOKMARK_PERSISTENCE=>82,SQL_CATALOG_LOCATION=>114 ,SQL_CATALOG_NAME=>10003,SQL_CATALOG_NAME_SEPARATOR=>41 ,SQL_CATALOG_TERM=>42 ,SQL_CATALOG_USAGE=>92 ,SQL_COLLATION_SEQ=>10004,SQL_COLUMN_ALIAS=>87,SQL_CONCAT_NULL_BEHAVIOR=>22,SQL_CONVERT_BIGINT=>53,SQL_CONVERT_BINARY=>54,SQL_CONVERT_BIT=>55,SQL_CONVERT_CHAR=>56,SQL_CONVERT_DATE=>57,SQL_CONVERT_DECIMAL=>58,SQL_CONVERT_DOUBLE=>59,SQL_CONVERT_FLOAT=>60,SQL_CONVERT_FUNCTIONS=>48,SQL_CONVERT_GUID=>173,SQL_CONVERT_INTEGER=>61,SQL_CONVERT_INTERVAL_DAY_TIME=>123,SQL_CONVERT_INTERVAL_YEAR_MONTH=>124,SQL_CONVERT_LONGVARBINARY=>71,SQL_CONVERT_LONGVARCHAR=>62,SQL_CONVERT_NUMERIC=>63,SQL_CONVERT_REAL=>64,SQL_CONVERT_SMALLINT=>65,SQL_CONVERT_TIME=>66,SQL_CONVERT_TIMESTAMP=>67,SQL_CONVERT_TINYINT=>68,SQL_CONVERT_VARBINARY=>69,SQL_CONVERT_VARCHAR=>70,SQL_CONVERT_WCHAR=>122,SQL_CONVERT_WLONGVARCHAR=>125,SQL_CONVERT_WVARCHAR=>126,SQL_CORRELATION_NAME=>74,SQL_CREATE_ASSERTION=>127,SQL_CREATE_CHARACTER_SET=>128,SQL_CREATE_COLLATION=>129,SQL_CREATE_DOMAIN=>130,SQL_CREATE_SCHEMA=>131,SQL_CREATE_TABLE=>132,SQL_CREATE_TRANSLATION=>133,SQL_CREATE_VIEW=>134,SQL_CURSOR_COMMIT_BEHAVIOR=>23,SQL_CURSOR_ROLLBACK_BEHAVIOR=>24,SQL_CURSOR_SENSITIVITY=>10001,SQL_DATA_SOURCE_NAME=>2,SQL_DATA_SOURCE_READ_ONLY=>25,SQL_DATABASE_NAME=>16,SQL_DATETIME_LITERALS=>119,SQL_DBMS_NAME=>17,SQL_DBMS_VER=>18,SQL_DDL_INDEX=>170,SQL_DEFAULT_TXN_ISOLATION=>26,SQL_DESCRIBE_PARAMETER=>10002,SQL_DM_VER=>171,SQL_DRIVER_HDBC=>3,SQL_DRIVER_HDESC=>135,SQL_DRIVER_HENV=>4,SQL_DRIVER_HLIB=>76,SQL_DRIVER_HSTMT=>5,SQL_DRIVER_NAME=>6,SQL_DRIVER_ODBC_VER=>77,SQL_DRIVER_VER=>7,SQL_DROP_ASSERTION=>136,SQL_DROP_CHARACTER_SET=>137,SQL_DROP_COLLATION=>138,SQL_DROP_DOMAIN=>139,SQL_DROP_SCHEMA=>140,SQL_DROP_TABLE=>141,SQL_DROP_TRANSLATION=>142,SQL_DROP_VIEW=>143,SQL_DYNAMIC_CURSOR_ATTRIBUTES1=>144,SQL_DYNAMIC_CURSOR_ATTRIBUTES2=>145,SQL_EXPRESSIONS_IN_ORDERBY=>27,SQL_FETCH_DIRECTION=>8,SQL_FILE_USAGE=>84,SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1=>146,SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2=>147,SQL_GETDATA_EXTENSIONS=>81,SQL_GROUP_BY=>88,SQL_IDENTIFIER_CASE=>28,SQL_IDENTIFIER_QUOTE_CHAR=>29,SQL_INDEX_KEYWORDS=>148,SQL_INFO_SCHEMA_VIEWS=>149,SQL_INSERT_STATEMENT=>172,SQL_INTEGRITY=>73,SQL_KEYSET_CURSOR_ATTRIBUTES1=>150,SQL_KEYSET_CURSOR_ATTRIBUTES2=>151,SQL_KEYWORDS=>89,SQL_LIKE_ESCAPE_CLAUSE=>113,SQL_LOCK_TYPES=>78,SQL_MAXIMUM_CATALOG_NAME_LENGTH=>34 ,SQL_MAXIMUM_COLUMNS_IN_GROUP_BY=>97 ,SQL_MAXIMUM_COLUMNS_IN_INDEX=>98 ,SQL_MAXIMUM_COLUMNS_IN_ORDER_BY=>99 ,SQL_MAXIMUM_COLUMNS_IN_SELECT=>100 ,SQL_MAXIMUM_COLUMN_NAME_LENGTH=>30 ,SQL_MAXIMUM_CONCURRENT_ACTIVITIES=>1 ,SQL_MAXIMUM_CURSOR_NAME_LENGTH=>31 ,SQL_MAXIMUM_DRIVER_CONNECTIONS=>0 ,SQL_MAXIMUM_IDENTIFIER_LENGTH=>10005 ,SQL_MAXIMUM_INDEX_SIZE=>102 ,SQL_MAXIMUM_ROW_SIZE=>104 ,SQL_MAXIMUM_SCHEMA_NAME_LENGTH=>32 ,SQL_MAXIMUM_STATEMENT_LENGTH=>105 ,SQL_MAXIMUM_TABLES_IN_SELECT=>106 ,SQL_MAXIMUM_USER_NAME_LENGTH=>107 ,SQL_MAX_ASYNC_CONCURRENT_STATEMENTS=>10022,SQL_MAX_BINARY_LITERAL_LEN=>112,SQL_MAX_CATALOG_NAME_LEN=>34,SQL_MAX_CHAR_LITERAL_LEN=>108,SQL_MAX_COLUMNS_IN_GROUP_BY=>97,SQL_MAX_COLUMNS_IN_INDEX=>98,SQL_MAX_COLUMNS_IN_ORDER_BY=>99,SQL_MAX_COLUMNS_IN_SELECT=>100,SQL_MAX_COLUMNS_IN_TABLE=>101,SQL_MAX_COLUMN_NAME_LEN=>30,SQL_MAX_CONCURRENT_ACTIVITIES=>1,SQL_MAX_CURSOR_NAME_LEN=>31,SQL_MAX_DRIVER_CONNECTIONS=>0,SQL_MAX_IDENTIFIER_LEN=>10005,SQL_MAX_INDEX_SIZE=>102,SQL_MAX_OWNER_NAME_LEN=>32,SQL_MAX_PROCEDURE_NAME_LEN=>33,SQL_MAX_QUALIFIER_NAME_LEN=>34,SQL_MAX_ROW_SIZE=>104,SQL_MAX_ROW_SIZE_INCLUDES_LONG=>103,SQL_MAX_SCHEMA_NAME_LEN=>32,SQL_MAX_STATEMENT_LEN=>105,SQL_MAX_TABLES_IN_SELECT=>106,SQL_MAX_TABLE_NAME_LEN=>35,SQL_MAX_USER_NAME_LEN=>107,SQL_MULTIPLE_ACTIVE_TXN=>37,SQL_MULT_RESULT_SETS=>36,SQL_NEED_LONG_DATA_LEN=>111,SQL_NON_NULLABLE_COLUMNS=>75,SQL_NULL_COLLATION=>85,SQL_NUMERIC_FUNCTIONS=>49,SQL_ODBC_API_CONFORMANCE=>9,SQL_ODBC_INTERFACE_CONFORMANCE=>152,SQL_ODBC_SAG_CLI_CONFORMANCE=>12,SQL_ODBC_SQL_CONFORMANCE=>15,SQL_ODBC_SQL_OPT_IEF=>73,SQL_ODBC_VER=>10,SQL_OJ_CAPABILITIES=>115,SQL_ORDER_BY_COLUMNS_IN_SELECT=>90,SQL_OUTER_JOINS=>38,SQL_OUTER_JOIN_CAPABILITIES=>115 ,SQL_OWNER_TERM=>39,SQL_OWNER_USAGE=>91,SQL_PARAM_ARRAY_ROW_COUNTS=>153,SQL_PARAM_ARRAY_SELECTS=>154,SQL_POSITIONED_STATEMENTS=>80,SQL_POS_OPERATIONS=>79,SQL_PROCEDURES=>21,SQL_PROCEDURE_TERM=>40,SQL_QUALIFIER_LOCATION=>114,SQL_QUALIFIER_NAME_SEPARATOR=>41,SQL_QUALIFIER_TERM=>42,SQL_QUALIFIER_USAGE=>92,SQL_QUOTED_IDENTIFIER_CASE=>93,SQL_ROW_UPDATES=>11,SQL_SCHEMA_TERM=>39 ,SQL_SCHEMA_USAGE=>91 ,SQL_SCROLL_CONCURRENCY=>43,SQL_SCROLL_OPTIONS=>44,SQL_SEARCH_PATTERN_ESCAPE=>14,SQL_SERVER_NAME=>13,SQL_SPECIAL_CHARACTERS=>94,SQL_SQL92_DATETIME_FUNCTIONS=>155,SQL_SQL92_FOREIGN_KEY_DELETE_RULE=>156,SQL_SQL92_FOREIGN_KEY_UPDATE_RULE=>157,SQL_SQL92_GRANT=>158,SQL_SQL92_NUMERIC_VALUE_FUNCTIONS=>159,SQL_SQL92_PREDICATES=>160,SQL_SQL92_RELATIONAL_JOIN_OPERATORS=>161,SQL_SQL92_REVOKE=>162,SQL_SQL92_ROW_VALUE_CONSTRUCTOR=>163,SQL_SQL92_STRING_FUNCTIONS=>164,SQL_SQL92_VALUE_EXPRESSIONS=>165,SQL_SQL_CONFORMANCE=>118,SQL_STANDARD_CLI_CONFORMANCE=>166,SQL_STATIC_CURSOR_ATTRIBUTES1=>167,SQL_STATIC_CURSOR_ATTRIBUTES2=>168,SQL_STATIC_SENSITIVITY=>83,SQL_STRING_FUNCTIONS=>50,SQL_SUBQUERIES=>95,SQL_SYSTEM_FUNCTIONS=>51,SQL_TABLE_TERM=>45,SQL_TIMEDATE_ADD_INTERVALS=>109,SQL_TIMEDATE_DIFF_INTERVALS=>110,SQL_TIMEDATE_FUNCTIONS=>52,SQL_TRANSACTION_CAPABLE=>46 ,SQL_TRANSACTION_ISOLATION_OPTION=>72 ,SQL_TXN_CAPABLE=>46,SQL_TXN_ISOLATION_OPTION=>72,SQL_UNION=>96,SQL_UNION_STATEMENT=>96 ,SQL_USER_NAME=>47,SQL_XOPEN_CLI_YEAR=>10000);%ReturnTypes=(SQL_ACCESSIBLE_PROCEDURES=>'SQLCHAR' ,SQL_ACCESSIBLE_TABLES=>'SQLCHAR' ,SQL_ACTIVE_CONNECTIONS=>'SQLUSMALLINT' ,SQL_ACTIVE_ENVIRONMENTS=>'SQLUSMALLINT' ,SQL_ACTIVE_STATEMENTS=>'SQLUSMALLINT' ,SQL_AGGREGATE_FUNCTIONS=>'SQLUINTEGER bitmask' ,SQL_ALTER_DOMAIN=>'SQLUINTEGER bitmask' ,SQL_ALTER_TABLE=>'SQLUINTEGER bitmask' ,SQL_ASYNC_MODE=>'SQLUINTEGER' ,SQL_BATCH_ROW_COUNT=>'SQLUINTEGER bitmask' ,SQL_BATCH_SUPPORT=>'SQLUINTEGER bitmask' ,SQL_BOOKMARK_PERSISTENCE=>'SQLUINTEGER bitmask' ,SQL_CATALOG_LOCATION=>'SQLUSMALLINT' ,SQL_CATALOG_NAME=>'SQLCHAR' ,SQL_CATALOG_NAME_SEPARATOR=>'SQLCHAR' ,SQL_CATALOG_TERM=>'SQLCHAR' ,SQL_CATALOG_USAGE=>'SQLUINTEGER bitmask' ,SQL_COLLATION_SEQ=>'SQLCHAR' ,SQL_COLUMN_ALIAS=>'SQLCHAR' ,SQL_CONCAT_NULL_BEHAVIOR=>'SQLUSMALLINT' ,SQL_CONVERT_BIGINT=>'SQLUINTEGER bitmask' ,SQL_CONVERT_BINARY=>'SQLUINTEGER bitmask' ,SQL_CONVERT_BIT=>'SQLUINTEGER bitmask' ,SQL_CONVERT_CHAR=>'SQLUINTEGER bitmask' ,SQL_CONVERT_DATE=>'SQLUINTEGER bitmask' ,SQL_CONVERT_DECIMAL=>'SQLUINTEGER bitmask' ,SQL_CONVERT_DOUBLE=>'SQLUINTEGER bitmask' ,SQL_CONVERT_FLOAT=>'SQLUINTEGER bitmask' ,SQL_CONVERT_FUNCTIONS=>'SQLUINTEGER bitmask' ,SQL_CONVERT_GUID=>'SQLUINTEGER bitmask' ,SQL_CONVERT_INTEGER=>'SQLUINTEGER bitmask' ,SQL_CONVERT_INTERVAL_DAY_TIME=>'SQLUINTEGER bitmask' ,SQL_CONVERT_INTERVAL_YEAR_MONTH=>'SQLUINTEGER bitmask' ,SQL_CONVERT_LONGVARBINARY=>'SQLUINTEGER bitmask' ,SQL_CONVERT_LONGVARCHAR=>'SQLUINTEGER bitmask' ,SQL_CONVERT_NUMERIC=>'SQLUINTEGER bitmask' ,SQL_CONVERT_REAL=>'SQLUINTEGER bitmask' ,SQL_CONVERT_SMALLINT=>'SQLUINTEGER bitmask' ,SQL_CONVERT_TIME=>'SQLUINTEGER bitmask' ,SQL_CONVERT_TIMESTAMP=>'SQLUINTEGER bitmask' ,SQL_CONVERT_TINYINT=>'SQLUINTEGER bitmask' ,SQL_CONVERT_VARBINARY=>'SQLUINTEGER bitmask' ,SQL_CONVERT_VARCHAR=>'SQLUINTEGER bitmask' ,SQL_CONVERT_WCHAR=>'SQLUINTEGER bitmask' ,SQL_CONVERT_WLONGVARCHAR=>'SQLUINTEGER bitmask' ,SQL_CONVERT_WVARCHAR=>'SQLUINTEGER bitmask' ,SQL_CORRELATION_NAME=>'SQLUSMALLINT' ,SQL_CREATE_ASSERTION=>'SQLUINTEGER bitmask' ,SQL_CREATE_CHARACTER_SET=>'SQLUINTEGER bitmask' ,SQL_CREATE_COLLATION=>'SQLUINTEGER bitmask' ,SQL_CREATE_DOMAIN=>'SQLUINTEGER bitmask' ,SQL_CREATE_SCHEMA=>'SQLUINTEGER bitmask' ,SQL_CREATE_TABLE=>'SQLUINTEGER bitmask' ,SQL_CREATE_TRANSLATION=>'SQLUINTEGER bitmask' ,SQL_CREATE_VIEW=>'SQLUINTEGER bitmask' ,SQL_CURSOR_COMMIT_BEHAVIOR=>'SQLUSMALLINT' ,SQL_CURSOR_ROLLBACK_BEHAVIOR=>'SQLUSMALLINT' ,SQL_CURSOR_SENSITIVITY=>'SQLUINTEGER' ,SQL_DATA_SOURCE_NAME=>'SQLCHAR' ,SQL_DATA_SOURCE_READ_ONLY=>'SQLCHAR' ,SQL_DATABASE_NAME=>'SQLCHAR' ,SQL_DATETIME_LITERALS=>'SQLUINTEGER bitmask' ,SQL_DBMS_NAME=>'SQLCHAR' ,SQL_DBMS_VER=>'SQLCHAR' ,SQL_DDL_INDEX=>'SQLUINTEGER bitmask' ,SQL_DEFAULT_TXN_ISOLATION=>'SQLUINTEGER' ,SQL_DESCRIBE_PARAMETER=>'SQLCHAR' ,SQL_DM_VER=>'SQLCHAR' ,SQL_DRIVER_HDBC=>'SQLUINTEGER' ,SQL_DRIVER_HDESC=>'SQLUINTEGER' ,SQL_DRIVER_HENV=>'SQLUINTEGER' ,SQL_DRIVER_HLIB=>'SQLUINTEGER' ,SQL_DRIVER_HSTMT=>'SQLUINTEGER' ,SQL_DRIVER_NAME=>'SQLCHAR' ,SQL_DRIVER_ODBC_VER=>'SQLCHAR' ,SQL_DRIVER_VER=>'SQLCHAR' ,SQL_DROP_ASSERTION=>'SQLUINTEGER bitmask' ,SQL_DROP_CHARACTER_SET=>'SQLUINTEGER bitmask' ,SQL_DROP_COLLATION=>'SQLUINTEGER bitmask' ,SQL_DROP_DOMAIN=>'SQLUINTEGER bitmask' ,SQL_DROP_SCHEMA=>'SQLUINTEGER bitmask' ,SQL_DROP_TABLE=>'SQLUINTEGER bitmask' ,SQL_DROP_TRANSLATION=>'SQLUINTEGER bitmask' ,SQL_DROP_VIEW=>'SQLUINTEGER bitmask' ,SQL_DYNAMIC_CURSOR_ATTRIBUTES1=>'SQLUINTEGER bitmask' ,SQL_DYNAMIC_CURSOR_ATTRIBUTES2=>'SQLUINTEGER bitmask' ,SQL_EXPRESSIONS_IN_ORDERBY=>'SQLCHAR' ,SQL_FETCH_DIRECTION=>'SQLUINTEGER bitmask' ,SQL_FILE_USAGE=>'SQLUSMALLINT' ,SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1=>'SQLUINTEGER bitmask' ,SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2=>'SQLUINTEGER bitmask' ,SQL_GETDATA_EXTENSIONS=>'SQLUINTEGER bitmask' ,SQL_GROUP_BY=>'SQLUSMALLINT' ,SQL_IDENTIFIER_CASE=>'SQLUSMALLINT' ,SQL_IDENTIFIER_QUOTE_CHAR=>'SQLCHAR' ,SQL_INDEX_KEYWORDS=>'SQLUINTEGER bitmask' ,SQL_INFO_SCHEMA_VIEWS=>'SQLUINTEGER bitmask' ,SQL_INSERT_STATEMENT=>'SQLUINTEGER bitmask' ,SQL_INTEGRITY=>'SQLCHAR' ,SQL_KEYSET_CURSOR_ATTRIBUTES1=>'SQLUINTEGER bitmask' ,SQL_KEYSET_CURSOR_ATTRIBUTES2=>'SQLUINTEGER bitmask' ,SQL_KEYWORDS=>'SQLCHAR' ,SQL_LIKE_ESCAPE_CLAUSE=>'SQLCHAR' ,SQL_LOCK_TYPES=>'SQLUINTEGER bitmask' ,SQL_MAXIMUM_CATALOG_NAME_LENGTH=>'SQLUSMALLINT' ,SQL_MAXIMUM_COLUMNS_IN_GROUP_BY=>'SQLUSMALLINT' ,SQL_MAXIMUM_COLUMNS_IN_INDEX=>'SQLUSMALLINT' ,SQL_MAXIMUM_COLUMNS_IN_ORDER_BY=>'SQLUSMALLINT' ,SQL_MAXIMUM_COLUMNS_IN_SELECT=>'SQLUSMALLINT' ,SQL_MAXIMUM_COLUMN_NAME_LENGTH=>'SQLUSMALLINT' ,SQL_MAXIMUM_CONCURRENT_ACTIVITIES=>'SQLUSMALLINT' ,SQL_MAXIMUM_CURSOR_NAME_LENGTH=>'SQLUSMALLINT' ,SQL_MAXIMUM_DRIVER_CONNECTIONS=>'SQLUSMALLINT' ,SQL_MAXIMUM_IDENTIFIER_LENGTH=>'SQLUSMALLINT' ,SQL_MAXIMUM_INDEX_SIZE=>'SQLUINTEGER' ,SQL_MAXIMUM_ROW_SIZE=>'SQLUINTEGER' ,SQL_MAXIMUM_SCHEMA_NAME_LENGTH=>'SQLUSMALLINT' ,SQL_MAXIMUM_STATEMENT_LENGTH=>'SQLUINTEGER' ,SQL_MAXIMUM_TABLES_IN_SELECT=>'SQLUSMALLINT' ,SQL_MAXIMUM_USER_NAME_LENGTH=>'SQLUSMALLINT' ,SQL_MAX_ASYNC_CONCURRENT_STATEMENTS=>'SQLUINTEGER' ,SQL_MAX_BINARY_LITERAL_LEN=>'SQLUINTEGER' ,SQL_MAX_CATALOG_NAME_LEN=>'SQLUSMALLINT' ,SQL_MAX_CHAR_LITERAL_LEN=>'SQLUINTEGER' ,SQL_MAX_COLUMNS_IN_GROUP_BY=>'SQLUSMALLINT' ,SQL_MAX_COLUMNS_IN_INDEX=>'SQLUSMALLINT' ,SQL_MAX_COLUMNS_IN_ORDER_BY=>'SQLUSMALLINT' ,SQL_MAX_COLUMNS_IN_SELECT=>'SQLUSMALLINT' ,SQL_MAX_COLUMNS_IN_TABLE=>'SQLUSMALLINT' ,SQL_MAX_COLUMN_NAME_LEN=>'SQLUSMALLINT' ,SQL_MAX_CONCURRENT_ACTIVITIES=>'SQLUSMALLINT' ,SQL_MAX_CURSOR_NAME_LEN=>'SQLUSMALLINT' ,SQL_MAX_DRIVER_CONNECTIONS=>'SQLUSMALLINT' ,SQL_MAX_IDENTIFIER_LEN=>'SQLUSMALLINT' ,SQL_MAX_INDEX_SIZE=>'SQLUINTEGER' ,SQL_MAX_OWNER_NAME_LEN=>'SQLUSMALLINT' ,SQL_MAX_PROCEDURE_NAME_LEN=>'SQLUSMALLINT' ,SQL_MAX_QUALIFIER_NAME_LEN=>'SQLUSMALLINT' ,SQL_MAX_ROW_SIZE=>'SQLUINTEGER' ,SQL_MAX_ROW_SIZE_INCLUDES_LONG=>'SQLCHAR' ,SQL_MAX_SCHEMA_NAME_LEN=>'SQLUSMALLINT' ,SQL_MAX_STATEMENT_LEN=>'SQLUINTEGER' ,SQL_MAX_TABLES_IN_SELECT=>'SQLUSMALLINT' ,SQL_MAX_TABLE_NAME_LEN=>'SQLUSMALLINT' ,SQL_MAX_USER_NAME_LEN=>'SQLUSMALLINT' ,SQL_MULTIPLE_ACTIVE_TXN=>'SQLCHAR' ,SQL_MULT_RESULT_SETS=>'SQLCHAR' ,SQL_NEED_LONG_DATA_LEN=>'SQLCHAR' ,SQL_NON_NULLABLE_COLUMNS=>'SQLUSMALLINT' ,SQL_NULL_COLLATION=>'SQLUSMALLINT' ,SQL_NUMERIC_FUNCTIONS=>'SQLUINTEGER bitmask' ,SQL_ODBC_API_CONFORMANCE=>'SQLUSMALLINT' ,SQL_ODBC_INTERFACE_CONFORMANCE=>'SQLUINTEGER' ,SQL_ODBC_SAG_CLI_CONFORMANCE=>'SQLUSMALLINT' ,SQL_ODBC_SQL_CONFORMANCE=>'SQLUSMALLINT' ,SQL_ODBC_SQL_OPT_IEF=>'SQLCHAR' ,SQL_ODBC_VER=>'SQLCHAR' ,SQL_OJ_CAPABILITIES=>'SQLUINTEGER bitmask' ,SQL_ORDER_BY_COLUMNS_IN_SELECT=>'SQLCHAR' ,SQL_OUTER_JOINS=>'SQLCHAR' ,SQL_OUTER_JOIN_CAPABILITIES=>'SQLUINTEGER bitmask' ,SQL_OWNER_TERM=>'SQLCHAR' ,SQL_OWNER_USAGE=>'SQLUINTEGER bitmask' ,SQL_PARAM_ARRAY_ROW_COUNTS=>'SQLUINTEGER' ,SQL_PARAM_ARRAY_SELECTS=>'SQLUINTEGER' ,SQL_POSITIONED_STATEMENTS=>'SQLUINTEGER bitmask' ,SQL_POS_OPERATIONS=>'SQLINTEGER bitmask' ,SQL_PROCEDURES=>'SQLCHAR' ,SQL_PROCEDURE_TERM=>'SQLCHAR' ,SQL_QUALIFIER_LOCATION=>'SQLUSMALLINT' ,SQL_QUALIFIER_NAME_SEPARATOR=>'SQLCHAR' ,SQL_QUALIFIER_TERM=>'SQLCHAR' ,SQL_QUALIFIER_USAGE=>'SQLUINTEGER bitmask' ,SQL_QUOTED_IDENTIFIER_CASE=>'SQLUSMALLINT' ,SQL_ROW_UPDATES=>'SQLCHAR' ,SQL_SCHEMA_TERM=>'SQLCHAR' ,SQL_SCHEMA_USAGE=>'SQLUINTEGER bitmask' ,SQL_SCROLL_CONCURRENCY=>'SQLUINTEGER bitmask' ,SQL_SCROLL_OPTIONS=>'SQLUINTEGER bitmask' ,SQL_SEARCH_PATTERN_ESCAPE=>'SQLCHAR' ,SQL_SERVER_NAME=>'SQLCHAR' ,SQL_SPECIAL_CHARACTERS=>'SQLCHAR' ,SQL_SQL92_DATETIME_FUNCTIONS=>'SQLUINTEGER bitmask' ,SQL_SQL92_FOREIGN_KEY_DELETE_RULE=>'SQLUINTEGER bitmask' ,SQL_SQL92_FOREIGN_KEY_UPDATE_RULE=>'SQLUINTEGER bitmask' ,SQL_SQL92_GRANT=>'SQLUINTEGER bitmask' ,SQL_SQL92_NUMERIC_VALUE_FUNCTIONS=>'SQLUINTEGER bitmask' ,SQL_SQL92_PREDICATES=>'SQLUINTEGER bitmask' ,SQL_SQL92_RELATIONAL_JOIN_OPERATORS=>'SQLUINTEGER bitmask' ,SQL_SQL92_REVOKE=>'SQLUINTEGER bitmask' ,SQL_SQL92_ROW_VALUE_CONSTRUCTOR=>'SQLUINTEGER bitmask' ,SQL_SQL92_STRING_FUNCTIONS=>'SQLUINTEGER bitmask' ,SQL_SQL92_VALUE_EXPRESSIONS=>'SQLUINTEGER bitmask' ,SQL_SQL_CONFORMANCE=>'SQLUINTEGER' ,SQL_STANDARD_CLI_CONFORMANCE=>'SQLUINTEGER bitmask' ,SQL_STATIC_CURSOR_ATTRIBUTES1=>'SQLUINTEGER bitmask' ,SQL_STATIC_CURSOR_ATTRIBUTES2=>'SQLUINTEGER bitmask' ,SQL_STATIC_SENSITIVITY=>'SQLUINTEGER bitmask' ,SQL_STRING_FUNCTIONS=>'SQLUINTEGER bitmask' ,SQL_SUBQUERIES=>'SQLUINTEGER bitmask' ,SQL_SYSTEM_FUNCTIONS=>'SQLUINTEGER bitmask' ,SQL_TABLE_TERM=>'SQLCHAR' ,SQL_TIMEDATE_ADD_INTERVALS=>'SQLUINTEGER bitmask' ,SQL_TIMEDATE_DIFF_INTERVALS=>'SQLUINTEGER bitmask' ,SQL_TIMEDATE_FUNCTIONS=>'SQLUINTEGER bitmask' ,SQL_TRANSACTION_CAPABLE=>'SQLUSMALLINT' ,SQL_TRANSACTION_ISOLATION_OPTION=>'SQLUINTEGER bitmask' ,SQL_TXN_CAPABLE=>'SQLUSMALLINT' ,SQL_TXN_ISOLATION_OPTION=>'SQLUINTEGER bitmask' ,SQL_UNION=>'SQLUINTEGER bitmask' ,SQL_UNION_STATEMENT=>'SQLUINTEGER bitmask' ,SQL_USER_NAME=>'SQLCHAR' ,SQL_XOPEN_CLI_YEAR=>'SQLCHAR');$ReturnValues{SQL_AGGREGATE_FUNCTIONS}={SQL_AF_AVG=>0x00000001,SQL_AF_COUNT=>0x00000002,SQL_AF_MAX=>0x00000004,SQL_AF_MIN=>0x00000008,SQL_AF_SUM=>0x00000010,SQL_AF_DISTINCT=>0x00000020,SQL_AF_ALL=>0x00000040 };$ReturnValues{SQL_ALTER_DOMAIN}={SQL_AD_CONSTRAINT_NAME_DEFINITION=>0x00000001,SQL_AD_ADD_DOMAIN_CONSTRAINT=>0x00000002,SQL_AD_DROP_DOMAIN_CONSTRAINT=>0x00000004,SQL_AD_ADD_DOMAIN_DEFAULT=>0x00000008,SQL_AD_DROP_DOMAIN_DEFAULT=>0x00000010,SQL_AD_ADD_CONSTRAINT_INITIALLY_DEFERRED=>0x00000020,SQL_AD_ADD_CONSTRAINT_INITIALLY_IMMEDIATE=>0x00000040,SQL_AD_ADD_CONSTRAINT_DEFERRABLE=>0x00000080,SQL_AD_ADD_CONSTRAINT_NON_DEFERRABLE=>0x00000100 };$ReturnValues{SQL_ALTER_TABLE}={SQL_AT_ADD_COLUMN=>0x00000001,SQL_AT_DROP_COLUMN=>0x00000002,SQL_AT_ADD_CONSTRAINT=>0x00000008,SQL_AT_ADD_COLUMN_SINGLE=>0x00000020,SQL_AT_ADD_COLUMN_DEFAULT=>0x00000040,SQL_AT_ADD_COLUMN_COLLATION=>0x00000080,SQL_AT_SET_COLUMN_DEFAULT=>0x00000100,SQL_AT_DROP_COLUMN_DEFAULT=>0x00000200,SQL_AT_DROP_COLUMN_CASCADE=>0x00000400,SQL_AT_DROP_COLUMN_RESTRICT=>0x00000800,SQL_AT_ADD_TABLE_CONSTRAINT=>0x00001000,SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE=>0x00002000,SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT=>0x00004000,SQL_AT_CONSTRAINT_NAME_DEFINITION=>0x00008000,SQL_AT_CONSTRAINT_INITIALLY_DEFERRED=>0x00010000,SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE=>0x00020000,SQL_AT_CONSTRAINT_DEFERRABLE=>0x00040000,SQL_AT_CONSTRAINT_NON_DEFERRABLE=>0x00080000 };$ReturnValues{SQL_ASYNC_MODE}={SQL_AM_NONE=>0,SQL_AM_CONNECTION=>1,SQL_AM_STATEMENT=>2 };$ReturnValues{SQL_ATTR_MAX_ROWS}={SQL_CA2_MAX_ROWS_SELECT=>0x00000080,SQL_CA2_MAX_ROWS_INSERT=>0x00000100,SQL_CA2_MAX_ROWS_DELETE=>0x00000200,SQL_CA2_MAX_ROWS_UPDATE=>0x00000400,SQL_CA2_MAX_ROWS_CATALOG=>0x00000800 };$ReturnValues{SQL_ATTR_SCROLL_CONCURRENCY}={SQL_CA2_READ_ONLY_CONCURRENCY=>0x00000001,SQL_CA2_LOCK_CONCURRENCY=>0x00000002,SQL_CA2_OPT_ROWVER_CONCURRENCY=>0x00000004,SQL_CA2_OPT_VALUES_CONCURRENCY=>0x00000008,SQL_CA2_SENSITIVITY_ADDITIONS=>0x00000010,SQL_CA2_SENSITIVITY_DELETIONS=>0x00000020,SQL_CA2_SENSITIVITY_UPDATES=>0x00000040 };$ReturnValues{SQL_BATCH_ROW_COUNT}={SQL_BRC_PROCEDURES=>0x0000001,SQL_BRC_EXPLICIT=>0x0000002,SQL_BRC_ROLLED_UP=>0x0000004 };$ReturnValues{SQL_BATCH_SUPPORT}={SQL_BS_SELECT_EXPLICIT=>0x00000001,SQL_BS_ROW_COUNT_EXPLICIT=>0x00000002,SQL_BS_SELECT_PROC=>0x00000004,SQL_BS_ROW_COUNT_PROC=>0x00000008 };$ReturnValues{SQL_BOOKMARK_PERSISTENCE}={SQL_BP_CLOSE=>0x00000001,SQL_BP_DELETE=>0x00000002,SQL_BP_DROP=>0x00000004,SQL_BP_TRANSACTION=>0x00000008,SQL_BP_UPDATE=>0x00000010,SQL_BP_OTHER_HSTMT=>0x00000020,SQL_BP_SCROLL=>0x00000040 };$ReturnValues{SQL_CATALOG_LOCATION}={SQL_CL_START=>0x0001 ,SQL_CL_END=>0x0002 };$ReturnValues{SQL_CATALOG_USAGE}={SQL_CU_DML_STATEMENTS=>0x00000001 ,SQL_CU_PROCEDURE_INVOCATION=>0x00000002 ,SQL_CU_TABLE_DEFINITION=>0x00000004 ,SQL_CU_INDEX_DEFINITION=>0x00000008 ,SQL_CU_PRIVILEGE_DEFINITION=>0x00000010 };$ReturnValues{SQL_CONCAT_NULL_BEHAVIOR}={SQL_CB_NULL=>0x0000,SQL_CB_NON_NULL=>0x0001 };$ReturnValues{SQL_CONVERT_}={SQL_CVT_CHAR=>0x00000001,SQL_CVT_NUMERIC=>0x00000002,SQL_CVT_DECIMAL=>0x00000004,SQL_CVT_INTEGER=>0x00000008,SQL_CVT_SMALLINT=>0x00000010,SQL_CVT_FLOAT=>0x00000020,SQL_CVT_REAL=>0x00000040,SQL_CVT_DOUBLE=>0x00000080,SQL_CVT_VARCHAR=>0x00000100,SQL_CVT_LONGVARCHAR=>0x00000200,SQL_CVT_BINARY=>0x00000400,SQL_CVT_VARBINARY=>0x00000800,SQL_CVT_BIT=>0x00001000,SQL_CVT_TINYINT=>0x00002000,SQL_CVT_BIGINT=>0x00004000,SQL_CVT_DATE=>0x00008000,SQL_CVT_TIME=>0x00010000,SQL_CVT_TIMESTAMP=>0x00020000,SQL_CVT_LONGVARBINARY=>0x00040000,SQL_CVT_INTERVAL_YEAR_MONTH=>0x00080000,SQL_CVT_INTERVAL_DAY_TIME=>0x00100000,SQL_CVT_WCHAR=>0x00200000,SQL_CVT_WLONGVARCHAR=>0x00400000,SQL_CVT_WVARCHAR=>0x00800000,SQL_CVT_GUID=>0x01000000 };$ReturnValues{SQL_CONVERT_BIGINT }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_BINARY }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_BIT }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_CHAR }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_DATE }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_DECIMAL }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_DOUBLE }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_FLOAT }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_GUID }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_INTEGER }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_INTERVAL_DAY_TIME }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_INTERVAL_YEAR_MONTH}=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_LONGVARBINARY }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_LONGVARCHAR }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_NUMERIC }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_REAL }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_SMALLINT }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_TIME }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_TIMESTAMP }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_TINYINT }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_VARBINARY }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_VARCHAR }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_WCHAR }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_WLONGVARCHAR }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_WVARCHAR }=$ReturnValues{SQL_CONVERT_};$ReturnValues{SQL_CONVERT_FUNCTIONS}={SQL_FN_CVT_CONVERT=>0x00000001,SQL_FN_CVT_CAST=>0x00000002 };$ReturnValues{SQL_CORRELATION_NAME}={SQL_CN_NONE=>0x0000,SQL_CN_DIFFERENT=>0x0001,SQL_CN_ANY=>0x0002 };$ReturnValues{SQL_CREATE_ASSERTION}={SQL_CA_CREATE_ASSERTION=>0x00000001,SQL_CA_CONSTRAINT_INITIALLY_DEFERRED=>0x00000010,SQL_CA_CONSTRAINT_INITIALLY_IMMEDIATE=>0x00000020,SQL_CA_CONSTRAINT_DEFERRABLE=>0x00000040,SQL_CA_CONSTRAINT_NON_DEFERRABLE=>0x00000080 };$ReturnValues{SQL_CREATE_CHARACTER_SET}={SQL_CCS_CREATE_CHARACTER_SET=>0x00000001,SQL_CCS_COLLATE_CLAUSE=>0x00000002,SQL_CCS_LIMITED_COLLATION=>0x00000004 };$ReturnValues{SQL_CREATE_COLLATION}={SQL_CCOL_CREATE_COLLATION=>0x00000001 };$ReturnValues{SQL_CREATE_DOMAIN}={SQL_CDO_CREATE_DOMAIN=>0x00000001,SQL_CDO_DEFAULT=>0x00000002,SQL_CDO_CONSTRAINT=>0x00000004,SQL_CDO_COLLATION=>0x00000008,SQL_CDO_CONSTRAINT_NAME_DEFINITION=>0x00000010,SQL_CDO_CONSTRAINT_INITIALLY_DEFERRED=>0x00000020,SQL_CDO_CONSTRAINT_INITIALLY_IMMEDIATE=>0x00000040,SQL_CDO_CONSTRAINT_DEFERRABLE=>0x00000080,SQL_CDO_CONSTRAINT_NON_DEFERRABLE=>0x00000100 };$ReturnValues{SQL_CREATE_SCHEMA}={SQL_CS_CREATE_SCHEMA=>0x00000001,SQL_CS_AUTHORIZATION=>0x00000002,SQL_CS_DEFAULT_CHARACTER_SET=>0x00000004 };$ReturnValues{SQL_CREATE_TABLE}={SQL_CT_CREATE_TABLE=>0x00000001,SQL_CT_COMMIT_PRESERVE=>0x00000002,SQL_CT_COMMIT_DELETE=>0x00000004,SQL_CT_GLOBAL_TEMPORARY=>0x00000008,SQL_CT_LOCAL_TEMPORARY=>0x00000010,SQL_CT_CONSTRAINT_INITIALLY_DEFERRED=>0x00000020,SQL_CT_CONSTRAINT_INITIALLY_IMMEDIATE=>0x00000040,SQL_CT_CONSTRAINT_DEFERRABLE=>0x00000080,SQL_CT_CONSTRAINT_NON_DEFERRABLE=>0x00000100,SQL_CT_COLUMN_CONSTRAINT=>0x00000200,SQL_CT_COLUMN_DEFAULT=>0x00000400,SQL_CT_COLUMN_COLLATION=>0x00000800,SQL_CT_TABLE_CONSTRAINT=>0x00001000,SQL_CT_CONSTRAINT_NAME_DEFINITION=>0x00002000 };$ReturnValues{SQL_CREATE_TRANSLATION}={SQL_CTR_CREATE_TRANSLATION=>0x00000001 };$ReturnValues{SQL_CREATE_VIEW}={SQL_CV_CREATE_VIEW=>0x00000001,SQL_CV_CHECK_OPTION=>0x00000002,SQL_CV_CASCADED=>0x00000004,SQL_CV_LOCAL=>0x00000008 };$ReturnValues{SQL_CURSOR_COMMIT_BEHAVIOR}={SQL_CB_DELETE=>0,SQL_CB_CLOSE=>1,SQL_CB_PRESERVE=>2 };$ReturnValues{SQL_CURSOR_ROLLBACK_BEHAVIOR}=$ReturnValues{SQL_CURSOR_COMMIT_BEHAVIOR};$ReturnValues{SQL_CURSOR_SENSITIVITY}={SQL_UNSPECIFIED=>0,SQL_INSENSITIVE=>1,SQL_SENSITIVE=>2 };$ReturnValues{SQL_DATETIME_LITERALS}={SQL_DL_SQL92_DATE=>0x00000001,SQL_DL_SQL92_TIME=>0x00000002,SQL_DL_SQL92_TIMESTAMP=>0x00000004,SQL_DL_SQL92_INTERVAL_YEAR=>0x00000008,SQL_DL_SQL92_INTERVAL_MONTH=>0x00000010,SQL_DL_SQL92_INTERVAL_DAY=>0x00000020,SQL_DL_SQL92_INTERVAL_HOUR=>0x00000040,SQL_DL_SQL92_INTERVAL_MINUTE=>0x00000080,SQL_DL_SQL92_INTERVAL_SECOND=>0x00000100,SQL_DL_SQL92_INTERVAL_YEAR_TO_MONTH=>0x00000200,SQL_DL_SQL92_INTERVAL_DAY_TO_HOUR=>0x00000400,SQL_DL_SQL92_INTERVAL_DAY_TO_MINUTE=>0x00000800,SQL_DL_SQL92_INTERVAL_DAY_TO_SECOND=>0x00001000,SQL_DL_SQL92_INTERVAL_HOUR_TO_MINUTE=>0x00002000,SQL_DL_SQL92_INTERVAL_HOUR_TO_SECOND=>0x00004000,SQL_DL_SQL92_INTERVAL_MINUTE_TO_SECOND=>0x00008000 };$ReturnValues{SQL_DDL_INDEX}={SQL_DI_CREATE_INDEX=>0x00000001,SQL_DI_DROP_INDEX=>0x00000002 };$ReturnValues{SQL_DIAG_CURSOR_ROW_COUNT}={SQL_CA2_CRC_EXACT=>0x00001000,SQL_CA2_CRC_APPROXIMATE=>0x00002000,SQL_CA2_SIMULATE_NON_UNIQUE=>0x00004000,SQL_CA2_SIMULATE_TRY_UNIQUE=>0x00008000,SQL_CA2_SIMULATE_UNIQUE=>0x00010000 };$ReturnValues{SQL_DROP_ASSERTION}={SQL_DA_DROP_ASSERTION=>0x00000001 };$ReturnValues{SQL_DROP_CHARACTER_SET}={SQL_DCS_DROP_CHARACTER_SET=>0x00000001 };$ReturnValues{SQL_DROP_COLLATION}={SQL_DC_DROP_COLLATION=>0x00000001 };$ReturnValues{SQL_DROP_DOMAIN}={SQL_DD_DROP_DOMAIN=>0x00000001,SQL_DD_RESTRICT=>0x00000002,SQL_DD_CASCADE=>0x00000004 };$ReturnValues{SQL_DROP_SCHEMA}={SQL_DS_DROP_SCHEMA=>0x00000001,SQL_DS_RESTRICT=>0x00000002,SQL_DS_CASCADE=>0x00000004 };$ReturnValues{SQL_DROP_TABLE}={SQL_DT_DROP_TABLE=>0x00000001,SQL_DT_RESTRICT=>0x00000002,SQL_DT_CASCADE=>0x00000004 };$ReturnValues{SQL_DROP_TRANSLATION}={SQL_DTR_DROP_TRANSLATION=>0x00000001 };$ReturnValues{SQL_DROP_VIEW}={SQL_DV_DROP_VIEW=>0x00000001,SQL_DV_RESTRICT=>0x00000002,SQL_DV_CASCADE=>0x00000004 };$ReturnValues{SQL_CURSOR_ATTRIBUTES1}={SQL_CA1_NEXT=>0x00000001,SQL_CA1_ABSOLUTE=>0x00000002,SQL_CA1_RELATIVE=>0x00000004,SQL_CA1_BOOKMARK=>0x00000008,SQL_CA1_LOCK_NO_CHANGE=>0x00000040,SQL_CA1_LOCK_EXCLUSIVE=>0x00000080,SQL_CA1_LOCK_UNLOCK=>0x00000100,SQL_CA1_POS_POSITION=>0x00000200,SQL_CA1_POS_UPDATE=>0x00000400,SQL_CA1_POS_DELETE=>0x00000800,SQL_CA1_POS_REFRESH=>0x00001000,SQL_CA1_POSITIONED_UPDATE=>0x00002000,SQL_CA1_POSITIONED_DELETE=>0x00004000,SQL_CA1_SELECT_FOR_UPDATE=>0x00008000,SQL_CA1_BULK_ADD=>0x00010000,SQL_CA1_BULK_UPDATE_BY_BOOKMARK=>0x00020000,SQL_CA1_BULK_DELETE_BY_BOOKMARK=>0x00040000,SQL_CA1_BULK_FETCH_BY_BOOKMARK=>0x00080000 };$ReturnValues{SQL_DYNAMIC_CURSOR_ATTRIBUTES1}=$ReturnValues{SQL_CURSOR_ATTRIBUTES1};$ReturnValues{SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1}=$ReturnValues{SQL_CURSOR_ATTRIBUTES1};$ReturnValues{SQL_KEYSET_CURSOR_ATTRIBUTES1}=$ReturnValues{SQL_CURSOR_ATTRIBUTES1};$ReturnValues{SQL_STATIC_CURSOR_ATTRIBUTES1}=$ReturnValues{SQL_CURSOR_ATTRIBUTES1};$ReturnValues{SQL_CURSOR_ATTRIBUTES2}={SQL_CA2_READ_ONLY_CONCURRENCY=>0x00000001,SQL_CA2_LOCK_CONCURRENCY=>0x00000002,SQL_CA2_OPT_ROWVER_CONCURRENCY=>0x00000004,SQL_CA2_OPT_VALUES_CONCURRENCY=>0x00000008,SQL_CA2_SENSITIVITY_ADDITIONS=>0x00000010,SQL_CA2_SENSITIVITY_DELETIONS=>0x00000020,SQL_CA2_SENSITIVITY_UPDATES=>0x00000040,SQL_CA2_MAX_ROWS_SELECT=>0x00000080,SQL_CA2_MAX_ROWS_INSERT=>0x00000100,SQL_CA2_MAX_ROWS_DELETE=>0x00000200,SQL_CA2_MAX_ROWS_UPDATE=>0x00000400,SQL_CA2_MAX_ROWS_CATALOG=>0x00000800,SQL_CA2_CRC_EXACT=>0x00001000,SQL_CA2_CRC_APPROXIMATE=>0x00002000,SQL_CA2_SIMULATE_NON_UNIQUE=>0x00004000,SQL_CA2_SIMULATE_TRY_UNIQUE=>0x00008000,SQL_CA2_SIMULATE_UNIQUE=>0x00010000 };$ReturnValues{SQL_DYNAMIC_CURSOR_ATTRIBUTES2}=$ReturnValues{SQL_CURSOR_ATTRIBUTES2};$ReturnValues{SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2}=$ReturnValues{SQL_CURSOR_ATTRIBUTES2};$ReturnValues{SQL_KEYSET_CURSOR_ATTRIBUTES2}=$ReturnValues{SQL_CURSOR_ATTRIBUTES2};$ReturnValues{SQL_STATIC_CURSOR_ATTRIBUTES2}=$ReturnValues{SQL_CURSOR_ATTRIBUTES2};$ReturnValues{SQL_FETCH_DIRECTION}={SQL_FD_FETCH_NEXT=>0x00000001,SQL_FD_FETCH_FIRST=>0x00000002,SQL_FD_FETCH_LAST=>0x00000004,SQL_FD_FETCH_PRIOR=>0x00000008,SQL_FD_FETCH_ABSOLUTE=>0x00000010,SQL_FD_FETCH_RELATIVE=>0x00000020,SQL_FD_FETCH_RESUME=>0x00000040,SQL_FD_FETCH_BOOKMARK=>0x00000080 };$ReturnValues{SQL_FILE_USAGE}={SQL_FILE_NOT_SUPPORTED=>0x0000,SQL_FILE_TABLE=>0x0001,SQL_FILE_QUALIFIER=>0x0002,SQL_FILE_CATALOG=>0x0002 };$ReturnValues{SQL_GETDATA_EXTENSIONS}={SQL_GD_ANY_COLUMN=>0x00000001,SQL_GD_ANY_ORDER=>0x00000002,SQL_GD_BLOCK=>0x00000004,SQL_GD_BOUND=>0x00000008 };$ReturnValues{SQL_GROUP_BY}={SQL_GB_NOT_SUPPORTED=>0x0000,SQL_GB_GROUP_BY_EQUALS_SELECT=>0x0001,SQL_GB_GROUP_BY_CONTAINS_SELECT=>0x0002,SQL_GB_NO_RELATION=>0x0003,SQL_GB_COLLATE=>0x0004 };$ReturnValues{SQL_IDENTIFIER_CASE}={SQL_IC_UPPER=>1,SQL_IC_LOWER=>2,SQL_IC_SENSITIVE=>3,SQL_IC_MIXED=>4 };$ReturnValues{SQL_INDEX_KEYWORDS}={SQL_IK_NONE=>0x00000000,SQL_IK_ASC=>0x00000001,SQL_IK_DESC=>0x00000002 };$ReturnValues{SQL_INFO_SCHEMA_VIEWS}={SQL_ISV_ASSERTIONS=>0x00000001,SQL_ISV_CHARACTER_SETS=>0x00000002,SQL_ISV_CHECK_CONSTRAINTS=>0x00000004,SQL_ISV_COLLATIONS=>0x00000008,SQL_ISV_COLUMN_DOMAIN_USAGE=>0x00000010,SQL_ISV_COLUMN_PRIVILEGES=>0x00000020,SQL_ISV_COLUMNS=>0x00000040,SQL_ISV_CONSTRAINT_COLUMN_USAGE=>0x00000080,SQL_ISV_CONSTRAINT_TABLE_USAGE=>0x00000100,SQL_ISV_DOMAIN_CONSTRAINTS=>0x00000200,SQL_ISV_DOMAINS=>0x00000400,SQL_ISV_KEY_COLUMN_USAGE=>0x00000800,SQL_ISV_REFERENTIAL_CONSTRAINTS=>0x00001000,SQL_ISV_SCHEMATA=>0x00002000,SQL_ISV_SQL_LANGUAGES=>0x00004000,SQL_ISV_TABLE_CONSTRAINTS=>0x00008000,SQL_ISV_TABLE_PRIVILEGES=>0x00010000,SQL_ISV_TABLES=>0x00020000,SQL_ISV_TRANSLATIONS=>0x00040000,SQL_ISV_USAGE_PRIVILEGES=>0x00080000,SQL_ISV_VIEW_COLUMN_USAGE=>0x00100000,SQL_ISV_VIEW_TABLE_USAGE=>0x00200000,SQL_ISV_VIEWS=>0x00400000 };$ReturnValues{SQL_INSERT_STATEMENT}={SQL_IS_INSERT_LITERALS=>0x00000001,SQL_IS_INSERT_SEARCHED=>0x00000002,SQL_IS_SELECT_INTO=>0x00000004 };$ReturnValues{SQL_LOCK_TYPES}={SQL_LCK_NO_CHANGE=>0x00000001,SQL_LCK_EXCLUSIVE=>0x00000002,SQL_LCK_UNLOCK=>0x00000004 };$ReturnValues{SQL_NON_NULLABLE_COLUMNS}={SQL_NNC_NULL=>0x0000,SQL_NNC_NON_NULL=>0x0001 };$ReturnValues{SQL_NULL_COLLATION}={SQL_NC_HIGH=>0,SQL_NC_LOW=>1,SQL_NC_START=>0x0002,SQL_NC_END=>0x0004 };$ReturnValues{SQL_NUMERIC_FUNCTIONS}={SQL_FN_NUM_ABS=>0x00000001,SQL_FN_NUM_ACOS=>0x00000002,SQL_FN_NUM_ASIN=>0x00000004,SQL_FN_NUM_ATAN=>0x00000008,SQL_FN_NUM_ATAN2=>0x00000010,SQL_FN_NUM_CEILING=>0x00000020,SQL_FN_NUM_COS=>0x00000040,SQL_FN_NUM_COT=>0x00000080,SQL_FN_NUM_EXP=>0x00000100,SQL_FN_NUM_FLOOR=>0x00000200,SQL_FN_NUM_LOG=>0x00000400,SQL_FN_NUM_MOD=>0x00000800,SQL_FN_NUM_SIGN=>0x00001000,SQL_FN_NUM_SIN=>0x00002000,SQL_FN_NUM_SQRT=>0x00004000,SQL_FN_NUM_TAN=>0x00008000,SQL_FN_NUM_PI=>0x00010000,SQL_FN_NUM_RAND=>0x00020000,SQL_FN_NUM_DEGREES=>0x00040000,SQL_FN_NUM_LOG10=>0x00080000,SQL_FN_NUM_POWER=>0x00100000,SQL_FN_NUM_RADIANS=>0x00200000,SQL_FN_NUM_ROUND=>0x00400000,SQL_FN_NUM_TRUNCATE=>0x00800000 };$ReturnValues{SQL_ODBC_API_CONFORMANCE}={SQL_OAC_NONE=>0x0000,SQL_OAC_LEVEL1=>0x0001,SQL_OAC_LEVEL2=>0x0002 };$ReturnValues{SQL_ODBC_INTERFACE_CONFORMANCE}={SQL_OIC_CORE=>1,SQL_OIC_LEVEL1=>2,SQL_OIC_LEVEL2=>3 };$ReturnValues{SQL_ODBC_SAG_CLI_CONFORMANCE}={SQL_OSCC_NOT_COMPLIANT=>0x0000,SQL_OSCC_COMPLIANT=>0x0001 };$ReturnValues{SQL_ODBC_SQL_CONFORMANCE}={SQL_OSC_MINIMUM=>0x0000,SQL_OSC_CORE=>0x0001,SQL_OSC_EXTENDED=>0x0002 };$ReturnValues{SQL_OJ_CAPABILITIES}={SQL_OJ_LEFT=>0x00000001,SQL_OJ_RIGHT=>0x00000002,SQL_OJ_FULL=>0x00000004,SQL_OJ_NESTED=>0x00000008,SQL_OJ_NOT_ORDERED=>0x00000010,SQL_OJ_INNER=>0x00000020,SQL_OJ_ALL_COMPARISON_OPS=>0x00000040 };$ReturnValues{SQL_OWNER_USAGE}={SQL_OU_DML_STATEMENTS=>0x00000001,SQL_OU_PROCEDURE_INVOCATION=>0x00000002,SQL_OU_TABLE_DEFINITION=>0x00000004,SQL_OU_INDEX_DEFINITION=>0x00000008,SQL_OU_PRIVILEGE_DEFINITION=>0x00000010 };$ReturnValues{SQL_PARAM_ARRAY_ROW_COUNTS}={SQL_PARC_BATCH=>1,SQL_PARC_NO_BATCH=>2 };$ReturnValues{SQL_PARAM_ARRAY_SELECTS}={SQL_PAS_BATCH=>1,SQL_PAS_NO_BATCH=>2,SQL_PAS_NO_SELECT=>3 };$ReturnValues{SQL_POSITIONED_STATEMENTS}={SQL_PS_POSITIONED_DELETE=>0x00000001,SQL_PS_POSITIONED_UPDATE=>0x00000002,SQL_PS_SELECT_FOR_UPDATE=>0x00000004 };$ReturnValues{SQL_POS_OPERATIONS}={SQL_POS_POSITION=>0x00000001,SQL_POS_REFRESH=>0x00000002,SQL_POS_UPDATE=>0x00000004,SQL_POS_DELETE=>0x00000008,SQL_POS_ADD=>0x00000010 };$ReturnValues{SQL_QUALIFIER_LOCATION}={SQL_QL_START=>0x0001,SQL_QL_END=>0x0002 };$ReturnValues{SQL_QUALIFIER_USAGE}={SQL_QU_DML_STATEMENTS=>0x00000001,SQL_QU_PROCEDURE_INVOCATION=>0x00000002,SQL_QU_TABLE_DEFINITION=>0x00000004,SQL_QU_INDEX_DEFINITION=>0x00000008,SQL_QU_PRIVILEGE_DEFINITION=>0x00000010 };$ReturnValues{SQL_QUOTED_IDENTIFIER_CASE}=$ReturnValues{SQL_IDENTIFIER_CASE};$ReturnValues{SQL_SCHEMA_USAGE}={SQL_SU_DML_STATEMENTS=>0x00000001 ,SQL_SU_PROCEDURE_INVOCATION=>0x00000002 ,SQL_SU_TABLE_DEFINITION=>0x00000004 ,SQL_SU_INDEX_DEFINITION=>0x00000008 ,SQL_SU_PRIVILEGE_DEFINITION=>0x00000010 };$ReturnValues{SQL_SCROLL_CONCURRENCY}={SQL_SCCO_READ_ONLY=>0x00000001,SQL_SCCO_LOCK=>0x00000002,SQL_SCCO_OPT_ROWVER=>0x00000004,SQL_SCCO_OPT_VALUES=>0x00000008 };$ReturnValues{SQL_SCROLL_OPTIONS}={SQL_SO_FORWARD_ONLY=>0x00000001,SQL_SO_KEYSET_DRIVEN=>0x00000002,SQL_SO_DYNAMIC=>0x00000004,SQL_SO_MIXED=>0x00000008,SQL_SO_STATIC=>0x00000010 };$ReturnValues{SQL_SQL92_DATETIME_FUNCTIONS}={SQL_SDF_CURRENT_DATE=>0x00000001,SQL_SDF_CURRENT_TIME=>0x00000002,SQL_SDF_CURRENT_TIMESTAMP=>0x00000004 };$ReturnValues{SQL_SQL92_FOREIGN_KEY_DELETE_RULE}={SQL_SFKD_CASCADE=>0x00000001,SQL_SFKD_NO_ACTION=>0x00000002,SQL_SFKD_SET_DEFAULT=>0x00000004,SQL_SFKD_SET_NULL=>0x00000008 };$ReturnValues{SQL_SQL92_FOREIGN_KEY_UPDATE_RULE}={SQL_SFKU_CASCADE=>0x00000001,SQL_SFKU_NO_ACTION=>0x00000002,SQL_SFKU_SET_DEFAULT=>0x00000004,SQL_SFKU_SET_NULL=>0x00000008 };$ReturnValues{SQL_SQL92_GRANT}={SQL_SG_USAGE_ON_DOMAIN=>0x00000001,SQL_SG_USAGE_ON_CHARACTER_SET=>0x00000002,SQL_SG_USAGE_ON_COLLATION=>0x00000004,SQL_SG_USAGE_ON_TRANSLATION=>0x00000008,SQL_SG_WITH_GRANT_OPTION=>0x00000010,SQL_SG_DELETE_TABLE=>0x00000020,SQL_SG_INSERT_TABLE=>0x00000040,SQL_SG_INSERT_COLUMN=>0x00000080,SQL_SG_REFERENCES_TABLE=>0x00000100,SQL_SG_REFERENCES_COLUMN=>0x00000200,SQL_SG_SELECT_TABLE=>0x00000400,SQL_SG_UPDATE_TABLE=>0x00000800,SQL_SG_UPDATE_COLUMN=>0x00001000 };$ReturnValues{SQL_SQL92_NUMERIC_VALUE_FUNCTIONS}={SQL_SNVF_BIT_LENGTH=>0x00000001,SQL_SNVF_CHAR_LENGTH=>0x00000002,SQL_SNVF_CHARACTER_LENGTH=>0x00000004,SQL_SNVF_EXTRACT=>0x00000008,SQL_SNVF_OCTET_LENGTH=>0x00000010,SQL_SNVF_POSITION=>0x00000020 };$ReturnValues{SQL_SQL92_PREDICATES}={SQL_SP_EXISTS=>0x00000001,SQL_SP_ISNOTNULL=>0x00000002,SQL_SP_ISNULL=>0x00000004,SQL_SP_MATCH_FULL=>0x00000008,SQL_SP_MATCH_PARTIAL=>0x00000010,SQL_SP_MATCH_UNIQUE_FULL=>0x00000020,SQL_SP_MATCH_UNIQUE_PARTIAL=>0x00000040,SQL_SP_OVERLAPS=>0x00000080,SQL_SP_UNIQUE=>0x00000100,SQL_SP_LIKE=>0x00000200,SQL_SP_IN=>0x00000400,SQL_SP_BETWEEN=>0x00000800,SQL_SP_COMPARISON=>0x00001000,SQL_SP_QUANTIFIED_COMPARISON=>0x00002000 };$ReturnValues{SQL_SQL92_RELATIONAL_JOIN_OPERATORS}={SQL_SRJO_CORRESPONDING_CLAUSE=>0x00000001,SQL_SRJO_CROSS_JOIN=>0x00000002,SQL_SRJO_EXCEPT_JOIN=>0x00000004,SQL_SRJO_FULL_OUTER_JOIN=>0x00000008,SQL_SRJO_INNER_JOIN=>0x00000010,SQL_SRJO_INTERSECT_JOIN=>0x00000020,SQL_SRJO_LEFT_OUTER_JOIN=>0x00000040,SQL_SRJO_NATURAL_JOIN=>0x00000080,SQL_SRJO_RIGHT_OUTER_JOIN=>0x00000100,SQL_SRJO_UNION_JOIN=>0x00000200 };$ReturnValues{SQL_SQL92_REVOKE}={SQL_SR_USAGE_ON_DOMAIN=>0x00000001,SQL_SR_USAGE_ON_CHARACTER_SET=>0x00000002,SQL_SR_USAGE_ON_COLLATION=>0x00000004,SQL_SR_USAGE_ON_TRANSLATION=>0x00000008,SQL_SR_GRANT_OPTION_FOR=>0x00000010,SQL_SR_CASCADE=>0x00000020,SQL_SR_RESTRICT=>0x00000040,SQL_SR_DELETE_TABLE=>0x00000080,SQL_SR_INSERT_TABLE=>0x00000100,SQL_SR_INSERT_COLUMN=>0x00000200,SQL_SR_REFERENCES_TABLE=>0x00000400,SQL_SR_REFERENCES_COLUMN=>0x00000800,SQL_SR_SELECT_TABLE=>0x00001000,SQL_SR_UPDATE_TABLE=>0x00002000,SQL_SR_UPDATE_COLUMN=>0x00004000 };$ReturnValues{SQL_SQL92_ROW_VALUE_CONSTRUCTOR}={SQL_SRVC_VALUE_EXPRESSION=>0x00000001,SQL_SRVC_NULL=>0x00000002,SQL_SRVC_DEFAULT=>0x00000004,SQL_SRVC_ROW_SUBQUERY=>0x00000008 };$ReturnValues{SQL_SQL92_STRING_FUNCTIONS}={SQL_SSF_CONVERT=>0x00000001,SQL_SSF_LOWER=>0x00000002,SQL_SSF_UPPER=>0x00000004,SQL_SSF_SUBSTRING=>0x00000008,SQL_SSF_TRANSLATE=>0x00000010,SQL_SSF_TRIM_BOTH=>0x00000020,SQL_SSF_TRIM_LEADING=>0x00000040,SQL_SSF_TRIM_TRAILING=>0x00000080 };$ReturnValues{SQL_SQL92_VALUE_EXPRESSIONS}={SQL_SVE_CASE=>0x00000001,SQL_SVE_CAST=>0x00000002,SQL_SVE_COALESCE=>0x00000004,SQL_SVE_NULLIF=>0x00000008 };$ReturnValues{SQL_SQL_CONFORMANCE}={SQL_SC_SQL92_ENTRY=>0x00000001,SQL_SC_FIPS127_2_TRANSITIONAL=>0x00000002,SQL_SC_SQL92_INTERMEDIATE=>0x00000004,SQL_SC_SQL92_FULL=>0x00000008 };$ReturnValues{SQL_STANDARD_CLI_CONFORMANCE}={SQL_SCC_XOPEN_CLI_VERSION1=>0x00000001,SQL_SCC_ISO92_CLI=>0x00000002 };$ReturnValues{SQL_STATIC_SENSITIVITY}={SQL_SS_ADDITIONS=>0x00000001,SQL_SS_DELETIONS=>0x00000002,SQL_SS_UPDATES=>0x00000004 };$ReturnValues{SQL_STRING_FUNCTIONS}={SQL_FN_STR_CONCAT=>0x00000001,SQL_FN_STR_INSERT=>0x00000002,SQL_FN_STR_LEFT=>0x00000004,SQL_FN_STR_LTRIM=>0x00000008,SQL_FN_STR_LENGTH=>0x00000010,SQL_FN_STR_LOCATE=>0x00000020,SQL_FN_STR_LCASE=>0x00000040,SQL_FN_STR_REPEAT=>0x00000080,SQL_FN_STR_REPLACE=>0x00000100,SQL_FN_STR_RIGHT=>0x00000200,SQL_FN_STR_RTRIM=>0x00000400,SQL_FN_STR_SUBSTRING=>0x00000800,SQL_FN_STR_UCASE=>0x00001000,SQL_FN_STR_ASCII=>0x00002000,SQL_FN_STR_CHAR=>0x00004000,SQL_FN_STR_DIFFERENCE=>0x00008000,SQL_FN_STR_LOCATE_2=>0x00010000,SQL_FN_STR_SOUNDEX=>0x00020000,SQL_FN_STR_SPACE=>0x00040000,SQL_FN_STR_BIT_LENGTH=>0x00080000,SQL_FN_STR_CHAR_LENGTH=>0x00100000,SQL_FN_STR_CHARACTER_LENGTH=>0x00200000,SQL_FN_STR_OCTET_LENGTH=>0x00400000,SQL_FN_STR_POSITION=>0x00800000 };$ReturnValues{SQL_SUBQUERIES}={SQL_SQ_COMPARISON=>0x00000001,SQL_SQ_EXISTS=>0x00000002,SQL_SQ_IN=>0x00000004,SQL_SQ_QUANTIFIED=>0x00000008,SQL_SQ_CORRELATED_SUBQUERIES=>0x00000010 };$ReturnValues{SQL_SYSTEM_FUNCTIONS}={SQL_FN_SYS_USERNAME=>0x00000001,SQL_FN_SYS_DBNAME=>0x00000002,SQL_FN_SYS_IFNULL=>0x00000004 };$ReturnValues{SQL_TIMEDATE_ADD_INTERVALS}={SQL_FN_TSI_FRAC_SECOND=>0x00000001,SQL_FN_TSI_SECOND=>0x00000002,SQL_FN_TSI_MINUTE=>0x00000004,SQL_FN_TSI_HOUR=>0x00000008,SQL_FN_TSI_DAY=>0x00000010,SQL_FN_TSI_WEEK=>0x00000020,SQL_FN_TSI_MONTH=>0x00000040,SQL_FN_TSI_QUARTER=>0x00000080,SQL_FN_TSI_YEAR=>0x00000100 };$ReturnValues{SQL_TIMEDATE_FUNCTIONS}={SQL_FN_TD_NOW=>0x00000001,SQL_FN_TD_CURDATE=>0x00000002,SQL_FN_TD_DAYOFMONTH=>0x00000004,SQL_FN_TD_DAYOFWEEK=>0x00000008,SQL_FN_TD_DAYOFYEAR=>0x00000010,SQL_FN_TD_MONTH=>0x00000020,SQL_FN_TD_QUARTER=>0x00000040,SQL_FN_TD_WEEK=>0x00000080,SQL_FN_TD_YEAR=>0x00000100,SQL_FN_TD_CURTIME=>0x00000200,SQL_FN_TD_HOUR=>0x00000400,SQL_FN_TD_MINUTE=>0x00000800,SQL_FN_TD_SECOND=>0x00001000,SQL_FN_TD_TIMESTAMPADD=>0x00002000,SQL_FN_TD_TIMESTAMPDIFF=>0x00004000,SQL_FN_TD_DAYNAME=>0x00008000,SQL_FN_TD_MONTHNAME=>0x00010000,SQL_FN_TD_CURRENT_DATE=>0x00020000,SQL_FN_TD_CURRENT_TIME=>0x00040000,SQL_FN_TD_CURRENT_TIMESTAMP=>0x00080000,SQL_FN_TD_EXTRACT=>0x00100000 };$ReturnValues{SQL_TXN_CAPABLE}={SQL_TC_NONE=>0,SQL_TC_DML=>1,SQL_TC_ALL=>2,SQL_TC_DDL_COMMIT=>3,SQL_TC_DDL_IGNORE=>4 };$ReturnValues{SQL_TRANSACTION_ISOLATION_OPTION}={SQL_TRANSACTION_READ_UNCOMMITTED=>0x00000001 ,SQL_TRANSACTION_READ_COMMITTED=>0x00000002 ,SQL_TRANSACTION_REPEATABLE_READ=>0x00000004 ,SQL_TRANSACTION_SERIALIZABLE=>0x00000008 };$ReturnValues{SQL_DEFAULT_TRANSACTION_ISOLATION}=$ReturnValues{SQL_TRANSACTION_ISOLATION_OPTION};$ReturnValues{SQL_TXN_ISOLATION_OPTION}={SQL_TXN_READ_UNCOMMITTED=>0x00000001,SQL_TXN_READ_COMMITTED=>0x00000002,SQL_TXN_REPEATABLE_READ=>0x00000004,SQL_TXN_SERIALIZABLE=>0x00000008 };$ReturnValues{SQL_DEFAULT_TXN_ISOLATION}=$ReturnValues{SQL_TXN_ISOLATION_OPTION};$ReturnValues{SQL_TXN_VERSIONING}={SQL_TXN_VERSIONING=>0x00000010 };$ReturnValues{SQL_UNION}={SQL_U_UNION=>0x00000001,SQL_U_UNION_ALL=>0x00000002 };$ReturnValues{SQL_UNION_STATEMENT}={SQL_US_UNION=>0x00000001 ,SQL_US_UNION_ALL=>0x00000002 };1;
DBI_CONST_GETINFO_ODBC

$fatpacked{"DBI/Const/GetInfoReturn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_CONST_GETINFORETURN';
  package DBI::Const::GetInfoReturn;use strict;use Exporter ();use vars qw(@ISA @EXPORT @EXPORT_OK %GetInfoReturnTypes %GetInfoReturnValues);@ISA=qw(Exporter);@EXPORT=qw(%GetInfoReturnTypes %GetInfoReturnValues);my$VERSION="0.03";use DBI::Const::GetInfoType;use DBI::Const::GetInfo::ANSI ();use DBI::Const::GetInfo::ODBC ();%GetInfoReturnTypes=(%DBI::Const::GetInfo::ANSI::ReturnTypes,%DBI::Const::GetInfo::ODBC::ReturnTypes);%GetInfoReturnValues=();{my$A=\%DBI::Const::GetInfo::ANSI::ReturnValues;my$O=\%DBI::Const::GetInfo::ODBC::ReturnValues;while (my ($k,$v)=each %$A){my%h=(exists$O->{$k})? (%$v,%{$O->{$k}}): %$v;$GetInfoReturnValues{$k}=\%h}while (my ($k,$v)=each %$O){next if exists$A->{$k};my%h=%$v;$GetInfoReturnValues{$k}=\%h}}sub Format {my$InfoType=shift;my$Value=shift;return '' unless defined$Value;my$ReturnType=$GetInfoReturnTypes{$InfoType};return sprintf '0x%08X',$Value if$ReturnType eq 'SQLUINTEGER bitmask';return sprintf '0x%08X',$Value if$ReturnType eq 'SQLINTEGER bitmask';return$Value}sub Explain {my$InfoType=shift;my$Value=shift;return '' unless defined$Value;return '' unless exists$GetInfoReturnValues{$InfoType};$Value=int$Value;my$ReturnType=$GetInfoReturnTypes{$InfoType};my%h=reverse %{$GetInfoReturnValues{$InfoType}};if ($ReturnType eq 'SQLUINTEGER bitmask'|| $ReturnType eq 'SQLINTEGER bitmask'){my@a=();for my$k (sort {$a <=> $b}keys%h){push@a,$h{$k}if$Value & $k}return wantarray ? @a : join(' ',@a)}else {return$h{$Value}||'?'}}1;
DBI_CONST_GETINFORETURN

$fatpacked{"DBI/Const/GetInfoType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_CONST_GETINFOTYPE';
  package DBI::Const::GetInfoType;use strict;use Exporter ();use vars qw(@ISA @EXPORT @EXPORT_OK %GetInfoType);@ISA=qw(Exporter);@EXPORT=qw(%GetInfoType);my$VERSION="0.03";use DBI::Const::GetInfo::ANSI ();use DBI::Const::GetInfo::ODBC ();%GetInfoType=(%DBI::Const::GetInfo::ANSI::InfoTypes ,%DBI::Const::GetInfo::ODBC::InfoTypes);1;
DBI_CONST_GETINFOTYPE

$fatpacked{"DBI/DBD.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_DBD';
  package DBI::DBD;use strict;use vars qw($VERSION);$VERSION="0.03";use Exporter ();use Config qw(%Config);use Carp;use Cwd;use File::Spec;use strict;use vars qw(@ISA @EXPORT $is_dbi);BEGIN {if ($^O eq 'VMS'){require vmsish;import vmsish;require VMS::Filespec;import VMS::Filespec}else {*vmsify=sub {return $_[0]};*unixify=sub {return $_[0]}}}@ISA=qw(Exporter);@EXPORT=qw(dbd_dbi_dir dbd_dbi_arch_dir dbd_edit_mm_attribs dbd_postamble);BEGIN {$is_dbi=(-r 'DBI.pm' && -r 'DBI.xs' && -r 'DBIXS.h');require DBI unless$is_dbi}my$done_inst_checks;sub _inst_checks {return if$done_inst_checks++;my$cwd=cwd();if ($cwd =~ /\Q$Config{path_sep}/){warn "*** Warning: Path separator characters (`$Config{path_sep}') ","in the current directory path ($cwd) may cause problems\a\n\n";sleep 2}if ($cwd =~ /\s/){warn "*** Warning: whitespace characters ","in the current directory path ($cwd) may cause problems\a\n\n";sleep 2}if ($^O eq 'MSWin32' && $Config{cc}eq 'cl' &&!(exists$ENV{'LIB'}&& exists$ENV{'INCLUDE'})){die <<EOT}}sub dbd_edit_mm_attribs {my$mm_attr=shift;my$dbd_attr=shift || {};croak "dbd_edit_mm_attribs( \%makemaker [, \%other ]): too many parameters" if @_;_inst_checks();my%test_variants=(p=>{name=>"DBI::PurePerl",match=>qr/^\d/,add=>['$ENV{DBI_PUREPERL} = 2','END { delete $ENV{DBI_PUREPERL}; }' ],},g=>{name=>"DBD::Gofer",match=>qr/^\d/,add=>[q{$ENV{DBI_AUTOPROXY} = 'dbi:Gofer:transport=null;policy=pedantic'},q|END { delete $ENV{DBI_AUTOPROXY}; }| ],},n=>{name=>"DBI::SQL::Nano",match=>qr/^(?:48dbi_dbd_sqlengine|49dbd_file|5\ddbm_\w+|85gofer)\.t$/,add=>[q{$ENV{DBI_SQL_NANO} = 1},q|END { delete $ENV{DBI_SQL_NANO}; }| ],},);$dbd_attr->{create_pp_tests}or delete$test_variants{p};$dbd_attr->{create_nano_tests}or delete$test_variants{n};$dbd_attr->{create_gap_tests}or delete$test_variants{g};my@all_keys=my@tv_keys=sort keys%test_variants;while(@tv_keys){my$cur_key=shift@tv_keys;last if(1 < length$cur_key);my@new_keys;for my$remain (@tv_keys){push@new_keys,$cur_key .$remain unless$remain =~ /$cur_key/}push@tv_keys,@new_keys;push@all_keys,@new_keys}my%uniq_keys;for my$key (@all_keys){@tv_keys=sort split //,$key;my$ordered=join('',@tv_keys);$uniq_keys{$ordered}=1}@all_keys=sort {length$a <=> length$b or $a cmp $b}keys%uniq_keys;if(keys%test_variants){opendir DIR,'t' or die "Can't read 't' directory: $!";my@tests=grep {/\.t$/}readdir DIR;closedir DIR;for my$test_combo (@all_keys){@tv_keys=split //,$test_combo;my@test_names=map {$test_variants{$_}->{name}}@tv_keys;printf "Creating test wrappers for " .join(" + ",@test_names).":\n";my@test_matches=map {$test_variants{$_}->{match}}@tv_keys;my@test_adds;for my$test_add (map {$test_variants{$_}->{add}}@tv_keys){push@test_adds,@$test_add}my$v_type=$test_combo;$v_type='x' .$v_type if length($v_type)> 1;TEST: foreach my$test (sort@tests){for my$match (@test_matches){next TEST if$test !~ $match}my$usethr=($test =~ /(\d+|\b)thr/ && $] >= 5.008 && $Config{useithreads});my$v_test="t/zv${v_type}_$test";my$v_perl=($test =~ /taint/)? "perl -wT" : "perl -w";printf "%s %s\n",$v_test,($usethr)? "(use threads)" : "";open PPT,">$v_test" or warn "Can't create $v_test: $!";print PPT "#!$v_perl\n";print PPT "use threads;\n" if$usethr;print PPT "$_;\n" foreach@test_adds;print PPT "require './t/$test'; # or warn \$!;\n";close PPT or warn "Error writing $v_test: $!"}}}return %$mm_attr}sub dbd_dbi_dir {_inst_checks();return '.' if$is_dbi;my$dbidir=$INC{'DBI.pm'}|| die "DBI.pm not in %INC!";$dbidir =~ s:/DBI\.pm$::;return$dbidir}sub dbd_dbi_arch_dir {_inst_checks();return '$(INST_ARCHAUTODIR)' if$is_dbi;my$dbidir=dbd_dbi_dir();my%seen;my@try=grep {not $seen{$_}++}map {vmsify(unixify($_)."/auto/DBI/")}@INC;my@xst=grep {-f vmsify(unixify($_)."/Driver.xst")}@try;Carp::croak("Unable to locate Driver.xst in @try")unless@xst;Carp::carp("Multiple copies of Driver.xst found in: @xst")if@xst > 1;print "Using DBI $DBI::VERSION (for perl $] on $Config{archname}) installed in $xst[0]\n";return File::Spec->canonpath($xst[0])}sub dbd_postamble {my$self=shift;_inst_checks();my$dbi_instarch_dir=($is_dbi)? "." : dbd_dbi_arch_dir();my$dbi_driver_xst=File::Spec->catfile($dbi_instarch_dir,'Driver.xst');my$xstf_h=File::Spec->catfile($dbi_instarch_dir,'Driver_xst.h');return '
  *** You're using Microsoft Visual C++ compiler or similar but
      the LIB and INCLUDE environment variables are not both set.
  
      You need to run the VCVARS32.BAT batch file that was supplied
      with the compiler before you can use it.
  
      A copy of vcvars32.bat can typically be found in the following
      directories under your Visual Studio install directory:
          Visual C++ 6.0:     vc98\\bin
          Visual Studio .NET: vc7\\bin
  
      Find it, run it, then retry this.
  
      If you think this error is not correct then just set the LIB and
      INCLUDE environment variables to some value to disable the check.
  EOT
  # --- This section was generated by DBI::DBD::dbd_postamble()
  DBI_INSTARCH_DIR='.$dbi_instarch_dir.'
  DBI_DRIVER_XST='.$dbi_driver_xst.'
  
  # The main dependency (technically correct but probably not used)
  $(BASEEXT).c: $(BASEEXT).xsi
  
  # This dependency is needed since MakeMaker uses the .xs.o rule
  $(BASEEXT)$(OBJ_EXT): $(BASEEXT).xsi
  
  $(BASEEXT).xsi: $(DBI_DRIVER_XST) '.$xstf_h.'
  	$(PERL) -p -e "s/~DRIVER~/$(BASEEXT)/g" $(DBI_DRIVER_XST) > $(BASEEXT).xsi
  
  # ---
  '}package DBDI;1;
DBI_DBD

$fatpacked{"DBI/DBD/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_DBD_METADATA';
  package DBI::DBD::Metadata;use strict;use Exporter ();use Carp;use DBI;use DBI::Const::GetInfoType qw(%GetInfoType);our@ISA=qw(Exporter);our@EXPORT=qw(write_getinfo_pm write_typeinfo_pm);our$VERSION="0.03";sub write_getinfo_pm {my ($dsn,$user,$pass,$driver)=@_ ? @_ : @ARGV;my$dbh=DBI->connect($dsn,$user,$pass,{RaiseError=>1});$driver="<foo>" unless defined$driver;print <<PERL;my$kw_map=0;{local $\="\n";local $,="\n";my ($kw)=$dbh->get_info($GetInfoType{SQL_KEYWORDS});if ($kw){print "\nmy \@Keywords = qw(\n";print sort split /,/,$kw;print ");\n\n";print "sub sql_keywords {\n";print q%    return join ',', @Keywords;%;print "\n}\n\n";$kw_map=1}}print <<'PERL';print "\nour \%info = (\n";for my$key (sort keys%GetInfoType){my$num=$GetInfoType{$key};my$val=eval {$dbh->get_info($num)};if ($key eq 'SQL_DATA_SOURCE_NAME'){$val='\&sql_data_source_name'}elsif ($key eq 'SQL_KEYWORDS'){$val=($kw_map)? '\&sql_keywords' : 'undef'}elsif ($key eq 'SQL_DRIVER_NAME'){$val="\$INC{'DBD/$driver.pm'}"}elsif ($key eq 'SQL_DRIVER_VER'){$val='$sql_driver_ver'}elsif ($key eq 'SQL_USER_NAME'){$val='\&sql_user_name'}elsif (not defined$val){$val='undef'}elsif ($val eq ''){$val="''"}elsif ($val =~ /\D/){$val =~ s/\\/\\\\/g;$val =~ s/'/\\'/g;$val="'$val'"}printf "%s %5d => %-30s # %s\n",(($val eq 'undef')? '#' : ' '),$num,"$val,",$key}print ");\n\n1;\n\n__END__\n"}my%dbi_inv;my%sql_type_inv;sub inverse_hash {my (%hash)=@_;my (%inv);for my$key (keys%hash){my$val=$hash{$key};die "Double mapping for key value $val ($inv{$val}, $key)!" if (defined$inv{$val});$inv{$val}=$key}return%inv}sub fmt_value {my ($num,$val)=@_;if (!defined$val){$val="undef"}elsif ($val !~ m/^[-+]?\d+$/){$val =~ s/"/\\"/g if ($val =~ m/"/o);$val=qq{"$val"}}elsif ($dbi_inv{$num}=~ m/^(SQL_)?DATA_TYPE$/){$val=$sql_type_inv{$val}if (defined$sql_type_inv{$val})}return$val}sub write_typeinfo_pm {my ($dsn,$user,$pass,$driver)=@_ ? @_ : @ARGV;my$dbh=DBI->connect($dsn,$user,$pass,{AutoCommit=>1,RaiseError=>1});$driver="<foo>" unless defined$driver;print <<PERL;my%sql_type_map;for (@{$DBI::EXPORT_TAGS{sql_types}}){no strict 'refs';$sql_type_map{$_}=&{"DBI::$_"}();$sql_type_inv{$sql_type_map{$_}}=$_}my%dbi_map=(TYPE_NAME=>0,DATA_TYPE=>1,COLUMN_SIZE=>2,LITERAL_PREFIX=>3,LITERAL_SUFFIX=>4,CREATE_PARAMS=>5,NULLABLE=>6,CASE_SENSITIVE=>7,SEARCHABLE=>8,UNSIGNED_ATTRIBUTE=>9,FIXED_PREC_SCALE=>10,AUTO_UNIQUE_VALUE=>11,LOCAL_TYPE_NAME=>12,MINIMUM_SCALE=>13,MAXIMUM_SCALE=>14,SQL_DATA_TYPE=>15,SQL_DATETIME_SUB=>16,NUM_PREC_RADIX=>17,INTERVAL_PRECISION=>18,);%dbi_inv=inverse_hash(%dbi_map);my$maxlen=0;for my$key (keys%dbi_map){$maxlen=length($key)if length($key)> $maxlen}my$fmt="            \%-${maxlen}s => \%2d,\n";my$numkey=0;my$maxkey=0;print "    \$type_info_all = [\n        {\n";for my$i (sort {$a <=> $b}keys%dbi_inv){printf($fmt,$dbi_inv{$i},$i);$numkey++;$maxkey=$i}print "        },\n";print STDERR "### WARNING - Non-dense set of keys ($numkey keys, $maxkey max key)\n" unless$numkey=$maxkey + 1;my$h=$dbh->type_info_all;my@tia=@$h;my%odbc_map=map {uc $_=>$tia[0]->{$_}}keys %{$tia[0]};shift@tia;my$numtyp=$#tia;my@dbi_to_odbc;for my$num (sort {$a <=> $b}keys%dbi_inv){my$dbi_key=$dbi_inv{$num};$dbi_to_odbc[$num]=(defined$odbc_map{$dbi_key})? $odbc_map{$dbi_key}: undef}my@len;for (my$i=0;$i <= $numtyp;$i++){my@odbc_val=@{$tia[$i]};for (my$num=0;$num <= $maxkey;$num++){my$val=(defined$dbi_to_odbc[$num])? $odbc_val[$dbi_to_odbc[$num]]: undef;$val=fmt_value($num,$val);$val="$val,";$len[$num]=length($val)if!defined$len[$num]|| length($val)> $len[$num]}}my@fmt;for (my$i=0;$i <= $maxkey;$i++){$fmt[$i]="%-$len[$i]s"}for (my$i=0;$i <= $numtyp;$i++){my@odbc_val=@{$tia[$i]};print "        [ ";for (my$num=0;$num <= $maxkey;$num++){my$val=(defined$dbi_to_odbc[$num])? $odbc_val[$dbi_to_odbc[$num]]: undef;$val=fmt_value($num,$val);printf$fmt[$num],"$val,"}print " ],\n"}print "    ];\n\n    1;\n}\n\n__END__\n"}1;
  
  # Transfer this to ${driver}.pm
  
  # The get_info function was automatically generated by
  # DBI::DBD::Metadata::write_getinfo_pm v$DBI::DBD::Metadata::VERSION.
  
  package DBD::${driver}::db;         # This line can be removed once transferred.
  
      sub get_info {
          my(\$dbh, \$info_type) = \@_;
          require DBD::${driver}::GetInfo;
          my \$v = \$DBD::${driver}::GetInfo::info{int(\$info_type)};
          \$v = \$v->(\$dbh) if ref \$v eq 'CODE';
          return \$v;
      }
  
  # Transfer this to lib/DBD/${driver}/GetInfo.pm
  
  # The \%info hash was automatically generated by
  # DBI::DBD::Metadata::write_getinfo_pm v$DBI::DBD::Metadata::VERSION.
  
  package DBD::${driver}::GetInfo;
  
  use strict;
  use DBD::${driver};
  
  # Beware: not officially documented interfaces...
  # use DBI::Const::GetInfoType qw(\%GetInfoType);
  # use DBI::Const::GetInfoReturn qw(\%GetInfoReturnTypes \%GetInfoReturnValues);
  
  my \$sql_driver = '${driver}';
  my \$sql_ver_fmt = '%02d.%02d.%04d';   # ODBC version string: ##.##.#####
  my \$sql_driver_ver = sprintf \$sql_ver_fmt, split (/\\./, \$DBD::${driver}::VERSION);
  PERL
  
  sub sql_data_source_name {
      my $dbh = shift;
      return "dbi:$sql_driver:" . $dbh->{Name};
  }
  
  sub sql_user_name {
      my $dbh = shift;
      # CURRENT_USER is a non-standard attribute, probably undef
      # Username is a standard DBI attribute
      return $dbh->{CURRENT_USER} || $dbh->{Username};
  }
  
  PERL
  
  # Transfer this to ${driver}.pm
  
  # The type_info_all function was automatically generated by
  # DBI::DBD::Metadata::write_typeinfo_pm v$DBI::DBD::Metadata::VERSION.
  
  package DBD::${driver}::db;         # This line can be removed once transferred.
  
      sub type_info_all
      {
          my (\$dbh) = \@_;
          require DBD::${driver}::TypeInfo;
          return [ \@\$DBD::${driver}::TypeInfo::type_info_all ];
      }
  
  # Transfer this to lib/DBD/${driver}/TypeInfo.pm.
  # Don't forget to add version and intellectual property control information.
  
  # The \%type_info_all hash was automatically generated by
  # DBI::DBD::Metadata::write_typeinfo_pm v$DBI::DBD::Metadata::VERSION.
  
  package DBD::${driver}::TypeInfo;
  
  {
      require Exporter;
      require DynaLoader;
      \@ISA = qw(Exporter DynaLoader);
      \@EXPORT = qw(type_info_all);
      use DBI qw(:sql_types);
  
  PERL
DBI_DBD_METADATA

$fatpacked{"DBI/DBD/SqlEngine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_DBD_SQLENGINE';
  require 5.008;use strict;use DBI ();require DBI::SQL::Nano;package DBI::DBD::SqlEngine;use strict;use Carp;use vars qw(@ISA $VERSION $drh %methods_installed);$VERSION="0.03";$drh=undef;DBI->setup_driver("DBI::DBD::SqlEngine");my%accessors=(versions=>"get_driver_versions",new_meta=>"new_sql_engine_meta",get_meta=>"get_sql_engine_meta",set_meta=>"set_sql_engine_meta",clear_meta=>"clear_sql_engine_meta",);sub driver ($;$) {my ($class,$attr)=@_;$drh->{$class}and return$drh->{$class};$attr ||= {};{no strict "refs";unless ($attr->{Attribution}){$class eq "DBI::DBD::SqlEngine" and $attr->{Attribution}="$class by Jens Rehsack";$attr->{Attribution}||= ${$class ."::ATTRIBUTION"}|| "oops the author of $class forgot to define this"}$attr->{Version}||= ${$class ."::VERSION"};$attr->{Name}or ($attr->{Name}=$class)=~ s/^DBD\:\://}$drh->{$class}=DBI::_new_drh($class ."::dr",$attr);$drh->{$class}->STORE(ShowErrorStatement=>1);my$prefix=DBI->driver_prefix($class);if ($prefix){my$dbclass=$class ."::db";while (my ($accessor,$funcname)=each%accessors){my$method=$prefix .$accessor;$dbclass->can($method)and next;my$inject=sprintf <<'EOI',$dbclass,$method,$dbclass,$funcname;eval$inject;$dbclass->install_method($method)}}else {warn "Using DBI::DBD::SqlEngine with unregistered driver $class.\n" ."Reading documentation how to prevent is strongly recommended.\n"}my$stclass=$class ."::st";$stclass->install_method("sql_get_colnames")unless ($methods_installed{__PACKAGE__}++);return$drh->{$class}}sub CLONE {undef$drh}package DBI::DBD::SqlEngine::dr;use strict;use warnings;use vars qw(@ISA $imp_data_size);use Carp qw/carp/;$imp_data_size=0;sub connect ($$;$$$) {my ($drh,$dbname,$user,$auth,$attr)=@_;my$dbh=DBI::_new_dbh($drh,{Name=>$dbname,USER=>$user,CURRENT_USER=>$user,});if ($dbh){$dbh->func(0,"init_default_attributes");my$two_phased_init;defined$dbh->{sql_init_phase}and $two_phased_init=++$dbh->{sql_init_phase};my%second_phase_attrs;my@func_inits;exists$attr->{RootClass}and $second_phase_attrs{RootClass}=delete$attr->{RootClass};my ($var,$val);while (length$dbname){if ($dbname =~ s/^((?:[^\\;]|\\.)*?);//s){$var=$1}else {$var=$dbname;$dbname=""}if ($var =~ m/^(.+?)=(.*)/s){$var=$1;($val=$2)=~ s/\\(.)/$1/g;exists$attr->{$var}and carp("$var is given in DSN *and* \$attr during DBI->connect()")if ($^W);exists$attr->{$var}or $attr->{$var}=$val}elsif ($var =~ m/^(.+?)=>(.*)/s){$var=$1;($val=$2)=~ s/\\(.)/$1/g;my$ref=eval$val;push(@func_inits,$var,$ref)}}my%order=map {my$order=$_;map {($_=>$order)}@{$dbh->{sql_init_order}{$order}}}sort {$a <=> $b}keys %{$dbh->{sql_init_order}|| {}};my@ordered_attr=map {$_->[0]}sort {$a->[1]<=> $b->[1]}map {[$_,defined$order{$_}? $order{$_}: 50 ]}keys %$attr;for my$a (@ordered_attr){exists$attr->{$a}or next;$two_phased_init and eval {$dbh->{$a}=$attr->{$a};delete$attr->{$a}};$@ and $second_phase_attrs{$a}=delete$attr->{$a};$two_phased_init or $dbh->STORE($a,delete$attr->{$a})}$two_phased_init and $dbh->func(1,"init_default_attributes");%$attr=%second_phase_attrs;for (my$i=0;$i < scalar(@func_inits);$i += 2 ){my$func=$func_inits[$i];my$arg=$func_inits[$i + 1 ];$dbh->$func($arg)}$dbh->func("init_done");$dbh->STORE(Active=>1)}return$dbh}sub data_sources ($;$) {my ($drh,$attr)=@_;my$tbl_src;$attr and defined$attr->{sql_table_source}and $attr->{sql_table_source}->isa('DBI::DBD::SqlEngine::TableSource')and $tbl_src=$attr->{sql_table_source};!defined($tbl_src)and $drh->{ImplementorClass}->can('default_table_source')and $tbl_src=$drh->{ImplementorClass}->default_table_source();defined($tbl_src)or return;$tbl_src->data_sources($drh,$attr)}sub disconnect_all {}sub DESTROY {undef}package DBI::DBD::SqlEngine::db;use strict;use warnings;use vars qw(@ISA $imp_data_size);use Carp;if (eval {require Clone}){Clone->import("clone")}else {require Storable;*clone=\&Storable::dclone}$imp_data_size=0;sub ping {($_[0]->FETCH("Active"))? 1 : 0}sub data_sources {my ($dbh,$attr,@other)=@_;my$drh=$dbh->{Driver};ref($attr)eq 'HASH' or $attr={};defined($attr->{sql_table_source})or $attr->{sql_table_source}=$dbh->{sql_table_source};return$drh->data_sources($attr,@other)}sub prepare ($$;@) {my ($dbh,$statement,@attribs)=@_;my$sth=DBI::_new_sth($dbh,{Statement=>$statement });if ($sth){my$class=$sth->FETCH("ImplementorClass");$class =~ s/::st$/::Statement/;my$stmt;if ($class->isa("SQL::Statement")){my$parser=$dbh->{sql_parser_object};$parser ||= eval {$dbh->func("sql_parser_object")};if ($@){$stmt=eval {$class->new($statement)}}else {$stmt=eval {$class->new($statement,$parser)}}}else {$stmt=eval {$class->new($statement)}}if ($@ || $stmt->{errstr}){$dbh->set_err($DBI::stderr,$@ || $stmt->{errstr});undef$sth}else {$sth->STORE("sql_stmt",$stmt);$sth->STORE("sql_params",[]);$sth->STORE("NUM_OF_PARAMS",scalar($stmt->params()));my@colnames=$sth->sql_get_colnames();$sth->STORE("NUM_OF_FIELDS",scalar@colnames)}}return$sth}sub set_versions {my$dbh=$_[0];$dbh->{sql_engine_version}=$DBI::DBD::SqlEngine::VERSION;for (qw(nano_version statement_version)){defined$DBI::SQL::Nano::versions->{$_}or next;$dbh->{"sql_$_"}=$DBI::SQL::Nano::versions->{$_}}$dbh->{sql_handler}=$dbh->{sql_statement_version}? "SQL::Statement" : "DBI::SQL::Nano";return$dbh}sub init_valid_attributes {my$dbh=$_[0];$dbh->{sql_valid_attrs}={sql_engine_version=>1,sql_handler=>1,sql_nano_version=>1,sql_statement_version=>1,sql_flags=>1,sql_dialect=>1,sql_quoted_identifier_case=>1,sql_identifier_case=>1,sql_parser_object=>1,sql_sponge_driver=>1,sql_valid_attrs=>1,sql_readonly_attrs=>1,sql_init_phase=>1,sql_meta=>1,sql_meta_map=>1,sql_data_source=>1,};$dbh->{sql_readonly_attrs}={sql_engine_version=>1,sql_handler=>1,sql_nano_version=>1,sql_statement_version=>1,sql_quoted_identifier_case=>1,sql_parser_object=>1,sql_sponge_driver=>1,sql_valid_attrs=>1,sql_readonly_attrs=>1,};return$dbh}sub init_default_attributes {my ($dbh,$phase)=@_;my$given_phase=$phase;unless (defined($phase)){$phase=defined$dbh->{sql_init_phase};$phase and $phase=$dbh->{sql_init_phase}}if (0==$phase){$dbh->func("init_valid_attributes");$dbh->func("set_versions");$dbh->{sql_identifier_case}=2;$dbh->{sql_quoted_identifier_case}=3;$dbh->{sql_dialect}="CSV";$dbh->{sql_init_phase}=$given_phase;(my$drv_class=$dbh->{ImplementorClass})=~ s/::db$//;my$drv_prefix=DBI->driver_prefix($drv_class);my$valid_attrs=$drv_prefix ."valid_attrs";my$ro_attrs=$drv_prefix ."readonly_attrs";$dbh->{sql_engine_in_gofer}=(defined$INC{"DBD/Gofer.pm"}&& (caller(5))[0]eq "DBI::Gofer::Execute");$dbh->{sql_meta}={};$dbh->{sql_meta_map}={};my$drv_pfx_meta=$drv_prefix ."meta";$dbh->{sql_init_order}={0=>[qw(Profile RaiseError PrintError AutoCommit)],90=>["sql_meta",$dbh->{$drv_pfx_meta}? $dbh->{$drv_pfx_meta}: ()],};my@comp_attrs=qw(valid_attrs version readonly_attrs);if (exists$dbh->{$drv_pfx_meta}and!$dbh->{sql_engine_in_gofer}){my$attr=$dbh->{$drv_pfx_meta};defined$attr and defined$dbh->{$valid_attrs}and!defined$dbh->{$valid_attrs}{$attr}and $dbh->{$valid_attrs}{$attr}=1;my%h;tie%h,"DBI::DBD::SqlEngine::TieTables",$dbh;$dbh->{$attr}=\%h;push@comp_attrs,"meta"}for my$comp_attr (@comp_attrs){my$attr=$drv_prefix .$comp_attr;defined$dbh->{$valid_attrs}and!defined$dbh->{$valid_attrs}{$attr}and $dbh->{$valid_attrs}{$attr}=1;defined$dbh->{$ro_attrs}and!defined$dbh->{$ro_attrs}{$attr}and $dbh->{$ro_attrs}{$attr}=1}}return$dbh}sub init_done {defined $_[0]->{sql_init_phase}and delete $_[0]->{sql_init_phase};delete $_[0]->{sql_valid_attrs}->{sql_init_phase};return}sub sql_parser_object {my$dbh=$_[0];my$dialect=$dbh->{sql_dialect}|| "CSV";my$parser={RaiseError=>$dbh->FETCH("RaiseError"),PrintError=>$dbh->FETCH("PrintError"),};my$sql_flags=$dbh->FETCH("sql_flags")|| {};%$parser=(%$parser,%$sql_flags);$parser=SQL::Parser->new($dialect,$parser);$dbh->{sql_parser_object}=$parser;return$parser}sub sql_sponge_driver {my$dbh=$_[0];my$dbh2=$dbh->{sql_sponge_driver};unless ($dbh2){$dbh2=$dbh->{sql_sponge_driver}=DBI->connect("DBI:Sponge:");unless ($dbh2){$dbh->set_err($DBI::stderr,$DBI::errstr);return}}}sub disconnect ($) {%{$_[0]->{sql_meta}}=();%{$_[0]->{sql_meta_map}}=();$_[0]->STORE(Active=>0);return 1}sub validate_FETCH_attr {my ($dbh,$attrib)=@_;if ($dbh->{sql_engine_in_gofer}){(my$drv_class=$dbh->{ImplementorClass})=~ s/::db$//;my$drv_prefix=DBI->driver_prefix($drv_class);exists$dbh->{$drv_prefix ."meta" }&& $attrib eq $dbh->{$drv_prefix ."meta" }and $attrib="sql_meta"}return$attrib}sub FETCH ($$) {my ($dbh,$attrib)=@_;$attrib eq "AutoCommit" and return 1;if ($attrib eq (lc$attrib)){$attrib=$dbh->func($attrib,"validate_FETCH_attr")or return;my$attr_prefix;$attrib =~ m/^([a-z]+_)/ and $attr_prefix=$1;unless ($attr_prefix){(my$drv_class=$dbh->{ImplementorClass})=~ s/::db$//;$attr_prefix=DBI->driver_prefix($drv_class);$attrib=$attr_prefix .$attrib}my$valid_attrs=$attr_prefix ."valid_attrs";my$ro_attrs=$attr_prefix ."readonly_attrs";exists$dbh->{$valid_attrs}and ($dbh->{$valid_attrs}{$attrib}or return$dbh->set_err($DBI::stderr,"Invalid attribute '$attrib'"));exists$dbh->{$ro_attrs}and $dbh->{$ro_attrs}{$attrib}and defined$dbh->{$attrib}and refaddr($dbh->{$attrib})and return clone($dbh->{$attrib});return$dbh->{$attrib}}return$dbh->SUPER::FETCH($attrib)}sub validate_STORE_attr {my ($dbh,$attrib,$value)=@_;if ($attrib eq "sql_identifier_case" || $attrib eq "sql_quoted_identifier_case" and $value < 1 || $value > 4){croak "attribute '$attrib' must have a value from 1 .. 4 (SQL_IC_UPPER .. SQL_IC_MIXED)"}(my$drv_class=$dbh->{ImplementorClass})=~ s/::db$//;my$drv_prefix=DBI->driver_prefix($drv_class);exists$dbh->{$drv_prefix ."meta" }and $attrib eq $dbh->{$drv_prefix ."meta" }and $attrib="sql_meta";return ($attrib,$value)}sub STORE ($$$) {my ($dbh,$attrib,$value)=@_;if ($attrib eq "AutoCommit"){$value and return 1;croak "Can't disable AutoCommit"}if ($attrib eq lc$attrib){($attrib,$value)=$dbh->func($attrib,$value,"validate_STORE_attr");$attrib or return;my$attr_prefix;$attrib =~ m/^([a-z]+_)/ and $attr_prefix=$1;unless ($attr_prefix){(my$drv_class=$dbh->{ImplementorClass})=~ s/::db$//;$attr_prefix=DBI->driver_prefix($drv_class);$attrib=$attr_prefix .$attrib}my$valid_attrs=$attr_prefix ."valid_attrs";my$ro_attrs=$attr_prefix ."readonly_attrs";exists$dbh->{$valid_attrs}and ($dbh->{$valid_attrs}{$attrib}or return$dbh->set_err($DBI::stderr,"Invalid attribute '$attrib'"));exists$dbh->{$ro_attrs}and $dbh->{$ro_attrs}{$attrib}and defined$dbh->{$attrib}and return$dbh->set_err($DBI::stderr,"attribute '$attrib' is readonly and must not be modified");if ($attrib eq "sql_meta"){while (my ($k,$v)=each %$value){$dbh->{$attrib}{$k}=$v}}else {$dbh->{$attrib}=$value}return 1}return$dbh->SUPER::STORE($attrib,$value)}sub get_driver_versions {my ($dbh,$table)=@_;my%vsn=(OS=>"$^O ($Config::Config{osvers})",Perl=>"$] ($Config::Config{archname})",DBI=>$DBI::VERSION,);my%vmp;my$sql_engine_verinfo=join " ",$dbh->{sql_engine_version},"using",$dbh->{sql_handler},$dbh->{sql_handler}eq "SQL::Statement" ? $dbh->{sql_statement_version}: $dbh->{sql_nano_version};my$indent=0;my@deriveds=($dbh->{ImplementorClass});while (@deriveds){my$derived=shift@deriveds;$derived eq "DBI::DBD::SqlEngine::db" and last;$derived->isa("DBI::DBD::SqlEngine::db")or next;eval "push \@deriveds, \@${derived}::ISA";(my$drv_class=$derived)=~ s/::db$//;my$drv_prefix=DBI->driver_prefix($drv_class);my$ddgv=$dbh->{ImplementorClass}->can("get_${drv_prefix}versions");my$drv_version=$ddgv ? &$ddgv($dbh,$table): $dbh->{$drv_prefix ."version" };$drv_version ||= eval {$derived->VERSION()};$vsn{$drv_class}=$drv_version;$indent and $vmp{$drv_class}=" " x $indent .$drv_class;$indent += 2}$vsn{"DBI::DBD::SqlEngine"}=$sql_engine_verinfo;$indent and $vmp{"DBI::DBD::SqlEngine"}=" " x $indent ."DBI::DBD::SqlEngine";$DBI::PurePerl and $vsn{"DBI::PurePerl"}=$DBI::PurePerl::VERSION;$indent += 20;my@versions=map {sprintf "%-${indent}s %s",$vmp{$_}|| $_,$vsn{$_}}sort {$a->isa($b)and return -1;$b->isa($a)and return 1;$a->isa("DBI::DBD::SqlEngine")and return -1;$b->isa("DBI::DBD::SqlEngine")and return 1;return$a cmp $b}keys%vsn;return wantarray ? @versions : join "\n",@versions}sub get_single_table_meta {my ($dbh,$table,$attr)=@_;my$meta;$table eq "." and return$dbh->FETCH($attr);(my$class=$dbh->{ImplementorClass})=~ s/::db$/::Table/;(undef,$meta)=$class->get_table_meta($dbh,$table,1);$meta or croak "No such table '$table'";return$class->get_table_meta_attr($meta,$attr)}sub get_sql_engine_meta {my ($dbh,$table,$attr)=@_;my$gstm=$dbh->{ImplementorClass}->can("get_single_table_meta");$table eq "*" and $table=[".",keys %{$dbh->{sql_meta}}];$table eq "+" and $table=[grep {m/^[_A-Za-z0-9]+$/}keys %{$dbh->{sql_meta}}];ref$table eq "Regexp" and $table=[grep {$_ =~ $table}keys %{$dbh->{sql_meta}}];ref$table || ref$attr or return$gstm->($dbh,$table,$attr);ref$table or $table=[$table];ref$attr or $attr=[$attr];"ARRAY" eq ref$table or return $dbh->set_err($DBI::stderr,"Invalid argument for \$table - SCALAR, Regexp or ARRAY expected but got " .ref$table);"ARRAY" eq ref$attr or return$dbh->set_err("Invalid argument for \$attr - SCALAR or ARRAY expected but got " .ref$attr);my%results;for my$tname (@{$table}){my%tattrs;for my$aname (@{$attr}){$tattrs{$aname}=$gstm->($dbh,$tname,$aname)}$results{$tname}=\%tattrs}return \%results}sub new_sql_engine_meta {my ($dbh,$table,$values)=@_;my$respect_case=0;"HASH" eq ref$values or croak "Invalid argument for \$values - SCALAR or HASH expected but got " .ref$values;$table =~ s/^\"// and $respect_case=1;$table =~ s/\"$//;unless ($respect_case){defined$dbh->{sql_meta_map}{$table}and $table=$dbh->{sql_meta_map}{$table}}$dbh->{sql_meta}{$table}={%{$values}};my$class;defined$values->{sql_table_class}and $class=$values->{sql_table_class};defined$class or ($class=$dbh->{ImplementorClass})=~ s/::db$/::Table/;my (undef,$meta)=$class->get_table_meta($dbh,$table,$respect_case);1}sub set_single_table_meta {my ($dbh,$table,$attr,$value)=@_;my$meta;$table eq "." and return$dbh->STORE($attr,$value);(my$class=$dbh->{ImplementorClass})=~ s/::db$/::Table/;(undef,$meta)=$class->get_table_meta($dbh,$table,1);$meta or croak "No such table '$table'";$class->set_table_meta_attr($meta,$attr,$value);return$dbh}sub set_sql_engine_meta {my ($dbh,$table,$attr,$value)=@_;my$sstm=$dbh->{ImplementorClass}->can("set_single_table_meta");$table eq "*" and $table=[".",keys %{$dbh->{sql_meta}}];$table eq "+" and $table=[grep {m/^[_A-Za-z0-9]+$/}keys %{$dbh->{sql_meta}}];ref($table)eq "Regexp" and $table=[grep {$_ =~ $table}keys %{$dbh->{sql_meta}}];ref$table || ref$attr or return$sstm->($dbh,$table,$attr,$value);ref$table or $table=[$table];ref$attr or $attr={$attr=>$value };"ARRAY" eq ref$table or croak "Invalid argument for \$table - SCALAR, Regexp or ARRAY expected but got " .ref$table;"HASH" eq ref$attr or croak "Invalid argument for \$attr - SCALAR or HASH expected but got " .ref$attr;for my$tname (@{$table}){while (my ($aname,$aval)=each %$attr){$sstm->($dbh,$tname,$aname,$aval)}}return$dbh}sub clear_sql_engine_meta {my ($dbh,$table)=@_;(my$class=$dbh->{ImplementorClass})=~ s/::db$/::Table/;my (undef,$meta)=$class->get_table_meta($dbh,$table,1);$meta and %{$meta}=();return}sub DESTROY ($) {my$dbh=shift;$dbh->SUPER::FETCH("Active")and $dbh->disconnect;undef$dbh->{sql_parser_object}}sub type_info_all ($) {[{TYPE_NAME=>0,DATA_TYPE=>1,PRECISION=>2,LITERAL_PREFIX=>3,LITERAL_SUFFIX=>4,CREATE_PARAMS=>5,NULLABLE=>6,CASE_SENSITIVE=>7,SEARCHABLE=>8,UNSIGNED_ATTRIBUTE=>9,MONEY=>10,AUTO_INCREMENT=>11,LOCAL_TYPE_NAME=>12,MINIMUM_SCALE=>13,MAXIMUM_SCALE=>14,},["VARCHAR",DBI::SQL_VARCHAR(),undef,"'","'",undef,0,1,1,0,0,0,undef,1,999999,],["CHAR",DBI::SQL_CHAR(),undef,"'","'",undef,0,1,1,0,0,0,undef,1,999999,],["INTEGER",DBI::SQL_INTEGER(),undef,"","",undef,0,0,1,0,0,0,undef,0,0,],["REAL",DBI::SQL_REAL(),undef,"","",undef,0,0,1,0,0,0,undef,0,0,],["BLOB",DBI::SQL_LONGVARBINARY(),undef,"'","'",undef,0,1,1,0,0,0,undef,1,999999,],["BLOB",DBI::SQL_LONGVARBINARY(),undef,"'","'",undef,0,1,1,0,0,0,undef,1,999999,],["TEXT",DBI::SQL_LONGVARCHAR(),undef,"'","'",undef,0,1,1,0,0,0,undef,1,999999,],]}sub get_avail_tables {my$dbh=$_[0];my@tables=();if ($dbh->{sql_handler}eq "SQL::Statement" and $dbh->{sql_ram_tables}){for my$table (keys %{$dbh->{sql_ram_tables}}){push@tables,[undef,undef,$table,"TABLE","TEMP" ]}}my$tbl_src;defined$dbh->{sql_table_source}and $dbh->{sql_table_source}->isa('DBI::DBD::SqlEngine::TableSource')and $tbl_src=$dbh->{sql_table_source};!defined($tbl_src)and $dbh->{Driver}->{ImplementorClass}->can('default_table_source')and $tbl_src=$dbh->{Driver}->{ImplementorClass}->default_table_source();defined($tbl_src)and push(@tables,$tbl_src->avail_tables($dbh));return@tables}{my$names=[qw(TABLE_QUALIFIER TABLE_OWNER TABLE_NAME TABLE_TYPE REMARKS)];sub table_info ($) {my$dbh=shift;my@tables=$dbh->func("get_avail_tables");my$dbh2=$dbh->func("sql_sponge_driver");my$sth=$dbh2->prepare("TABLE_INFO",{rows=>\@tables,NAME=>$names,});$sth or return$dbh->set_err($DBI::stderr,$dbh2->errstr);$sth->execute or return;return$sth}}sub list_tables ($) {my$dbh=shift;my@table_list;my@tables=$dbh->func("get_avail_tables")or return;for my$ref (@tables){push@table_list,$ref->[2]}return@table_list}sub quote ($$;$) {my ($self,$str,$type)=@_;defined$str or return "NULL";defined$type && ($type==DBI::SQL_NUMERIC()|| $type==DBI::SQL_DECIMAL()|| $type==DBI::SQL_INTEGER()|| $type==DBI::SQL_SMALLINT()|| $type==DBI::SQL_FLOAT()|| $type==DBI::SQL_REAL()|| $type==DBI::SQL_DOUBLE()|| $type==DBI::SQL_TINYINT())and return$str;$str =~ s/\\/\\\\/sg;$str =~ s/\0/\\0/sg;$str =~ s/\'/\\\'/sg;$str =~ s/\n/\\n/sg;$str =~ s/\r/\\r/sg;return "'$str'"}sub commit ($) {my$dbh=shift;$dbh->FETCH("Warn")and carp "Commit ineffective while AutoCommit is on",-1;return 1}sub rollback ($) {my$dbh=shift;$dbh->FETCH("Warn")and carp "Rollback ineffective while AutoCommit is on",-1;return 0}package DBI::DBD::SqlEngine::TieMeta;use Carp qw(croak);require Tie::Hash;@DBI::DBD::SqlEngine::TieMeta::ISA=qw(Tie::Hash);sub TIEHASH {my ($class,$tblClass,$tblMeta)=@_;my$self=bless({tblClass=>$tblClass,tblMeta=>$tblMeta,},$class);return$self}sub STORE {my ($self,$meta_attr,$meta_val)=@_;$self->{tblClass}->set_table_meta_attr($self->{tblMeta},$meta_attr,$meta_val);return}sub FETCH {my ($self,$meta_attr)=@_;return$self->{tblClass}->get_table_meta_attr($self->{tblMeta},$meta_attr)}sub FIRSTKEY {my$a=scalar keys %{$_[0]->{tblMeta}};each %{$_[0]->{tblMeta}}}sub NEXTKEY {each %{$_[0]->{tblMeta}}}sub EXISTS {exists $_[0]->{tblMeta}{$_[1]}}sub DELETE {croak "Can't delete single attributes from table meta structure"}sub CLEAR {%{$_[0]->{tblMeta}}=()}sub SCALAR {scalar %{$_[0]->{tblMeta}}}package DBI::DBD::SqlEngine::TieTables;use Carp qw(croak);require Tie::Hash;@DBI::DBD::SqlEngine::TieTables::ISA=qw(Tie::Hash);sub TIEHASH {my ($class,$dbh)=@_;(my$tbl_class=$dbh->{ImplementorClass})=~ s/::db$/::Table/;my$self=bless({dbh=>$dbh,tblClass=>$tbl_class,},$class);return$self}sub STORE {my ($self,$table,$tbl_meta)=@_;"HASH" eq ref$tbl_meta or croak "Invalid data for storing as table meta data (must be hash)";(undef,my$meta)=$self->{tblClass}->get_table_meta($self->{dbh},$table,1);$meta or croak "Invalid table name '$table'";while (my ($meta_attr,$meta_val)=each %$tbl_meta){$self->{tblClass}->set_table_meta_attr($meta,$meta_attr,$meta_val)}return}sub FETCH {my ($self,$table)=@_;(undef,my$meta)=$self->{tblClass}->get_table_meta($self->{dbh},$table,1);$meta or croak "Invalid table name '$table'";my%h;tie%h,"DBI::DBD::SqlEngine::TieMeta",$self->{tblClass},$meta;return \%h}sub FIRSTKEY {my$a=scalar keys %{$_[0]->{dbh}->{sql_meta}};each %{$_[0]->{dbh}->{sql_meta}}}sub NEXTKEY {each %{$_[0]->{dbh}->{sql_meta}}}sub EXISTS {exists $_[0]->{dbh}->{sql_meta}->{$_[1]}or exists $_[0]->{dbh}->{sql_meta_map}->{$_[1]}}sub DELETE {my ($self,$table)=@_;(undef,my$meta)=$self->{tblClass}->get_table_meta($self->{dbh},$table,1);$meta or croak "Invalid table name '$table'";delete $_[0]->{dbh}->{sql_meta}->{$meta->{table_name}}}sub CLEAR {%{$_[0]->{dbh}->{sql_meta}}=();%{$_[0]->{dbh}->{sql_meta_map}}=()}sub SCALAR {scalar %{$_[0]->{dbh}->{sql_meta}}}package DBI::DBD::SqlEngine::st;use strict;use warnings;use vars qw(@ISA $imp_data_size);$imp_data_size=0;sub bind_param ($$$;$) {my ($sth,$pNum,$val,$attr)=@_;if ($attr && defined$val){my$type=ref$attr eq "HASH" ? $attr->{TYPE}: $attr;if ($type==DBI::SQL_BIGINT()|| $type==DBI::SQL_INTEGER()|| $type==DBI::SQL_SMALLINT()|| $type==DBI::SQL_TINYINT()){$val += 0}elsif ($type==DBI::SQL_DECIMAL()|| $type==DBI::SQL_DOUBLE()|| $type==DBI::SQL_FLOAT()|| $type==DBI::SQL_NUMERIC()|| $type==DBI::SQL_REAL()){$val += 0.}else {$val="$val"}}$sth->{sql_params}[$pNum - 1 ]=$val;return 1}sub execute {my$sth=shift;my$params=@_ ? ($sth->{sql_params}=[@_]): $sth->{sql_params};$sth->finish;my$stmt=$sth->{sql_stmt};unless ($sth->{sql_params_checked}++){unless ((my$req_prm=$stmt->params())==(my$nparm=@$params)){my$msg="You passed $nparm parameters where $req_prm required";return$sth->set_err($DBI::stderr,$msg)}}my@err;my$result;eval {local$SIG{__WARN__}=sub {push@err,@_};$result=$stmt->execute($sth,$params)};unless (defined$result){$sth->set_err($DBI::stderr,$@ || $stmt->{errstr}|| $err[0]);return}if ($stmt->{NUM_OF_FIELDS}){$sth->STORE(Active=>1);$sth->FETCH("NUM_OF_FIELDS")or $sth->STORE("NUM_OF_FIELDS",$stmt->{NUM_OF_FIELDS})}return$result}sub finish {my$sth=$_[0];$sth->SUPER::STORE(Active=>0);delete$sth->{sql_stmt}{data};return 1}sub fetch ($) {my$sth=$_[0];my$data=$sth->{sql_stmt}{data};if (!$data || ref$data ne "ARRAY"){$sth->set_err($DBI::stderr,"Attempt to fetch row without a preceding execute () call or from a non-SELECT statement");return}my$dav=shift @$data;unless ($dav){$sth->finish;return}if ($sth->FETCH("ChopBlanks")){$_ && $_ =~ s/ +$// for @$dav}return$sth->_set_fbav($dav)}no warnings 'once';*fetchrow_arrayref=\&fetch;use warnings;sub sql_get_colnames {my$sth=$_[0];my@colnames;if ($sth->{sql_stmt}->{NAME}and "ARRAY" eq ref($sth->{sql_stmt}->{NAME})){@colnames=@{$sth->{sql_stmt}->{NAME}}}elsif ($sth->{sql_stmt}->isa('SQL::Statement')){my$stmt=$sth->{sql_stmt}|| {};my@coldefs=@{$stmt->{column_defs}|| []};@colnames=map {$_->{name}|| $_->{value}}@coldefs}@colnames=$sth->{sql_stmt}->column_names()unless (@colnames);@colnames=()if (grep {m/\*/}@colnames);return@colnames}sub FETCH ($$) {my ($sth,$attrib)=@_;$attrib eq "NAME" and return [$sth->sql_get_colnames()];$attrib eq "TYPE" and return [(DBI::SQL_VARCHAR())x scalar$sth->sql_get_colnames()];$attrib eq "TYPE_NAME" and return [("VARCHAR")x scalar$sth->sql_get_colnames()];$attrib eq "PRECISION" and return [(0)x scalar$sth->sql_get_colnames()];$attrib eq "NULLABLE" and return [(1)x scalar$sth->sql_get_colnames()];if ($attrib eq lc$attrib){return$sth->{$attrib}}return$sth->SUPER::FETCH($attrib)}sub STORE ($$$) {my ($sth,$attrib,$value)=@_;if ($attrib eq lc$attrib){$sth->{$attrib}=$value;return 1}return$sth->SUPER::STORE($attrib,$value)}sub DESTROY ($) {my$sth=shift;$sth->SUPER::FETCH("Active")and $sth->finish;undef$sth->{sql_stmt};undef$sth->{sql_params}}sub rows ($) {return $_[0]->{sql_stmt}{NUM_OF_ROWS}}package DBI::DBD::SqlEngine::TableSource;use strict;use warnings;use Carp;sub data_sources ($;$) {my ($class,$drh,$attrs)=@_;croak((ref($_[0])? ref($_[0]): $_[0])." must implement data_sources")}sub avail_tables {my ($self,$dbh)=@_;croak((ref($_[0])? ref($_[0]): $_[0])." must implement avail_tables")}package DBI::DBD::SqlEngine::DataSource;use strict;use warnings;use Carp;sub complete_table_name ($$;$) {my ($self,$meta,$table,$respect_case)=@_;croak((ref($_[0])? ref($_[0]): $_[0])." must implement complete_table_name")}sub open_data ($) {my ($self,$meta,$attrs,$flags)=@_;croak((ref($_[0])? ref($_[0]): $_[0])." must implement open_data")}package DBI::DBD::SqlEngine::Statement;use strict;use warnings;use Carp;@DBI::DBD::SqlEngine::Statement::ISA=qw(DBI::SQL::Nano::Statement);sub open_table ($$$$$) {my ($self,$data,$table,$createMode,$lockMode)=@_;my$class=ref$self;$class =~ s/::Statement/::Table/;my$flags={createMode=>$createMode,lockMode=>$lockMode,};$self->{command}eq "DROP" and $flags->{dropMode}=1;my ($tblnm,$table_meta)=$class->get_table_meta($data->{Database},$table,1)or croak "Cannot find appropriate meta for table '$table'";defined$table_meta->{sql_table_class}and $class=$table_meta->{sql_table_class};my$write_op=$createMode || $lockMode || $flags->{dropMode};if ($write_op){$table_meta->{readonly}and croak "Table '$table' is marked readonly - " .$self->{command}.($lockMode ? " with locking" : "")." command forbidden"}return$class->new($data,{table=>$table },$flags)}package DBI::DBD::SqlEngine::Table;use strict;use warnings;use Carp;@DBI::DBD::SqlEngine::Table::ISA=qw(DBI::SQL::Nano::Table);sub bootstrap_table_meta {my ($self,$dbh,$meta,$table)=@_;defined$dbh->{ReadOnly}and!defined($meta->{readonly})and $meta->{readonly}=$dbh->{ReadOnly};defined$meta->{sql_identifier_case}or $meta->{sql_identifier_case}=$dbh->{sql_identifier_case};exists$meta->{sql_data_source}or $meta->{sql_data_source}=$dbh->{sql_data_source};$meta}sub init_table_meta {my ($self,$dbh,$meta,$table)=@_ if (0);return}sub get_table_meta ($$$;$) {my ($self,$dbh,$table,$respect_case,@other)=@_;unless (defined$respect_case){$respect_case=0;$table =~ s/^\"// and $respect_case=1;$table =~ s/\"$//}unless ($respect_case){defined$dbh->{sql_meta_map}{$table}and $table=$dbh->{sql_meta_map}{$table}}my$meta={};defined$dbh->{sql_meta}{$table}and $meta=$dbh->{sql_meta}{$table};do_initialize: unless ($meta->{initialized}){$self->bootstrap_table_meta($dbh,$meta,$table,@other);$meta->{sql_data_source}->complete_table_name($meta,$table,$respect_case,@other)or return;if (defined$meta->{table_name}and $table ne $meta->{table_name}){$dbh->{sql_meta_map}{$table}=$meta->{table_name};$table=$meta->{table_name}}if (defined$dbh->{sql_meta}{$table}){$meta=delete$dbh->{sql_meta}{$table};$meta->{initialized}or goto do_initialize}unless ($dbh->{sql_meta}{$table}{initialized}){$self->init_table_meta($dbh,$meta,$table);$meta->{initialized}=1;$dbh->{sql_meta}{$table}=$meta}}return ($table,$meta)}my%reset_on_modify=();my%compat_map=();sub register_reset_on_modify {my ($proto,$extra_resets)=@_;for my$cv (keys %$extra_resets){push @{$reset_on_modify{$cv}},ref$extra_resets->{$cv}? @{$extra_resets->{$cv}}: ($extra_resets->{$cv})}return}sub register_compat_map {my ($proto,$extra_compat_map)=@_;%compat_map=(%compat_map,%$extra_compat_map);return}sub get_table_meta_attr {my ($class,$meta,$attrib)=@_;exists$compat_map{$attrib}and $attrib=$compat_map{$attrib};exists$meta->{$attrib}and return$meta->{$attrib};return}sub set_table_meta_attr {my ($class,$meta,$attrib,$value)=@_;exists$compat_map{$attrib}and $attrib=$compat_map{$attrib};$class->table_meta_attr_changed($meta,$attrib,$value);$meta->{$attrib}=$value}sub table_meta_attr_changed {my ($class,$meta,$attrib,$value)=@_;defined$reset_on_modify{$attrib}and delete @$meta{@{$reset_on_modify{$attrib}}}and $meta->{initialized}=0}sub open_data {my ($self,$meta,$attrs,$flags)=@_;$meta->{sql_data_source}or croak "Table " .$meta->{table_name}." not completely initialized";$meta->{sql_data_source}->open_data($meta,$attrs,$flags);return}sub new {my ($className,$data,$attrs,$flags)=@_;my$dbh=$data->{Database};my ($tblnm,$meta)=$className->get_table_meta($dbh,$attrs->{table},1)or croak "Cannot find appropriate table '$attrs->{table}'";$attrs->{table}=$tblnm;$flags->{createMode}&& $data->{sql_stmt}{table_defs}and $meta->{table_defs}=$data->{sql_stmt}{table_defs};$className->open_data($meta,$attrs,$flags);my$tbl={%{$attrs},meta=>$meta,col_names=>$meta->{col_names}|| [],};return$className->SUPER::new($tbl)}sub DESTROY {my$self=shift;my$meta=$self->{meta};$self->{row}and undef$self->{row};()}1;
  sub %s::%s
  {
      my $func = %s->can (q{%s});
      goto &$func;
      }
  EOI
DBI_DBD_SQLENGINE

$fatpacked{"DBI/Gofer/Execute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_GOFER_EXECUTE';
  package DBI::Gofer::Execute;use strict;use warnings;use Carp;use DBI qw(dbi_time);use DBI::Gofer::Request;use DBI::Gofer::Response;use base qw(DBI::Util::_accessor);our$VERSION="0.03";our@all_dbh_methods=sort map {keys %$_}$DBI::DBI_methods{db},$DBI::DBI_methods{common};our%all_dbh_methods=map {$_=>(DBD::_::db->can($_)||undef)}@all_dbh_methods;our$local_log=$ENV{DBI_GOFER_LOCAL_LOG};our$current_dbh;DBI->trace(split /=/,$ENV{DBI_GOFER_TRACE},2)if$ENV{DBI_GOFER_TRACE};my%configuration_attributes=(gofer_execute_class=>1,default_connect_dsn=>1,forced_connect_dsn=>1,default_connect_attributes=>{},forced_connect_attributes=>{},track_recent=>1,check_request_sub=>sub {},check_response_sub=>sub {},forced_single_resultset=>1,max_cached_dbh_per_drh=>1,max_cached_sth_per_dbh=>1,forced_response_attributes=>{},forced_gofer_random=>1,stats=>{},);__PACKAGE__->mk_accessors(keys%configuration_attributes);sub new {my ($self,$args)=@_;$args->{default_connect_attributes}||= {};$args->{forced_connect_attributes}||= {};$args->{max_cached_sth_per_dbh}||= 1000;$args->{stats}||= {};return$self->SUPER::new($args)}sub valid_configuration_attributes {my$self=shift;return {%configuration_attributes }}my%extra_attr=(mysql=>{dbh=>[qw(mysql_errno mysql_error mysql_hostinfo mysql_info mysql_insertid mysql_protoinfo mysql_serverinfo mysql_stat mysql_thread_id)],sth=>[qw(mysql_is_blob mysql_is_key mysql_is_num mysql_is_pri_key mysql_is_auto_increment mysql_length mysql_max_length mysql_table mysql_type mysql_type_name mysql_insertid)],dbh_after_sth=>[qw(mysql_insertid)],},Pg=>{dbh=>[qw(pg_protocol pg_lib_version pg_server_version pg_db pg_host pg_port pg_default_port pg_options pg_pid)],sth=>[qw(pg_size pg_type pg_oid_status pg_cmd_status)],},Sybase=>{dbh=>[qw(syb_dynamic_supported syb_oc_version syb_server_version syb_server_version_string)],sth=>[qw(syb_types syb_proc_status syb_result_type)],},SQLite=>{dbh=>[qw(sqlite_version)],sth=>[qw()],},ExampleP=>{dbh=>[qw(examplep_private_dbh_attrib)],sth=>[qw(examplep_private_sth_attrib)],dbh_after_sth=>[qw(examplep_insertid)],},);sub _connect {my ($self,$request)=@_;my$stats=$self->{stats};if (++$stats->{_requests_served}% 1000==0 and my$max_cached_dbh_per_drh=$self->{max_cached_dbh_per_drh}){my%drivers=DBI->installed_drivers();while (my ($driver,$drh)=each%drivers){next unless my$CK=$drh->{CachedKids};next unless keys %$CK > $max_cached_dbh_per_drh;next if$driver eq 'Gofer';DBI->trace_msg(sprintf "Clearing %d cached dbh from $driver",scalar keys %$CK,$self->{max_cached_dbh_per_drh});$_->{Active}&& $_->disconnect for values %$CK;%$CK=()}}local$ENV{DBI_AUTOPROXY}if$ENV{DBI_AUTOPROXY};my ($connect_method,$dsn,$username,$password,$attr)=@{$request->dbh_connect_call};$connect_method ||= 'connect_cached';$stats->{method_calls_dbh}->{$connect_method}++;delete @{$attr}{qw(Profile InactiveDestroy AutoInactiveDestroy HandleError HandleSetErr TraceLevel Taint TaintIn TaintOut)};$dsn=$self->forced_connect_dsn || $dsn || $self->default_connect_dsn or die "No forced_connect_dsn, requested dsn, or default_connect_dsn for request";my$random=$self->{forced_gofer_random}|| $ENV{DBI_GOFER_RANDOM}|| '';my$connect_attr={%{$self->default_connect_attributes},Username=>$username,Password=>$password,%$attr,PrintWarn=>$local_log,PrintError=>$local_log,%{$self->forced_connect_attributes},RaiseError=>1,Executed=>0,dbi_go_execute_unique=>join("|",__PACKAGE__,$$,$random),};my$dbh=DBI->$connect_method($dsn,undef,undef,$connect_attr);$dbh->{ShowErrorStatement}=1 if$local_log;if (my$random=$self->{forced_gofer_random}|| $ENV{DBI_GOFER_RANDOM}){$self->_install_rand_callbacks($dbh,$random)}my$CK=$dbh->{CachedKids};if ($CK && keys %$CK > $self->{max_cached_sth_per_dbh}){%$CK=()}$current_dbh=$dbh;return$dbh}sub reset_dbh {my ($self,$dbh)=@_;$dbh->set_err(undef,undef)}sub new_response_with_err {my ($self,$rv,$eval_error,$dbh)=@_;my ($err,$errstr,$state)=($DBI::err,$DBI::errstr,$DBI::state);if ($eval_error){$err ||= $DBI::stderr || 1;if ($errstr){$eval_error =~ s/(?: : \s)? \Q$errstr//x if$errstr;chomp$errstr;$errstr .= "; $eval_error"}else {$errstr=$eval_error}}chomp$errstr if$errstr;my$flags;$flags |= GOf_RESPONSE_EXECUTED if$dbh && $dbh->{Executed};my$response=DBI::Gofer::Response->new({rv=>$rv,err=>$err,errstr=>$errstr,state=>$state,flags=>$flags,});return$response}sub execute_request {my ($self,$request)=@_;DBI->trace_msg("-----> execute_request\n");my@warnings;local$SIG{__WARN__}=sub {push@warnings,@_;warn @_ if$local_log};my$response=eval {if (my$check_request_sub=$self->check_request_sub){$request=$check_request_sub->($request,$self)or die "check_request_sub failed"}my$version=$request->version || 0;die ref($request)." version $version is not supported" if$version < 0.009116 or $version >= 1;($request->is_sth_request)? $self->execute_sth_request($request): $self->execute_dbh_request($request)};$response ||= $self->new_response_with_err(undef,$@,$current_dbh);if (my$check_response_sub=$self->check_response_sub){my$new=$check_response_sub->($response,$self,$request);$response=$new if ref$new}undef$current_dbh;$response->warnings(\@warnings)if@warnings;DBI->trace_msg("<----- execute_request\n");return$response}sub execute_dbh_request {my ($self,$request)=@_;my$stats=$self->{stats};my$dbh;my$rv_ref=eval {$dbh=$self->_connect($request);my$args=$request->dbh_method_call;my$wantarray=shift @$args;my$meth=shift @$args;$stats->{method_calls_dbh}->{$meth}++;my@rv=($wantarray)? $dbh->$meth(@$args): scalar$dbh->$meth(@$args);\@rv}|| [];my$response=$self->new_response_with_err($rv_ref,$@,$dbh);return$response if not $dbh;if (my$dbh_attributes=$request->dbh_attributes){$response->dbh_attributes($self->gather_dbh_attributes($dbh,$dbh_attributes))}if ($rv_ref and my$lid_args=$request->dbh_last_insert_id_args){$stats->{method_calls_dbh}->{last_insert_id}++;my$id=$dbh->last_insert_id(@$lid_args);$response->last_insert_id($id)}if ($rv_ref and UNIVERSAL::isa($rv_ref->[0],'DBI::st')){my$sth=$rv_ref->[0];$response->sth_resultsets($self->gather_sth_resultsets($sth,$request,$response));$response->rv("(sth)")}$self->reset_dbh($dbh);return$response}sub gather_dbh_attributes {my ($self,$dbh,$dbh_attributes)=@_;my@req_attr_names=@$dbh_attributes;if ($req_attr_names[0]eq '*'){shift@req_attr_names;push@req_attr_names,@{$self->_std_response_attribute_names($dbh)}}my%dbh_attr_values;@dbh_attr_values{@req_attr_names}=$dbh->FETCH_many(@req_attr_names);$dbh_attr_values{dbi_installed_methods}={DBI->installed_methods };$dbh_attr_values{dbi_default_methods}=_get_default_methods($dbh);return \%dbh_attr_values}sub _std_response_attribute_names {my ($self,$h)=@_;$h=tied(%$h)|| $h;my ($dbh,$h_type,$driver_name,@attr_names);if ($dbh=$h->{Database}){return$dbh->{private_gofer_std_attr_names_sth}if$dbh->{private_gofer_std_attr_names_sth};($h_type,$driver_name)=('sth',$dbh->{Driver}{Name});push@attr_names,qw(NUM_OF_PARAMS NUM_OF_FIELDS NAME TYPE NULLABLE PRECISION SCALE)}else {return$h->{private_gofer_std_attr_names_dbh}if$h->{private_gofer_std_attr_names_dbh};($h_type,$driver_name,$dbh)=('dbh',$h->{Driver}{Name},$h);push@attr_names,qw(ChopBlanks LongReadLen LongTruncOk ReadOnly Name)}if (my$pai=$h->private_attribute_info){push@attr_names,keys %$pai}else {push@attr_names,@{$extra_attr{$driver_name }{$h_type}|| []}}if (my$fra=$self->{forced_response_attributes}){push@attr_names,@{$fra->{$driver_name }{$h_type}|| []}}$dbh->trace_msg("_std_response_attribute_names for $driver_name $h_type: @attr_names\n");return$dbh->{"private_gofer_std_attr_names_$h_type"}=\@attr_names}sub execute_sth_request {my ($self,$request)=@_;my$dbh;my$sth;my$last_insert_id;my$stats=$self->{stats};my$rv=eval {$dbh=$self->_connect($request);my$args=$request->dbh_method_call;shift @$args;my$meth=shift @$args;$stats->{method_calls_sth}->{$meth}++;$sth=$dbh->$meth(@$args);my$last='(sth)';if (my$calls=$request->sth_method_calls){for my$meth_call (@$calls){my$method=shift @$meth_call;$stats->{method_calls_sth}->{$method}++;$last=$sth->$method(@$meth_call)}}if (my$lid_args=$request->dbh_last_insert_id_args){$stats->{method_calls_sth}->{last_insert_id}++;$last_insert_id=$dbh->last_insert_id(@$lid_args)}$last};my$response=$self->new_response_with_err($rv,$@,$dbh);return$response if not $dbh;$response->last_insert_id($last_insert_id)if defined$last_insert_id;if ($sth){$response->sth_resultsets($self->gather_sth_resultsets($sth,$request,$response));$sth->finish}my$dbh_attr_set;if (my$dbh_attributes=$request->dbh_attributes){$dbh_attr_set=$self->gather_dbh_attributes($dbh,$dbh_attributes)}if (my$dbh_attr=$extra_attr{$dbh->{Driver}{Name}}{dbh_after_sth}){@{$dbh_attr_set}{@$dbh_attr}=$dbh->FETCH_many(@$dbh_attr)}$response->dbh_attributes($dbh_attr_set)if$dbh_attr_set && %$dbh_attr_set;$self->reset_dbh($dbh);return$response}sub gather_sth_resultsets {my ($self,$sth,$request,$response)=@_;my$resultsets=eval {my$attr_names=$self->_std_response_attribute_names($sth);my$sth_attr={};$sth_attr->{$_}=1 for @$attr_names;if (my$sth_result_attr=$request->sth_result_attr){$sth_attr->{$_}=$sth_result_attr->{$_}for keys %$sth_result_attr}my@sth_attr=grep {$sth_attr->{$_}}keys %$sth_attr;my$row_count=0;my$rs_list=[];while (1){my$rs=$self->fetch_result_set($sth,\@sth_attr);push @$rs_list,$rs;if (my$rows=$rs->{rowset}){$row_count += @$rows}last if$self->{forced_single_resultset};last if!($sth->more_results || $sth->{syb_more_results})}my$stats=$self->{stats};$stats->{rows_returned_total}+= $row_count;$stats->{rows_returned_max}=$row_count if$row_count > ($stats->{rows_returned_max}||0);$rs_list};$response->add_err(1,$@)if $@;return$resultsets}sub fetch_result_set {my ($self,$sth,$sth_attr)=@_;my%meta;eval {@meta{@$sth_attr }=$sth->FETCH_many(@$sth_attr);$meta{rowset}=$sth->fetchall_arrayref()if (($meta{NUM_OF_FIELDS}||0)> 0)};if ($@){chomp $@;$meta{err}=$DBI::err || 1;$meta{errstr}=$DBI::errstr || $@;$meta{state}=$DBI::state}return \%meta}sub _get_default_methods {my ($dbh)=@_;my$ImplementorClass=$dbh->{ImplementorClass}or die;my%default_methods;for my$method (@all_dbh_methods){my$dbi_sub=$all_dbh_methods{$method}|| 42;my$imp_sub=$ImplementorClass->can($method)|| 42;next if$imp_sub!=$dbi_sub;$default_methods{$method}=1}return \%default_methods}sub _install_rand_callbacks {my ($self,$dbh,$dbi_gofer_random)=@_;my$callbacks=$dbh->{Callbacks}|| {};my$prev=$dbh->{private_gofer_rand_fail_callbacks}|| {};return if (($callbacks->{_dbi_gofer_random_spec}||'')eq $dbi_gofer_random);$callbacks->{_dbi_gofer_random_spec}=$dbi_gofer_random;my ($fail_percent,$fail_err,$delay_percent,$delay_duration,%spec_part,@spec_note);my@specs=split /,/,$dbi_gofer_random;for my$spec (@specs){if ($spec =~ m/^fail=(-?[.\d]+)%?$/){$fail_percent=$1;$spec_part{fail}=$spec;next}if ($spec =~ m/^err=(-?\d+)$/){$fail_err=$1;$spec_part{err}=$spec;next}if ($spec =~ m/^delay([.\d]+)=(-?[.\d]+)%?$/){$delay_duration=$1;$delay_percent=$2;$spec_part{delay}=$spec;next}elsif ($spec !~ m/^(\w+|\*)$/){warn "Ignored DBI_GOFER_RANDOM item '$spec' which isn't a config or a dbh method name";next}my$method=$spec;if ($callbacks->{$method}&& $prev->{$method}&& $callbacks->{$method}!=$prev->{$method}){warn "Callback for $method method already installed so DBI_GOFER_RANDOM callback not installed\n";next}unless (defined$fail_percent or defined$delay_percent){warn "Ignored DBI_GOFER_RANDOM item '$spec' because not preceded by 'fail=N' and/or 'delayN=N'";next}push@spec_note,join(",",values(%spec_part),$method);$callbacks->{$method}=$self->_mk_rand_callback($method,$fail_percent,$delay_percent,$delay_duration,$fail_err)}warn "DBI_GOFER_RANDOM failures/delays enabled: @spec_note\n" if@spec_note;$dbh->{Callbacks}=$callbacks;$dbh->{private_gofer_rand_fail_callbacks}=$callbacks}my%_mk_rand_callback_seqn;sub _mk_rand_callback {my ($self,$method,$fail_percent,$delay_percent,$delay_duration,$fail_err)=@_;my ($fail_modrate,$delay_modrate);$fail_percent ||= 0;$fail_modrate=int(1/(-$fail_percent)*100)if$fail_percent;$delay_percent ||= 0;$delay_modrate=int(1/(-$delay_percent)*100)if$delay_percent;return sub {my ($h)=@_;my$seqn=++$_mk_rand_callback_seqn{$method};my$delay=($delay_percent > 0)? rand(100)< $delay_percent : ($delay_percent < 0)?!($seqn % $delay_modrate): 0;my$fail=($fail_percent > 0)? rand(100)< $fail_percent : ($fail_percent < 0)?!($seqn % $fail_modrate): 0;if ($delay){my$msg="DBI_GOFER_RANDOM delaying execution of $method() by $delay_duration seconds\n";($delay_percent % 2==1)? warn($msg): $h->trace_msg($msg);select undef,undef,undef,$delay_duration}if ($fail){undef $_;return$h->set_err($fail_err || $DBI::stderr,"fake error from $method method induced by DBI_GOFER_RANDOM env var ($fail_percent%)")}return}}sub update_stats {my ($self,$request,$response,$frozen_request,$frozen_response,$time_received,$store_meta,$other_meta,)=@_;carp("No response object provided")unless$request;my$stats=$self->{stats};$stats->{frozen_request_max_bytes}=length($frozen_request)if$frozen_request && length($frozen_request)> ($stats->{frozen_request_max_bytes}||0);$stats->{frozen_response_max_bytes}=length($frozen_response)if$frozen_response && length($frozen_response)> ($stats->{frozen_response_max_bytes}||0);my$recent;if (my$track_recent=$self->{track_recent}){$recent={request=>$frozen_request,response=>$frozen_response,time_received=>$time_received,duration=>dbi_time()-$time_received,($store_meta)? (meta=>$store_meta): (),};$recent->{request_object}=$request if!$frozen_request && $request;$recent->{response_object}=$response if!$frozen_response;my@queues=($stats->{recent_requests}||= []);push@queues,($stats->{recent_errors}||= [])if!$response or $response->err;for my$queue (@queues){push @$queue,$recent;shift @$queue if @$queue > $track_recent}}return$recent}1;
DBI_GOFER_EXECUTE

$fatpacked{"DBI/Gofer/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_GOFER_REQUEST';
  package DBI::Gofer::Request;use strict;use DBI qw(neat neat_list);use base qw(DBI::Util::_accessor);our$VERSION="0.03";use constant GOf_REQUEST_IDEMPOTENT=>0x0001;use constant GOf_REQUEST_READONLY=>0x0002;our@EXPORT=qw(GOf_REQUEST_IDEMPOTENT GOf_REQUEST_READONLY);__PACKAGE__->mk_accessors(qw(version flags dbh_connect_call dbh_method_call dbh_attributes dbh_last_insert_id_args sth_method_calls sth_result_attr));__PACKAGE__->mk_accessors_using(make_accessor_autoviv_hashref=>qw(meta));sub new {my ($self,$args)=@_;$args->{version}||= $VERSION;return$self->SUPER::new($args)}sub reset {my ($self,$flags)=@_;%$self=(version=>$self->{version},dbh_connect_call=>$self->{dbh_connect_call},);$self->{flags}=$flags if$flags}sub init_request {my ($self,$method_and_args,$dbh)=@_;$self->reset($dbh->{ReadOnly}? GOf_REQUEST_READONLY : 0);$self->dbh_method_call($method_and_args)}sub is_sth_request {return shift->{sth_result_attr}}sub statements {my$self=shift;my@statements;if (my$dbh_method_call=$self->dbh_method_call){my$statement_method_regex=qr/^(?:do|prepare)$/;my (undef,$method,$arg1)=@$dbh_method_call;push@statements,$arg1 if$method && $method =~ $statement_method_regex}return@statements}sub is_idempotent {my$self=shift;if (my$flags=$self->flags){return 1 if$flags & (GOf_REQUEST_IDEMPOTENT|GOf_REQUEST_READONLY)}my@statements=$self->statements;return 1 if@statements==grep {m/^ \s* SELECT \b /xmsi &&!m/ \b FOR \s+ UPDATE \b /xmsi}@statements;return 0}sub summary_as_text {my$self=shift;my ($context)=@_;my@s='';if ($context && %$context){my@keys=sort keys %$context;push@s,join(", ",map {"$_=>".$context->{$_}}@keys)}my ($method,$dsn,$user,$pass,$attr)=@{$self->dbh_connect_call};$method ||= 'connect_cached';$pass='***' if defined$pass;my$tmp='';if ($attr){$tmp={%{$attr||{}}};$tmp->{Password}='***' if exists$tmp->{Password};$tmp="{ ".neat_list([%$tmp ])." }"}push@s,sprintf "dbh= $method(%s, %s)",neat_list([$dsn,$user,$pass]),$tmp;if (my$flags=$self->flags){push@s,sprintf "flags: 0x%x",$flags}if (my$dbh_attr=$self->dbh_attributes){push@s,sprintf "dbh->FETCH: %s",@$dbh_attr if @$dbh_attr}my ($wantarray,$meth,@args)=@{$self->dbh_method_call};my$args=neat_list(\@args);$args =~ s/\n+/ /g;push@s,sprintf "dbh->%s(%s)",$meth,$args;if (my$lii_args=$self->dbh_last_insert_id_args){push@s,sprintf "dbh->last_insert_id(%s)",neat_list($lii_args)}for my$call (@{$self->sth_method_calls || []}){my ($meth,@args)=@$call;($args=neat_list(\@args))=~ s/\n+/ /g;push@s,sprintf "sth->%s(%s)",$meth,$args}if (my$sth_attr=$self->sth_result_attr){push@s,sprintf "sth->FETCH: %s",%$sth_attr if %$sth_attr}return join("\n\t",@s)."\n"}sub outline_as_text {my$self=shift;my@s='';my$neatlen=80;if (my$flags=$self->flags){push@s,sprintf "flags=0x%x",$flags}my (undef,$meth,@args)=@{$self->dbh_method_call};push@s,sprintf "%s(%s)",$meth,neat_list(\@args,$neatlen);for my$call (@{$self->sth_method_calls || []}){my ($meth,@args)=@$call;push@s,sprintf "%s(%s)",$meth,neat_list(\@args,$neatlen)}my ($method,$dsn)=@{$self->dbh_connect_call};push@s,"$method($dsn,...)";(my$outline=join("; ",@s))=~ s/\s+/ /g;return$outline}1;
DBI_GOFER_REQUEST

$fatpacked{"DBI/Gofer/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_GOFER_RESPONSE';
  package DBI::Gofer::Response;use strict;use Carp;use DBI qw(neat neat_list);use base qw(DBI::Util::_accessor Exporter);our$VERSION="0.03";use constant GOf_RESPONSE_EXECUTED=>0x0001;our@EXPORT=qw(GOf_RESPONSE_EXECUTED);__PACKAGE__->mk_accessors(qw(version rv err errstr state flags last_insert_id dbh_attributes sth_resultsets warnings));__PACKAGE__->mk_accessors_using(make_accessor_autoviv_hashref=>qw(meta));sub new {my ($self,$args)=@_;$args->{version}||= $VERSION;chomp$args->{errstr}if$args->{errstr};return$self->SUPER::new($args)}sub err_errstr_state {my$self=shift;return @{$self}{qw(err errstr state)}}sub executed_flag_set {my$flags=shift->flags or return 0;return$flags & GOf_RESPONSE_EXECUTED}sub add_err {my ($self,$err,$errstr,$state,$trace)=@_;chomp$errstr if$errstr;$state ||= '';carp ref($self)."->add_err($err, $errstr, $state)" if$trace and defined($err)|| $errstr;my ($r_err,$r_errstr,$r_state)=($self->{err},$self->{errstr},$self->{state});if ($r_errstr){$r_errstr .= sprintf " [err was %s now %s]",$r_err,$err if$r_err && $err && $r_err ne $err;$r_errstr .= sprintf " [state was %s now %s]",$r_state,$state if$r_state and $r_state ne "S1000" && $state && $r_state ne $state;$r_errstr .= "\n$errstr" if$r_errstr ne $errstr}else {$r_errstr=$errstr}my$err_changed;if ($err or!defined$r_err or defined$err && length($err)> length($r_err)){$r_err=$err;++$err_changed}$r_state=($state eq "00000")? "" : $state if$state && $err_changed;($self->{err},$self->{errstr},$self->{state})=($r_err,$r_errstr,$r_state);return undef}sub summary_as_text {my$self=shift;my ($context)=@_;my ($rv,$err,$errstr,$state)=($self->{rv},$self->{err},$self->{errstr},$self->{state});my@s=sprintf("\trv=%s",(ref$rv)? "[".neat_list($rv)."]" : neat($rv));$s[-1].= sprintf(", err=%s, errstr=%s",$err,neat($errstr))if defined$err;$s[-1].= sprintf(",  flags=0x%x",$self->{flags})if defined$self->{flags};push@s,"last_insert_id=%s",$self->last_insert_id if defined$self->last_insert_id;if (my$dbh_attr=$self->dbh_attributes){my@keys=sort keys %$dbh_attr;push@s,sprintf "dbh= { %s }",join(", ",map {"$_=>".neat($dbh_attr->{$_},100)}@keys)if@keys}for my$rs (@{$self->sth_resultsets || []}){my ($rowset,$err,$errstr,$state)=@{$rs}{qw(rowset err errstr state)};my$summary="rowset: ";my$NUM_OF_FIELDS=$rs->{NUM_OF_FIELDS}|| 0;my$rows=$rowset ? @$rowset : 0;if ($rowset || $NUM_OF_FIELDS > 0){$summary .= sprintf "%d rows, %d columns",$rows,$NUM_OF_FIELDS}$summary .= sprintf ", err=%s, errstr=%s",$err,neat($errstr)if defined$err;if ($rows){my$NAME=$rs->{NAME};my@colinfo=map {"$NAME->[$_]=".neat($rowset->[0][$_],30)}0..@{$NAME}-1;$summary .= sprintf " [%s]",join ", ",@colinfo;$summary .= ",..." if$rows > 1;$summary .= " syb_result_type=$rs->{syb_result_type}" if$rs->{syb_result_type}and $rs->{syb_result_type}!=4040}push@s,$summary}for my$w (@{$self->warnings || []}){chomp$w;push@s,"warning: $w"}if ($context && %$context){my@keys=sort keys %$context;push@s,join(", ",map {"$_=>".$context->{$_}}@keys)}return join("\n\t",@s)."\n"}sub outline_as_text {my$self=shift;my ($context)=@_;my ($rv,$err,$errstr,$state)=($self->{rv},$self->{err},$self->{errstr},$self->{state});my$s=sprintf("rv=%s",(ref$rv)? "[".neat_list($rv)."]" : neat($rv));$s .= sprintf(", err=%s %s",$err,neat($errstr))if defined$err;$s .= sprintf(", flags=0x%x",$self->{flags})if$self->{flags};if (my$sth_resultsets=$self->sth_resultsets){$s .= sprintf(", %d resultsets ",scalar @$sth_resultsets);my@rs;for my$rs (@{$self->sth_resultsets || []}){my$summary="";my ($rowset,$err,$errstr)=@{$rs}{qw(rowset err errstr)};my$NUM_OF_FIELDS=$rs->{NUM_OF_FIELDS}|| 0;my$rows=$rowset ? @$rowset : 0;if ($rowset || $NUM_OF_FIELDS > 0){$summary .= sprintf "%dr x %dc",$rows,$NUM_OF_FIELDS}$summary .= sprintf "%serr %s %s",($summary?", ":""),$err,neat($errstr)if defined$err;push@rs,$summary}$s .= join "; ",map {"[$_]"}@rs}return$s}1;
DBI_GOFER_RESPONSE

$fatpacked{"DBI/Gofer/Serializer/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_GOFER_SERIALIZER_BASE';
  package DBI::Gofer::Serializer::Base;use strict;use warnings;use Carp qw(croak);our$VERSION="0.03";sub new {my$class=shift;my$deserializer_class=$class->deserializer_class;return bless {deserializer_class=>$deserializer_class }=>$class}sub deserializer_class {my$self=shift;my$class=ref($self)|| $self;$class =~ s/^DBI::Gofer::Serializer:://;return$class}sub serialize {my$self=shift;croak ref($self)." has not implemented the serialize method"}sub deserialize {my$self=shift;croak ref($self)." has not implemented the deserialize method"}1;
DBI_GOFER_SERIALIZER_BASE

$fatpacked{"DBI/Gofer/Serializer/DataDumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_GOFER_SERIALIZER_DATADUMPER';
  package DBI::Gofer::Serializer::DataDumper;use strict;use warnings;our$VERSION="0.03";use Data::Dumper;use base qw(DBI::Gofer::Serializer::Base);sub serialize {my$self=shift;local$Data::Dumper::Indent=1;local$Data::Dumper::Terse=1;local$Data::Dumper::Useqq=0;local$Data::Dumper::Sortkeys=1;local$Data::Dumper::Quotekeys=0;local$Data::Dumper::Deparse=0;local$Data::Dumper::Purity=0;my$frozen=Data::Dumper::Dumper(shift);return$frozen unless wantarray;return ($frozen,$self->{deserializer_class})}1;
DBI_GOFER_SERIALIZER_DATADUMPER

$fatpacked{"DBI/Gofer/Serializer/Storable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_GOFER_SERIALIZER_STORABLE';
  package DBI::Gofer::Serializer::Storable;use strict;use warnings;use base qw(DBI::Gofer::Serializer::Base);use Storable qw(nfreeze thaw);our$VERSION="0.03";use base qw(DBI::Gofer::Serializer::Base);sub serialize {my$self=shift;local$Storable::forgive_me=1;local$Storable::canonical=1;my$frozen=nfreeze(shift);return$frozen unless wantarray;return ($frozen,$self->{deserializer_class})}sub deserialize {my$self=shift;return thaw(shift)}1;
DBI_GOFER_SERIALIZER_STORABLE

$fatpacked{"DBI/Gofer/Transport/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_GOFER_TRANSPORT_BASE';
  package DBI::Gofer::Transport::Base;use strict;use warnings;use DBI;use base qw(DBI::Util::_accessor);use DBI::Gofer::Serializer::Storable;use DBI::Gofer::Serializer::DataDumper;our$VERSION="0.03";__PACKAGE__->mk_accessors(qw(trace keep_meta_frozen serializer_obj));sub _init_trace {(split(/=/,$ENV{DBI_GOFER_TRACE}||0))[0]}sub new {my ($class,$args)=@_;$args->{trace}||= $class->_init_trace;$args->{serializer_obj}||= DBI::Gofer::Serializer::Storable->new();my$self=bless {},$class;$self->$_($args->{$_})for keys %$args;$self->trace_msg("$class->new({ @{[ %$args ]} })\n")if$self->trace;return$self}my$packet_header_text="GoFER1:";my$packet_header_regex=qr/^GoFER(\d+):/;sub _freeze_data {my ($self,$data,$serializer,$skip_trace)=@_;my$frozen=eval {$self->_dump("freezing $self->{trace} ".ref($data),$data)if!$skip_trace and $self->trace;local$data->{meta};$serializer ||= $self->{serializer_obj};my ($data,$deserializer_class)=$serializer->serialize($data);$packet_header_text .$data};if ($@){chomp $@;die "Error freezing ".ref($data)." object: $@"}$data->{meta}{frozen}=$frozen if$self->keep_meta_frozen;return$frozen}*freeze_request=\&_freeze_data;*freeze_response=\&_freeze_data;sub _thaw_data {my ($self,$frozen_data,$serializer,$skip_trace)=@_;my$data;eval {(my$frozen=$frozen_data)=~ s/$packet_header_regex//o or die "does not have gofer header\n";my ($t_version)=$1;$serializer ||= $self->{serializer_obj};$data=$serializer->deserialize($frozen);die ref($serializer)."->deserialize didn't return a reference" unless ref$data;$data->{_transport}{version}=$t_version;$data->{meta}{frozen}=$frozen_data if$self->keep_meta_frozen};if ($@){chomp(my$err=$@);$err =~ s{ at \S+?/Storable.pm \(autosplit into \S+?/Storable/thaw.al\) line \d+(, \S+ line \d+)?}{};my$msg=sprintf "Error thawing: %s (data=%s)",$err,DBI::neat($frozen_data,50);Carp::cluck("$msg, pid $$ stack trace follows:");die$msg}$self->_dump("thawing $self->{trace} ".ref($data),$data)if!$skip_trace and $self->trace;return$data}*thaw_request=\&_thaw_data;*thaw_response=\&_thaw_data;sub _dump {my ($self,$label,$data)=@_;local$data->{meta}{frozen}if$data->{meta}&& $data->{meta}{frozen};my$trace_level=$self->trace;my$summary;if ($trace_level >= 4){require Data::Dumper;local$Data::Dumper::Indent=1;local$Data::Dumper::Terse=1;local$Data::Dumper::Useqq=0;local$Data::Dumper::Sortkeys=1;local$Data::Dumper::Quotekeys=0;local$Data::Dumper::Deparse=0;local$Data::Dumper::Purity=0;$summary=Data::Dumper::Dumper($data)}elsif ($trace_level >= 2){$summary=eval {$data->summary_as_text}|| $@ || "no summary available\n"}else {$summary=eval {$data->outline_as_text."\n"}|| $@ || "no summary available\n"}$self->trace_msg("$label: $summary")}sub trace_msg {my ($self,$msg,$min_level)=@_;$min_level=1 unless defined$min_level;$min_level=0 if$self->trace >= $min_level;return DBI->trace_msg("gofer ".$msg,$min_level)}1;
DBI_GOFER_TRANSPORT_BASE

$fatpacked{"DBI/Gofer/Transport/pipeone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_GOFER_TRANSPORT_PIPEONE';
  package DBI::Gofer::Transport::pipeone;use strict;use warnings;use DBI::Gofer::Execute;use base qw(DBI::Gofer::Transport::Base Exporter);our$VERSION="0.03";our@EXPORT=qw(run_one_stdio);my$executor=DBI::Gofer::Execute->new();sub run_one_stdio {binmode STDIN;binmode STDOUT;my$transport=DBI::Gofer::Transport::pipeone->new();my$frozen_request=do {local $/;<STDIN>};my$response=$executor->execute_request($transport->thaw_request($frozen_request));my$frozen_response=$transport->freeze_response($response);print$frozen_response}1;
DBI_GOFER_TRANSPORT_PIPEONE

$fatpacked{"DBI/Gofer/Transport/stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_GOFER_TRANSPORT_STREAM';
  package DBI::Gofer::Transport::stream;use strict;use warnings;use DBI qw(dbi_time);use DBI::Gofer::Execute;use base qw(DBI::Gofer::Transport::pipeone Exporter);our$VERSION="0.03";our@EXPORT=qw(run_stdio_hex);my$executor=DBI::Gofer::Execute->new();sub run_stdio_hex {my$transport=DBI::Gofer::Transport::stream->new();local $|=1;DBI->trace_msg("$0 started (pid $$)\n");local $\;local $/="\012";while (defined(my$encoded_request=<STDIN>)){my$time_received=dbi_time();$encoded_request =~ s/\015?\012$//;my$frozen_request=pack "H*",$encoded_request;my$request=$transport->thaw_request($frozen_request);my$response=$executor->execute_request($request);my$frozen_response=$transport->freeze_response($response);my$encoded_response=unpack "H*",$frozen_response;print$encoded_response,"\015\012";$executor->update_stats($request,$response,$frozen_request,$frozen_response,$time_received,1)}DBI->trace_msg("$0 ending (pid $$)\n")}1;
DBI_GOFER_TRANSPORT_STREAM

$fatpacked{"DBI/Profile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_PROFILE';
  package DBI::Profile;use strict;use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);use Exporter ();use UNIVERSAL ();use Carp;use DBI qw(dbi_time dbi_profile dbi_profile_merge_nodes dbi_profile_merge);$VERSION="0.03";@ISA=qw(Exporter);@EXPORT=qw(DBIprofile_Statement DBIprofile_MethodName DBIprofile_MethodClass dbi_profile dbi_profile_merge_nodes dbi_profile_merge dbi_time);@EXPORT_OK=qw(format_profile_thingy);use constant DBIprofile_Statement=>'!Statement';use constant DBIprofile_MethodName=>'!MethodName';use constant DBIprofile_MethodClass=>'!MethodClass';our$ON_DESTROY_DUMP=sub {DBI->trace_msg(shift,0)};our$ON_FLUSH_DUMP=sub {DBI->trace_msg(shift,0)};sub new {my$class=shift;my$profile={@_ };return bless$profile=>$class}sub _auto_new {my$class=shift;my ($arg)=@_;$arg =~ s/^DBI::/2\/DBI::/ and carp "Automatically changed old-style DBI::Profile specification to $arg";my ($path,$package,$args)=split /\//,$arg,3;my@args=(defined$args)? split(/:/,$args,-1): ();my@Path;for my$element (split /:/,$path){if (DBI::looks_like_number($element)){my$reverse=($element < 0)? ($element=-$element,1): 0;my@p;push@p,"DBI" if$element & 0x01;push@p,DBIprofile_Statement if$element & 0x02;push@p,DBIprofile_MethodName if$element & 0x04;push@p,DBIprofile_MethodClass if$element & 0x08;push@p,'!Caller2' if$element & 0x10;push@Path,($reverse ? reverse@p : @p)}elsif ($element =~ m/^&(\w.*)/){my$name="DBI::ProfileSubs::$1";require DBI::ProfileSubs;my$code=do {no strict;*{$name}{CODE}};if (defined$code){push@Path,$code}else {warn "$name: subroutine not found\n";push@Path,$element}}else {push@Path,$element}}eval "require $package" if$package;$package ||= $class;return$package->new(Path=>\@Path,@args)}sub empty {my$self=shift;DBI->trace_msg("profile data discarded\n",0)if$self->{Trace};$self->{Data}=undef}sub filename {return undef}sub flush_to_disk {my$self=shift;return unless$ON_FLUSH_DUMP;return unless$self->{Data};my$detail=$self->format();$ON_FLUSH_DUMP->($detail)if$detail}sub as_node_path_list {my ($self,$node,$path)=@_;$node ||= $self->{Data}or return;$path ||= [];if (ref$node eq 'HASH'){$path=[@$path,undef ];return map {$path->[-1]=$_;($node->{$_})? $self->as_node_path_list($node->{$_},$path): ()}sort keys %$node}return [$node,@$path ]}sub as_text {my ($self,$args_ref)=@_;my$separator=$args_ref->{separator}|| " > ";my$format_path_element=$args_ref->{format_path_element}|| "%s";my$format=$args_ref->{format}|| '%1$s: %11$fs / %10$d = %2$fs avg (first %12$fs, min %13$fs, max %14$fs)'."\n";my@node_path_list=$self->as_node_path_list(undef,$args_ref->{path});$args_ref->{sortsub}->(\@node_path_list)if$args_ref->{sortsub};my$eval="qr/".quotemeta($separator)."/";my$separator_re=eval($eval)|| quotemeta($separator);my@text;my@spare_slots=(undef)x 7;for my$node_path (@node_path_list){my ($node,@path)=@$node_path;my$idx=0;for (@path){s/[\r\n]+/ /g;s/$separator_re/ /g;++$idx;if ($format_path_element eq "%s"){$_=sprintf$format_path_element,$_}else {$_=sprintf$format_path_element,$_,$idx}}push@text,sprintf$format,join($separator,@path),($node->[0]? $node->[1]/$node->[0]: 0),@spare_slots,@$node}return@text if wantarray;return join "",@text}sub format {my$self=shift;my$class=ref($self)|| $self;my$prologue="$class: ";my$detail=$self->format_profile_thingy($self->{Data},0,"    ",my$path=[],my$leaves=[],)."\n";if (@$leaves){dbi_profile_merge_nodes(my$totals=[],@$leaves);my ($count,$time_in_dbi,undef,undef,undef,$t1,$t2)=@$totals;(my$progname=$0)=~ s:.*/::;if ($count){$prologue .= sprintf "%fs ",$time_in_dbi;my$perl_time=($DBI::PERL_ENDING)? time()- $^T : $t2-$t1;$prologue .= sprintf "%.2f%% ",$time_in_dbi/$perl_time*100 if$perl_time;my@lt=localtime(time);my$ts=sprintf "%d-%02d-%02d %02d:%02d:%02d",1900+$lt[5],$lt[4]+1,@lt[3,2,1,0];$prologue .= sprintf "(%d calls) $progname \@ $ts\n",$count}if (@$leaves==1 && ref($self->{Data})eq 'HASH' && $self->{Data}->{DBI}){$detail=""}}return ($prologue,$detail)if wantarray;return$prologue.$detail}sub format_profile_leaf {my ($self,$thingy,$depth,$pad,$path,$leaves)=@_;croak "format_profile_leaf called on non-leaf ($thingy)" unless UNIVERSAL::isa($thingy,'ARRAY');push @$leaves,$thingy if$leaves;my ($count,$total_time,$first_time,$min,$max,$first_called,$last_called)=@$thingy;return sprintf "%s%fs\n",($pad x $depth),$total_time if$count <= 1;return sprintf "%s%fs / %d = %fs avg (first %fs, min %fs, max %fs)\n",($pad x $depth),$total_time,$count,$count ? $total_time/$count : 0,$first_time,$min,$max}sub format_profile_branch {my ($self,$thingy,$depth,$pad,$path,$leaves)=@_;croak "format_profile_branch called on non-branch ($thingy)" unless UNIVERSAL::isa($thingy,'HASH');my@chunk;my@keys=sort keys %$thingy;while (@keys){my$k=shift@keys;my$v=$thingy->{$k};push @$path,$k;push@chunk,sprintf "%s'%s' =>\n%s",($pad x $depth),$k,$self->format_profile_thingy($v,$depth+1,$pad,$path,$leaves);pop @$path}return join "",@chunk}sub format_profile_thingy {my ($self,$thingy,$depth,$pad,$path,$leaves)=@_;return "undef" if not defined$thingy;return$self->format_profile_leaf($thingy,$depth,$pad,$path,$leaves)if UNIVERSAL::isa($thingy,'ARRAY');return$self->format_profile_branch($thingy,$depth,$pad,$path,$leaves)if UNIVERSAL::isa($thingy,'HASH');return "$thingy\n"}sub on_destroy {my$self=shift;return unless$ON_DESTROY_DUMP;return unless$self->{Data};my$detail=$self->format();$ON_DESTROY_DUMP->($detail)if$detail;$self->{Data}=undef}sub DESTROY {my$self=shift;local $@;DBI->trace_msg("profile data DESTROY\n",0)if (($self->{Trace}||0)>= 2);eval {$self->on_destroy};if ($@){chomp $@;my$class=ref($self)|| $self;DBI->trace_msg("$class on_destroy failed: $@",0)}}1;
DBI_PROFILE

$fatpacked{"DBI/ProfileData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_PROFILEDATA';
  package DBI::ProfileData;use strict;our$VERSION="0.03";use Carp qw(croak);use Symbol;use Fcntl qw(:flock);use DBI::Profile qw(dbi_profile_merge);sub COUNT () {0};sub TOTAL () {1};sub FIRST () {2};sub SHORTEST () {3};sub LONGEST () {4};sub FIRST_AT () {5};sub LAST_AT () {6};sub PATH () {7};my$HAS_FLOCK=(defined$ENV{DBI_PROFILE_FLOCK})? $ENV{DBI_PROFILE_FLOCK}: do {local $@;eval {flock STDOUT,0;1}};sub new {my$pkg=shift;my$self={Files=>["dbi.prof" ],Filter=>undef,DeleteFiles=>0,LockFile=>$HAS_FLOCK,_header=>{},_nodes=>[],_node_lookup=>{},_sort=>'none',@_ };bless$self,$pkg;$self->{Files}=[$self->{File}]if exists$self->{File};$self->_read_files();return$self}sub _read_files {my$self=shift;my$files=$self->{Files};my$read_header=0;my@files_to_delete;my$fh=gensym;for (@$files){my$filename=$_;if ($self->{DeleteFiles}){my$newfilename=$filename .".deleteme";if ($^O eq 'VMS'){$newfilename=$filename .'deleteme'}rename($filename,$newfilename)or croak "Can't rename($filename, $newfilename): $!";1 while (unlink$filename);$filename=$newfilename}open($fh,"<",$filename)or croak("Unable to read profile file '$filename': $!");flock($fh,LOCK_SH)if$self->{LockFile};if (-s $fh){$self->_read_header($fh,$filename,$read_header ? 0 : 1);$read_header=1;$self->_read_body($fh,$filename)}close($fh);push@files_to_delete,$filename if$self->{DeleteFiles}}for (@files_to_delete){1 while (unlink $_);if(-e $_){warn "Can't delete '$_': $!"}}delete$self->{_node_lookup}}sub _read_header {my ($self,$fh,$filename,$keep)=@_;my$first=<$fh>;chomp$first;$self->{_profiler}=$first if$keep;local $_;while (<$fh>){chomp;last unless length $_;/^(\S+)\s*=\s*(.*)/ or croak("Syntax error in header in $filename line $.: $_");$self->{_header}{$1}=unescape_key($2)if$keep}}sub unescape_key {local $_=shift;s/(?<!\\)\\n/\n/g;s/(?<!\\)\\r/\r/g;s/\\\\/\\/g;return $_}sub _read_body {my ($self,$fh,$filename)=@_;my$nodes=$self->{_nodes};my$lookup=$self->{_node_lookup};my$filter=$self->{Filter};my@path=("");my (@data,$path_key);local $_;while (<$fh>){chomp;if (/^\+\s+(\d+)\s?(.*)/){my ($key,$index)=($2,$1 - 1);$#path=$index;$path[$index]=unescape_key($key)}elsif (s/^=\s+//){@data=split / /,$_;croak("Invalid number of fields in $filename line $.: $_")unless@data==7;croak("Invalid leaf node characters $filename line $.: $_")unless m/^[-+ 0-9eE\.]+$/;$filter->(\@path,\@data)if$filter;$path_key=join("\0",@path);if (exists$lookup->{$path_key}){dbi_profile_merge($nodes->[$lookup->{$path_key}],\@data)}else {push(@$nodes,[@data,@path ]);$lookup->{$path_key}=$#$nodes}}else {croak("Invalid line type syntax error in $filename line $.: $_")}}}sub clone {my$self=shift;my$clone=bless {%$self },ref($self);$clone->{_nodes}=[map {[@$_ ]}@{$self->{_nodes}}];$clone->{_header}={%{$self->{_header}}};return$clone}sub header {shift->{_header}}sub nodes {shift->{_nodes}}sub count {scalar @{shift->{_nodes}}}{my%FIELDS=(longest=>LONGEST,total=>TOTAL,count=>COUNT,shortest=>SHORTEST,key1=>PATH+0,key2=>PATH+1,key3=>PATH+2,);sub sort {my$self=shift;my$nodes=$self->{_nodes};my%opt=@_;croak("Missing required field option.")unless$opt{field};my$index=$FIELDS{$opt{field}};croak("Unrecognized sort field '$opt{field}'.")unless defined$index;if ($opt{reverse}){@$nodes=sort {$a->[$index]<=> $b->[$index]}@$nodes}else {@$nodes=sort {$b->[$index]<=> $a->[$index]}@$nodes}$self->{_sort}=$opt{field};return$self}}sub exclude {my$self=shift;my$nodes=$self->{_nodes};my%opt=@_;my ($index,$val);for (keys%opt){if (/^key(\d+)$/){$index=PATH + $1 - 1;$val=$opt{$_};last}}croak("Missing required keyN option.")unless$index;if (UNIVERSAL::isa($val,"Regexp")){@$nodes=grep {$#$_ < $index or $_->[$index]!~ /$val/}@$nodes}else {if ($opt{case_sensitive}){@$nodes=grep {$#$_ < $index or $_->[$index]ne $val}@$nodes}else {$val=lc$val;@$nodes=grep {$#$_ < $index or lc($_->[$index])ne $val}@$nodes}}return scalar @$nodes}sub match {my$self=shift;my$nodes=$self->{_nodes};my%opt=@_;my ($index,$val);for (keys%opt){if (/^key(\d+)$/){$index=PATH + $1 - 1;$val=$opt{$_};last}}croak("Missing required keyN option.")unless$index;if (UNIVERSAL::isa($val,"Regexp")){@$nodes=grep {$#$_ >= $index and $_->[$index]=~ /$val/}@$nodes}else {if ($opt{case_sensitive}){@$nodes=grep {$#$_ >= $index and $_->[$index]eq $val}@$nodes}else {$val=lc$val;@$nodes=grep {$#$_ >= $index and lc($_->[$index])eq $val}@$nodes}}return scalar @$nodes}sub Data {my$self=shift;my (%Data,@data,$ptr);for my$node (@{$self->{_nodes}}){$ptr=\%Data;for my$key (@{$node}[PATH .. $#$node - 1]){$ptr->{$key}={}unless exists$ptr->{$key};$ptr=$ptr->{$key}}$ptr->{$node->[-1]}=[@{$node}[0 .. 6]]}return \%Data}sub format {my ($self,$node)=@_;my$format;my$keys="";for (my$i=PATH;$i <= $#$node;$i++){my$key=$node->[$i];$key =~ s/^\s+//;$key =~ s/\s+$//;if (length($key)> 72 or $key =~ /\n/){$keys .= "  Key " .($i - PATH + 1)."         :\n\n$key\n\n"}else {$keys .= "  Key " .($i - PATH + 1)."         : $key\n"}}if ($node->[COUNT]> 1){$format=<<END;return sprintf($format,@{$node}[COUNT,TOTAL,LONGEST,SHORTEST],$node->[TOTAL]/ $node->[COUNT]).$keys}else {$format=<<END;return sprintf($format,@{$node}[COUNT,TOTAL]).$keys}}sub report {my$self=shift;my$nodes=$self->{_nodes};my%opt=@_;croak("Missing required number option")unless exists$opt{number};$opt{number}=@$nodes if @$nodes < $opt{number};my$report=$self->_report_header($opt{number});for (0 .. $opt{number}- 1){$report .= sprintf("#" x 5 ."[ %d ]"."#" x 59 ."\n",$_ + 1);$report .= $self->format($nodes->[$_]);$report .= "\n"}return$report}sub _report_header {my ($self,$number)=@_;my$nodes=$self->{_nodes};my$node_count=@$nodes;my ($time,$count)=(0,0);for my$node (@$nodes){$time += $node->[TOTAL];$count += $node->[COUNT]}my$header=<<END;while (my ($key,$value)=each %{$self->{_header}}){$header .= sprintf("  %-13s : %s\n",$key,$value)}$header .= sprintf(<<END,$node_count,$number,$self->{_sort},$count,$time);return$header}1;
    Count         : %d
    Total Time    : %3.6f seconds
    Longest Time  : %3.6f seconds
    Shortest Time : %3.6f seconds
    Average Time  : %3.6f seconds
  END
    Count         : %d
    Time          : %3.6f seconds
  END
  
  DBI Profile Data ($self->{_profiler})
  
  END
    Total Records : %d (showing %d, sorted by %s)
    Total Count   : %d
    Total Runtime : %3.6f seconds
  
  END
DBI_PROFILEDATA

$fatpacked{"DBI/ProfileDumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_PROFILEDUMPER';
  package DBI::ProfileDumper;use strict;use DBI::Profile;our@ISA=("DBI::Profile");our$VERSION="0.03";use Carp qw(croak);use Fcntl qw(:flock);use Symbol;my$HAS_FLOCK=(defined$ENV{DBI_PROFILE_FLOCK})? $ENV{DBI_PROFILE_FLOCK}: do {local $@;eval {flock STDOUT,0;1}};my$program_header;sub new {my$pkg=shift;my$self=$pkg->SUPER::new(LockFile=>$HAS_FLOCK,@_,);$self->filename("dbi.prof")unless$self->filename;DBI->trace_msg("$self: @{[ %$self ]}\n",0)if$self->{Trace}&& $self->{Trace}>= 2;return$self}sub filename {my$self=shift;$self->{File}=shift if @_;my$filename=$self->{File};$filename=$filename->($self)if ref($filename)eq 'CODE';return$filename}sub flush_to_disk {my$self=shift;my$class=ref$self;my$filename=$self->filename;my$data=$self->{Data};if (1){if (not $data or ref$data eq 'HASH' &&!%$data){DBI->trace_msg("flush_to_disk skipped for empty profile\n",0)if$self->{Trace};return undef}}my$fh=gensym;if (($self->{_wrote_header}||'')eq $filename){open($fh,">>",$filename)or croak("Unable to open '$filename' for $class output: $!")}else {if (-f $filename){my$bak=$filename.'.prev';unlink($bak);rename($filename,$bak)or warn "Error renaming $filename to $bak: $!\n"}open($fh,">",$filename)or croak("Unable to open '$filename' for $class output: $!")}flock($fh,LOCK_EX)if$self->{LockFile};if (-s $fh==0){DBI->trace_msg("flush_to_disk wrote header to $filename\n",0)if$self->{Trace};$self->write_header($fh);$self->{_wrote_header}=$filename}my$lines=$self->write_data($fh,$self->{Data},1);DBI->trace_msg("flush_to_disk wrote $lines lines to $filename\n",0)if$self->{Trace};close($fh)or croak("Error closing '$filename': $!");$self->empty();return$filename}sub write_header {my ($self,$fh)=@_;local($\,$,);my$version=$self->VERSION || $VERSION;print$fh ref($self)." $version\n";my@path_words=map {escape_key($_)}@{$self->{Path}|| []};print$fh "Path = [ ",join(', ',@path_words)," ]\n";if (!$program_header){$program_header="Program = " .join(" ",map {escape_key($_)}$0,@ARGV)."\n"}print$fh $program_header;print$fh "\n"}sub write_data {my ($self,$fh,$data,$level)=@_;return 0 unless$data and UNIVERSAL::isa($data,'HASH');local ($\,$,);my$lines=0;while (my ($key,$value)=each(%$data)){print$fh "+ $level ".escape_key($key)."\n";if (UNIVERSAL::isa($value,'ARRAY')){print$fh "= ".join(' ',@$value)."\n";$lines += 1}else {$lines += $self->write_data($fh,$value,$level + 1)}}return$lines}sub escape_key {my$key=shift;$key =~ s!\\!\\\\!g;$key =~ s!\n!\\n!g;$key =~ s!\r!\\r!g;$key =~ s!\0!!g;return$key}sub on_destroy {shift->flush_to_disk()}1;
DBI_PROFILEDUMPER

$fatpacked{"DBI/ProfileDumper/Apache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_PROFILEDUMPER_APACHE';
  package DBI::ProfileDumper::Apache;use strict;our$VERSION="0.03";our@ISA=qw(DBI::ProfileDumper);use DBI::ProfileDumper;use File::Spec;my$initial_pid=$$;use constant MP2=>($ENV{MOD_PERL_API_VERSION}and $ENV{MOD_PERL_API_VERSION}==2)? 1 : 0;my$server_root_dir;if (MP2){require Apache2::ServerUtil;$server_root_dir=Apache2::ServerUtil::server_root()}else {require Apache;$server_root_dir=eval {Apache->server_root_relative('')}|| "/tmp"}sub _dirname {my$self=shift;return$self->{Dir}||= $ENV{DBI_PROFILE_APACHE_LOG_DIR}|| File::Spec->catdir($server_root_dir,"logs")}sub filename {my$self=shift;my$filename=$self->SUPER::filename(@_);return$filename if not $filename;my$group_pid=($$ eq $initial_pid)? $$ : getppid();$filename .= ".$group_pid.$$";return$filename if File::Spec->file_name_is_absolute($filename);return File::Spec->catfile($self->_dirname,$filename)}sub flush_to_disk {my$self=shift;my$filename=$self->SUPER::flush_to_disk(@_);print STDERR ref($self)." pid$$ written to $filename\n" if$filename && not $self->{Quiet};return$filename}1;
DBI_PROFILEDUMPER_APACHE

$fatpacked{"DBI/ProfileSubs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_PROFILESUBS';
  package DBI::ProfileSubs;our$VERSION="0.03";use strict;use warnings;sub norm_std_n3 {local $_=$_;s/\b\d+\b/<N>/g;s/\b0x[0-9A-Fa-f]+\b/<N>/g;s/'.*?'/'<S>'/g;s/".*?"/"<S>"/g;s/([a-z_]+)(\d{3,})\b/${1}<N>/ig;s!((\s*<[NS]>\s*,\s*){100,})!sprintf("$2,<repeated %d times>",length($1)/2)!eg;return $_}1;
DBI_PROFILESUBS

$fatpacked{"DBI/ProxyServer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_PROXYSERVER';
  require 5.004;use strict;use RPC::PlServer 0.2001;require DBI;require Config;package DBI::ProxyServer;use vars qw($VERSION @ISA);$VERSION="0.03";@ISA=qw(RPC::PlServer DBI);my%DEFAULT_SERVER_OPTIONS;{my$o=\%DEFAULT_SERVER_OPTIONS;$o->{'chroot'}=undef,$o->{'clients'}=[{'mask'=>'.*','accept'=>1,'cipher'=>undef }];$o->{'configfile'}='/etc/dbiproxy.conf' if -f '/etc/dbiproxy.conf';$o->{'debug'}=0;$o->{'facility'}='daemon';$o->{'group'}=undef;$o->{'localaddr'}=undef;$o->{'localport'}=undef;$o->{'logfile'}=undef;$o->{'XXX_methods'}={'DBI::ProxyServer'=>{'Version'=>1,'NewHandle'=>1,'CallMethod'=>1,'DestroyHandle'=>1 },'DBI::ProxyServer::db'=>{'prepare'=>1,'commit'=>1,'rollback'=>1,'STORE'=>1,'FETCH'=>1,'func'=>1,'quote'=>1,'type_info_all'=>1,'table_info'=>1,'disconnect'=>1,},'DBI::ProxyServer::st'=>{'execute'=>1,'STORE'=>1,'FETCH'=>1,'func'=>1,'fetch'=>1,'finish'=>1 }};if ($Config::Config{'usethreads'}eq 'define'){$o->{'mode'}='threads'}elsif ($Config::Config{'d_fork'}eq 'define'){$o->{'mode'}='fork'}else {$o->{'mode'}='single'}$o->{'pidfile'}='none';$o->{'user'}=undef};sub Version {my$version=$DBI::ProxyServer::VERSION;"DBI::ProxyServer $version, Copyright (C) 1998, Jochen Wiedmann"}sub AcceptApplication {my$self=shift;my$dsn=shift;$dsn =~ /^dbi:\w+:/i}sub AcceptVersion {my$self=shift;my$version=shift;require DBI;DBI::ProxyServer->init_rootclass();$DBI::VERSION >= $version}sub AcceptUser {my$self=shift;my$user=shift;my$password=shift;return 0 if (!$self->SUPER::AcceptUser($user,$password));my$dsn=$self->{'application'};$self->Debug("Connecting to $dsn as $user");local$ENV{DBI_AUTOPROXY}='';$self->{'dbh'}=eval {DBI::ProxyServer->connect($dsn,$user,$password,{'PrintError'=>0,'Warn'=>0,'RaiseError'=>1,'HandleError'=>sub {my$err=$_[1]->err;my$state=$_[1]->state || '';$_[0].= " [err=$err,state=$state]";return 0}})};if ($@){$self->Error("Error while connecting to $dsn as $user: $@");return 0}[1,$self->StoreHandle($self->{'dbh'})]}sub CallMethod {my$server=shift;my$dbh=$server->{'dbh'};$dbh->{'private_server'}=$server;$server->Debug("CallMethod: => " .do {local $^W;join(",",@_)});my@result=eval {$server->SUPER::CallMethod(@_)};my$msg=$@;undef$dbh->{'private_server'};if ($msg){$server->Debug("CallMethod died with: $@");die$msg}else {$server->Debug("CallMethod: <= " .do {local $^W;join(",",@result)})}@result}sub main {my$server=DBI::ProxyServer->new(\%DEFAULT_SERVER_OPTIONS,\@_);$server->Bind()}package DBI::ProxyServer::dr;@DBI::ProxyServer::dr::ISA=qw(DBI::dr);package DBI::ProxyServer::db;@DBI::ProxyServer::db::ISA=qw(DBI::db);sub prepare {my($dbh,$statement,$attr,$params,$proto_ver)=@_;my$server=$dbh->{'private_server'};if (my$client=$server->{'client'}){if ($client->{'sql'}){if ($statement =~ /^\s*(\S+)/){my$st=$1;if (!($statement=$client->{'sql'}->{$st})){die "Unknown SQL query: $st"}}else {die "Cannot parse restricted SQL statement: $statement"}}}my$sth=$dbh->SUPER::prepare($statement,$attr);my$handle=$server->StoreHandle($sth);if ($proto_ver and $proto_ver > 1){$sth->{private_proxyserver_described}=0;return$handle}else {my@result=$sth->execute($params);my ($NAME,$TYPE);my$NUM_OF_FIELDS=$sth->{NUM_OF_FIELDS};if ($NUM_OF_FIELDS){$NAME=$sth->{NAME};$TYPE=$sth->{TYPE}}($handle,$NUM_OF_FIELDS,$sth->{'NUM_OF_PARAMS'},$NAME,$TYPE,@result)}}sub table_info {my$dbh=shift;my$sth=$dbh->SUPER::table_info();my$numFields=$sth->{'NUM_OF_FIELDS'};my$names=$sth->{'NAME'};my$types=$sth->{'TYPE'};my@rows;while (my ($row)=$sth->fetch()){last unless defined$row;push(@rows,[@$row])}($numFields,$names,$types,@rows)}package DBI::ProxyServer::st;@DBI::ProxyServer::st::ISA=qw(DBI::st);sub execute {my$sth=shift;my$params=shift;my$proto_ver=shift;my@outParams;if ($params){for (my$i=0;$i < @$params;){my$param=$params->[$i++];if (!ref($param)){$sth->bind_param($i,$param)}else {if (!ref(@$param[0])){$sth->bind_param($i,@$param)}else {$sth->bind_param_inout($i,@$param);my$ref=shift @$param;push(@outParams,$ref)}}}}my$rows=$sth->SUPER::execute();if ($proto_ver and $proto_ver > 1 and not $sth->{private_proxyserver_described}){my ($NAME,$TYPE);my$NUM_OF_FIELDS=$sth->{NUM_OF_FIELDS};if ($NUM_OF_FIELDS){$NAME=$sth->{NAME};$TYPE=$sth->{TYPE}}$sth->{private_proxyserver_described}=1;return ($rows,$NUM_OF_FIELDS,$sth->{'NUM_OF_PARAMS'},$NAME,$TYPE,@outParams)}($rows,@outParams)}sub fetch {my$sth=shift;my$numRows=shift || 1;my($ref,@rows);while ($numRows-- && ($ref=$sth->SUPER::fetch())){push(@rows,[@$ref])}@rows}1;
DBI_PROXYSERVER

$fatpacked{"DBI/PurePerl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_PUREPERL';
  package DBI;use strict;use Carp;require Symbol;require utf8;*utf8::is_utf8=sub {require bytes;return unless defined $_[0];return!(length($_[0])==bytes::length($_[0]))}unless defined&utf8::is_utf8;$DBI::PurePerl=$ENV{DBI_PUREPERL}|| 1;$DBI::PurePerl::VERSION="0.03";$DBI::neat_maxlen ||= 400;$DBI::tfh=Symbol::gensym();open$DBI::tfh,">&STDERR" or warn "Can't dup STDERR: $!";select((select($DBI::tfh),$|=1)[0]);my$HAS_WEAKEN=eval {require Scalar::Util;Scalar::Util::weaken(my$test=[]);1};%DBI::last_method_except=map {$_=>1}qw(DESTROY _set_fbav set_err);use constant SQL_ALL_TYPES=>0;use constant SQL_ARRAY=>50;use constant SQL_ARRAY_LOCATOR=>51;use constant SQL_BIGINT=>(-5);use constant SQL_BINARY=>(-2);use constant SQL_BIT=>(-7);use constant SQL_BLOB=>30;use constant SQL_BLOB_LOCATOR=>31;use constant SQL_BOOLEAN=>16;use constant SQL_CHAR=>1;use constant SQL_CLOB=>40;use constant SQL_CLOB_LOCATOR=>41;use constant SQL_DATE=>9;use constant SQL_DATETIME=>9;use constant SQL_DECIMAL=>3;use constant SQL_DOUBLE=>8;use constant SQL_FLOAT=>6;use constant SQL_GUID=>(-11);use constant SQL_INTEGER=>4;use constant SQL_INTERVAL=>10;use constant SQL_INTERVAL_DAY=>103;use constant SQL_INTERVAL_DAY_TO_HOUR=>108;use constant SQL_INTERVAL_DAY_TO_MINUTE=>109;use constant SQL_INTERVAL_DAY_TO_SECOND=>110;use constant SQL_INTERVAL_HOUR=>104;use constant SQL_INTERVAL_HOUR_TO_MINUTE=>111;use constant SQL_INTERVAL_HOUR_TO_SECOND=>112;use constant SQL_INTERVAL_MINUTE=>105;use constant SQL_INTERVAL_MINUTE_TO_SECOND=>113;use constant SQL_INTERVAL_MONTH=>102;use constant SQL_INTERVAL_SECOND=>106;use constant SQL_INTERVAL_YEAR=>101;use constant SQL_INTERVAL_YEAR_TO_MONTH=>107;use constant SQL_LONGVARBINARY=>(-4);use constant SQL_LONGVARCHAR=>(-1);use constant SQL_MULTISET=>55;use constant SQL_MULTISET_LOCATOR=>56;use constant SQL_NUMERIC=>2;use constant SQL_REAL=>7;use constant SQL_REF=>20;use constant SQL_ROW=>19;use constant SQL_SMALLINT=>5;use constant SQL_TIME=>10;use constant SQL_TIMESTAMP=>11;use constant SQL_TINYINT=>(-6);use constant SQL_TYPE_DATE=>91;use constant SQL_TYPE_TIME=>92;use constant SQL_TYPE_TIMESTAMP=>93;use constant SQL_TYPE_TIMESTAMP_WITH_TIMEZONE=>95;use constant SQL_TYPE_TIME_WITH_TIMEZONE=>94;use constant SQL_UDT=>17;use constant SQL_UDT_LOCATOR=>18;use constant SQL_UNKNOWN_TYPE=>0;use constant SQL_VARBINARY=>(-3);use constant SQL_VARCHAR=>12;use constant SQL_WCHAR=>(-8);use constant SQL_WLONGVARCHAR=>(-10);use constant SQL_WVARCHAR=>(-9);use constant SQL_CURSOR_FORWARD_ONLY=>0;use constant SQL_CURSOR_KEYSET_DRIVEN=>1;use constant SQL_CURSOR_DYNAMIC=>2;use constant SQL_CURSOR_STATIC=>3;use constant SQL_CURSOR_TYPE_DEFAULT=>SQL_CURSOR_FORWARD_ONLY;use constant IMA_HAS_USAGE=>0x0001;use constant IMA_FUNC_REDIRECT=>0x0002;use constant IMA_KEEP_ERR=>0x0004;use constant IMA_KEEP_ERR_SUB=>0x0008;use constant IMA_NO_TAINT_IN=>0x0010;use constant IMA_NO_TAINT_OUT=>0x0020;use constant IMA_COPY_UP_STMT=>0x0040;use constant IMA_END_WORK=>0x0080;use constant IMA_STUB=>0x0100;use constant IMA_CLEAR_STMT=>0x0200;use constant IMA_UNRELATED_TO_STMT=>0x0400;use constant IMA_NOT_FOUND_OKAY=>0x0800;use constant IMA_EXECUTE=>0x1000;use constant IMA_SHOW_ERR_STMT=>0x2000;use constant IMA_HIDE_ERR_PARAMVALUES=>0x4000;use constant IMA_IS_FACTORY=>0x8000;use constant IMA_CLEAR_CACHED_KIDS=>0x10000;use constant DBIstcf_STRICT=>0x0001;use constant DBIstcf_DISCARD_STRING=>0x0002;my%is_flag_attribute=map {$_=>1}qw(Active AutoCommit ChopBlanks CompatMode Executed Taint TaintIn TaintOut InactiveDestroy AutoInactiveDestroy LongTruncOk MultiThread PrintError PrintWarn RaiseError ShowErrorStatement Warn);my%is_valid_attribute=map {$_=>1}(keys%is_flag_attribute,qw(ActiveKids Attribution BegunWork CachedKids Callbacks ChildHandles CursorName Database DebugDispatch Driver Err Errstr ErrCount FetchHashKeyName HandleError HandleSetErr ImplementorClass Kids LongReadLen NAME NAME_uc NAME_lc NAME_uc_hash NAME_lc_hash NULLABLE NUM_OF_FIELDS NUM_OF_PARAMS Name PRECISION ParamValues Profile Provider ReadOnly RootClass RowCacheSize RowsInCache SCALE State Statement TYPE Type TraceLevel Username Version));sub valid_attribute {my$attr=shift;return 1 if$is_valid_attribute{$attr};return 1 if$attr =~ m/^[a-z]/;return 0}my$initial_setup;sub initial_setup {$initial_setup=1;print$DBI::tfh __FILE__ ." version " .$DBI::PurePerl::VERSION ."\n" if$DBI::dbi_debug & 0xF;untie$DBI::err;untie$DBI::errstr;untie$DBI::state;untie$DBI::rows}sub _install_method {my ($caller,$method,$from,$param_hash)=@_;initial_setup()unless$initial_setup;my ($class,$method_name)=$method =~ /^[^:]+::(.+)::(.+)$/;my$bitmask=$param_hash->{'O'}|| 0;my@pre_call_frag;return if$method_name eq 'can';push@pre_call_frag,q{
          delete $h->{CachedKids};
          # ignore DESTROY for outer handle (DESTROY for inner likely to follow soon)
          return if $h_inner;
          # handle AutoInactiveDestroy and InactiveDestroy
          $h->{InactiveDestroy} = 1
              if $h->{AutoInactiveDestroy} and $$ != $h->{dbi_pp_pid};
          $h->{Active} = 0
              if $h->{InactiveDestroy};
  	# copy err/errstr/state up to driver so $DBI::err etc still work
  	if ($h->{err} and my $drh = $h->{Driver}) {
  	    $drh->{$_} = $h->{$_} for ('err','errstr','state');
  	}
      } if$method_name eq 'DESTROY';push@pre_call_frag,q{
  	return $h->{$_[0]} if exists $h->{$_[0]};
      } if$method_name eq 'FETCH' &&!exists$ENV{DBI_TRACE};push@pre_call_frag,"return;" if IMA_STUB & $bitmask;push@pre_call_frag,q{
  	$method_name = pop @_;
      } if IMA_FUNC_REDIRECT & $bitmask;push@pre_call_frag,q{
  	my $parent_dbh = $h->{Database};
      } if (IMA_COPY_UP_STMT|IMA_EXECUTE)& $bitmask;push@pre_call_frag,q{
  	warn "No Database set for $h on $method_name!" unless $parent_dbh; # eg proxy problems
  	$parent_dbh->{Statement} = $h->{Statement} if $parent_dbh;
      } if IMA_COPY_UP_STMT & $bitmask;push@pre_call_frag,q{
  	$h->{Executed} = 1;
  	$parent_dbh->{Executed} = 1 if $parent_dbh;
      } if IMA_EXECUTE & $bitmask;push@pre_call_frag,q{
  	%{ $h->{CachedKids} } = () if $h->{CachedKids};
      } if IMA_CLEAR_CACHED_KIDS & $bitmask;if (IMA_KEEP_ERR & $bitmask){push@pre_call_frag,q{
  	    my $keep_error = DBI::_err_hash($h);
  	}}else {my$ke_init=(IMA_KEEP_ERR_SUB & $bitmask)? q{= ($h->{dbi_pp_parent}->{dbi_pp_call_depth} && DBI::_err_hash($h)) } : "";push@pre_call_frag,qq{
  	    my \$keep_error $ke_init;
  	};my$clear_error_code=q{
  	    #warn "$method_name cleared err";
  	    $h->{err}    = $DBI::err    = undef;
  	    $h->{errstr} = $DBI::errstr = undef;
  	    $h->{state}  = $DBI::state  = '';
  	};$clear_error_code=q{
  	    printf $DBI::tfh "    !! %s: %s CLEARED by call to }.$method_name.q{ method\n".
  		    $h->{err}, $h->{err}
  		if defined $h->{err} && $DBI::dbi_debug & 0xF;
  	}.$clear_error_code if exists$ENV{DBI_TRACE};push@pre_call_frag,($ke_init)? qq{ unless (\$keep_error) { $clear_error_code }} : $clear_error_code unless$method_name eq 'set_err'}push@pre_call_frag,q{
  	my $ErrCount = $h->{ErrCount};
      };push@pre_call_frag,q{
          if (($DBI::dbi_debug & 0xF) >= 2) {
  	    local $^W;
  	    my $args = join " ", map { DBI::neat($_) } ($h, @_);
  	    printf $DBI::tfh "    > $method_name in $imp ($args) [$@]\n";
  	}
      } if exists$ENV{DBI_TRACE};push@pre_call_frag,q{
          $h->{'dbi_pp_last_method'} = $method_name;
      } unless exists$DBI::last_method_except{$method_name};my@post_call_frag;push@post_call_frag,q{
          if (my $trace_level = ($DBI::dbi_debug & 0xF)) {
  	    if ($h->{err}) {
  		printf $DBI::tfh "    !! ERROR: %s %s\n", $h->{err}, $h->{errstr};
  	    }
  	    my $ret = join " ", map { DBI::neat($_) } @ret;
  	    my $msg = "    < $method_name= $ret";
  	    $msg = ($trace_level >= 2) ? Carp::shortmess($msg) : "$msg\n";
  	    print $DBI::tfh $msg;
  	}
      } if exists$ENV{DBI_TRACE};push@post_call_frag,q{
  	$h->{Executed} = 0;
  	if ($h->{BegunWork}) {
  	    $h->{BegunWork}  = 0;
  	    $h->{AutoCommit} = 1;
  	}
      } if IMA_END_WORK & $bitmask;push@post_call_frag,q{
          if ( ref $ret[0] and
              UNIVERSAL::isa($ret[0], 'DBI::_::common') and
              defined( (my $h_new = tied(%{$ret[0]})||$ret[0])->{err} )
          ) {
              # copy up info/warn to drh so PrintWarn on connect is triggered
              $h->set_err($h_new->{err}, $h_new->{errstr}, $h_new->{state})
          }
      } if IMA_IS_FACTORY & $bitmask;push@post_call_frag,q{
          if ($keep_error) {
              $keep_error = 0
                  if $h->{ErrCount} > $ErrCount
                  or DBI::_err_hash($h) ne $keep_error;
          }
  
  	$DBI::err    = $h->{err};
  	$DBI::errstr = $h->{errstr};
  	$DBI::state  = $h->{state};
  
          if ( !$keep_error
  	&& defined(my $err = $h->{err})
  	&& ($call_depth <= 1 && !$h->{dbi_pp_parent}{dbi_pp_call_depth})
  	) {
  
  	    my($pe,$pw,$re,$he) = @{$h}{qw(PrintError PrintWarn RaiseError HandleError)};
  	    my $msg;
  
  	    if ($err && ($pe || $re || $he)	# error
  	    or (!$err && length($err) && $pw)	# warning
  	    ) {
  		my $last = ($DBI::last_method_except{$method_name})
  		    ? ($h->{'dbi_pp_last_method'}||$method_name) : $method_name;
  		my $errstr = $h->{errstr} || $DBI::errstr || $err || '';
  		my $msg = sprintf "%s %s %s: %s", $imp, $last,
  			($err eq "0") ? "warning" : "failed", $errstr;
  
  		if ($h->{'ShowErrorStatement'} and my $Statement = $h->{Statement}) {
  		    $msg .= ' [for Statement "' . $Statement;
  		    if (my $ParamValues = $h->FETCH('ParamValues')) {
  			$msg .= '" with ParamValues: ';
  			$msg .= DBI::_concat_hash_sorted($ParamValues, "=", ", ", 1, undef);
                          $msg .= "]";
  		    }
                      else {
                          $msg .= '"]';
                      }
  		}
  		if ($err eq "0") { # is 'warning' (not info)
  		    carp $msg if $pw;
  		}
  		else {
  		    my $do_croak = 1;
  		    if (my $subsub = $h->{'HandleError'}) {
  			$do_croak = 0 if &$subsub($msg,$h,$ret[0]);
  		    }
  		    if ($do_croak) {
  			printf $DBI::tfh "    $method_name has failed ($h->{PrintError},$h->{RaiseError})\n"
  				if ($DBI::dbi_debug & 0xF) >= 4;
  			carp  $msg if $pe;
  			die $msg if $h->{RaiseError};
  		    }
  		}
  	    }
  	}
      };my$method_code=q[
        sub {
          my $h = shift;
  	my $h_inner = tied(%$h);
  	$h = $h_inner if $h_inner;
  
          my $imp;
  	if ($method_name eq 'DESTROY') {
  	    # during global destruction, $h->{...} can trigger "Can't call FETCH on an undef value"
  	    # implying that tied() above lied to us, so we need to use eval
  	    local $@;	 # protect $@
  	    $imp = eval { $h->{"ImplementorClass"} } or return; # probably global destruction
  	}
  	else {
  	    $imp = $h->{"ImplementorClass"} or do {
                  warn "Can't call $method_name method on handle $h after take_imp_data()\n"
                      if not exists $h->{Active};
                  return; # or, more likely, global destruction
              };
  	}
  
  	] .join("\n",'',@pre_call_frag,'').q[
  
  	my $call_depth = $h->{'dbi_pp_call_depth'} + 1;
  	local ($h->{'dbi_pp_call_depth'}) = $call_depth;
  
  	my @ret;
          my $sub = $imp->can($method_name);
          if (!$sub and IMA_FUNC_REDIRECT & $bitmask and $sub = $imp->can('func')) {
              push @_, $method_name;
          }
  	if ($sub) {
  	    (wantarray) ? (@ret = &$sub($h,@_)) : (@ret = scalar &$sub($h,@_));
  	}
  	else {
  	    # XXX could try explicit fallback to $imp->can('AUTOLOAD') etc
  	    # which would then let Multiplex pass PurePerl tests, but some
  	    # hook into install_method may be better.
  	    croak "Can't locate DBI object method \"$method_name\" via package \"$imp\""
  		if ] .((IMA_NOT_FOUND_OKAY & $bitmask)? 0 : 1).q[;
  	}
  
  	] .join("\n",'',@post_call_frag,'').q[
  
  	return (wantarray) ? @ret : $ret[0];
        }
      ];no strict qw(refs);my$code_ref=eval qq{#line 1 "DBI::PurePerl $method"\n$method_code};warn "$@\n$method_code\n" if $@;die "$@\n$method_code\n" if $@;*$method=$code_ref;if (0 && $method =~ /\b(connect|FETCH)\b/){my$l=0;warn "*$method code:\n".join("\n",map {++$l.": $_"}split/\n/,$method_code)}}sub _new_handle {my ($class,$parent,$attr,$imp_data,$imp_class)=@_;DBI->trace_msg("    New $class (for $imp_class, parent=$parent, id=".($imp_data||'').")\n")if$DBI::dbi_debug >= 3;$attr->{ImplementorClass}=$imp_class or Carp::croak("_new_handle($class): 'ImplementorClass' attribute not given");my (%outer,$i,$h);$i=tie%outer,$class,$attr;$h=bless \%outer,$class;DBI::_setup_handle($h,$imp_class,$parent,$imp_data);return$h unless wantarray;return ($h,$i)}sub _setup_handle {my($h,$imp_class,$parent,$imp_data)=@_;my$h_inner=tied(%$h)|| $h;if (($DBI::dbi_debug & 0xF)>= 4){local $^W;print$DBI::tfh "      _setup_handle(@_)\n"}$h_inner->{"imp_data"}=$imp_data;$h_inner->{"ImplementorClass"}=$imp_class;$h_inner->{"Kids"}=$h_inner->{"ActiveKids"}=0;if ($parent){for (qw(RaiseError PrintError PrintWarn HandleError HandleSetErr Warn LongTruncOk ChopBlanks AutoCommit ReadOnly ShowErrorStatement FetchHashKeyName LongReadLen CompatMode)){$h_inner->{$_}=$parent->{$_}if exists$parent->{$_}&&!exists$h_inner->{$_}}if (ref($parent)=~ /::db$/){$h_inner->{Database}=$parent;$parent->{Statement}=$h_inner->{Statement};$h_inner->{NUM_OF_PARAMS}=0;$h_inner->{Active}=0}elsif (ref($parent)=~ /::dr$/){$h_inner->{Driver}=$parent;$h_inner->{Active}=0}else {warn "panic: ".ref($parent)}$h_inner->{dbi_pp_parent}=$parent;if ($HAS_WEAKEN){my$handles=$parent->{ChildHandles}||= [];push @$handles,$h;Scalar::Util::weaken($handles->[-1]);if (@$handles % 120==0){@$handles=grep {defined}@$handles;Scalar::Util::weaken($_)for @$handles}}}else {$h_inner->{Warn}=1;$h_inner->{PrintWarn}=1;$h_inner->{AutoCommit}=1;$h_inner->{TraceLevel}=0;$h_inner->{CompatMode}=(1==0);$h_inner->{FetchHashKeyName}||= 'NAME';$h_inner->{LongReadLen}||= 80;$h_inner->{ChildHandles}||= []if$HAS_WEAKEN;$h_inner->{Type}||= 'dr';$h_inner->{Active}=1}$h_inner->{"dbi_pp_call_depth"}=0;$h_inner->{"dbi_pp_pid"}=$$;$h_inner->{ErrCount}=0}sub constant {warn "constant(@_) called unexpectedly";return undef}sub trace {my ($h,$level,$file)=@_;$level=$h->parse_trace_flags($level)if defined$level and!DBI::looks_like_number($level);my$old_level=$DBI::dbi_debug;_set_trace_file($file)if$level;if (defined$level){$DBI::dbi_debug=$level;print$DBI::tfh "    DBI $DBI::VERSION (PurePerl) " ."dispatch trace level set to $DBI::dbi_debug\n" if$DBI::dbi_debug & 0xF}_set_trace_file($file)if!$level;return$old_level}sub _set_trace_file {my ($file)=@_;$DBI::tfh=undef unless$DBI::tfh_needs_close;if (ref$file eq 'GLOB'){$DBI::tfh=$file;select((select($DBI::tfh),$|=1)[0]);$DBI::tfh_needs_close=0;return 1}if ($file && ref \$file eq 'GLOB'){$DBI::tfh=*{$file}{IO};select((select($DBI::tfh),$|=1)[0]);$DBI::tfh_needs_close=0;return 1}$DBI::tfh_needs_close=1;if (!$file || $file eq 'STDERR'){open$DBI::tfh,">&STDERR" or carp "Can't dup STDERR: $!"}elsif ($file eq 'STDOUT'){open$DBI::tfh,">&STDOUT" or carp "Can't dup STDOUT: $!"}else {open$DBI::tfh,">>$file" or carp "Can't open $file: $!"}select((select($DBI::tfh),$|=1)[0]);return 1}sub _get_imp_data {shift->{"imp_data"}}sub _svdump {}sub dump_handle {my ($h,$msg,$level)=@_;$msg||="dump_handle $h";print$DBI::tfh "$msg:\n";for my$attrib (sort keys %$h){print$DBI::tfh "\t$attrib => ".DBI::neat($h->{$attrib})."\n"}}sub _handles {my$h=shift;my$h_inner=tied %$h;if ($h_inner){return$h unless wantarray;return ($h,$h_inner)}Carp::carp("Can't return outer handle from inner handle using DBI::PurePerl");return$h unless wantarray;return ($h,$h)}sub hash {my ($key,$type)=@_;my ($hash);if (!$type){$hash=0;for my$char (unpack ("c*",$key)){$hash=$hash * 33 + $char}$hash &= 0x7FFFFFFF;$hash |= 0x40000000;return -$hash}elsif ($type==1){require Math::BigInt;(my$version=$Math::BigInt::VERSION || 0)=~ s/_.*//;if ($version >= 1.56){$hash=Math::BigInt->new(0x811c9dc5);for my$uchar (unpack ("C*",$key)){$hash=($hash * 0x01000193)& 0xffffffff;$hash ^= $uchar}return unpack "i",pack "i",$hash}croak("DBI::PurePerl doesn't support hash type 1 without Math::BigInt >= 1.56 (available on CPAN)")}else {croak("bad hash type $type")}}sub looks_like_number {my@new=();for my$thing(@_){if (!defined$thing or $thing eq ''){push@new,undef}else {push@new,($thing =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/)? 1 : 0}}return (@_ >1)? @new : $new[0]}sub neat {my$v=shift;return "undef" unless defined$v;my$quote=q{"};if (not utf8::is_utf8($v)){return$v if (($v & ~ $v)eq "0");$quote=q{'}}my$maxlen=shift || $DBI::neat_maxlen;if ($maxlen && $maxlen < length($v)+ 2){$v=substr($v,0,$maxlen-5);$v .= '...'}$v =~ s/[^[:print:]]/./g;return "$quote$v$quote"}sub sql_type_cast {my (undef,$sql_type,$flags)=@_;return -1 unless defined $_[0];my$cast_ok=1;my$evalret=eval {use warnings FATAL=>qw(numeric);if ($sql_type==SQL_INTEGER){my$dummy=$_[0]+ 0;return 1}elsif ($sql_type==SQL_DOUBLE){my$dummy=$_[0]+ 0.0;return 1}elsif ($sql_type==SQL_NUMERIC){my$dummy=$_[0]+ 0.0;return 1}else {return -2}}or $^W && warn $@;return$evalret if defined($evalret)&& ($evalret==-2);$cast_ok=0 unless$evalret;return 2 if$cast_ok;return 0 if$flags & DBIstcf_STRICT;return 1}sub dbi_time {return time()}sub DBI::st::TIEHASH {bless $_[1]=>$_[0]};sub _concat_hash_sorted {my ($hash_ref,$kv_separator,$pair_separator,$use_neat,$num_sort)=@_;return undef unless defined$hash_ref;die "hash is not a hash reference" unless ref$hash_ref eq 'HASH';my$keys=_get_sorted_hash_keys($hash_ref,$num_sort);my$string='';for my$key (@$keys){$string .= $pair_separator if length$string > 0;my$value=$hash_ref->{$key};if ($use_neat){$value=DBI::neat($value,0)}else {$value=(defined$value)? "'$value'" : 'undef'}$string .= $key .$kv_separator .$value}return$string}sub _get_sorted_hash_keys {my ($hash_ref,$num_sort)=@_;if (not defined$num_sort){my$sort_guess=1;$sort_guess=(not looks_like_number($_))? 0 : $sort_guess for keys %$hash_ref;$num_sort=$sort_guess}my@keys=keys %$hash_ref;no warnings 'numeric';my@sorted=($num_sort)? sort {$a <=> $b or $a cmp $b}@keys : sort@keys;return \@sorted}sub _err_hash {return 1 unless defined $_[0]->{err};return "$_[0]->{err} $_[0]->{errstr}"}package DBI::var;sub FETCH {my($key)=shift;return$DBI::err if $$key eq '*err';return$DBI::errstr if $$key eq '&errstr';Carp::confess("FETCH $key not supported when using DBI::PurePerl")}package DBD::_::common;sub swap_inner_handle {my ($h1,$h2)=@_;return$h1->set_err($DBI::stderr,"swap_inner_handle not currently supported by DBI::PurePerl")}sub trace {my ($h,$level,$file)=@_;$level=$h->parse_trace_flags($level)if defined$level and!DBI::looks_like_number($level);my$old_level=$DBI::dbi_debug;DBI::_set_trace_file($file)if defined$file;if (defined$level){$DBI::dbi_debug=$level;if ($DBI::dbi_debug){printf$DBI::tfh "    %s trace level set to %d in DBI $DBI::VERSION (PurePerl)\n",$h,$DBI::dbi_debug;print$DBI::tfh "    Full trace not available because DBI_TRACE is not in environment\n" unless exists$ENV{DBI_TRACE}}}return$old_level}*debug=\&trace;*debug=\&trace;sub FETCH {my($h,$key)=@_;my$v=$h->{$key};return$v if defined$v;if ($key =~ /^NAME_.c$/){my$cols=$h->FETCH('NAME');return undef unless$cols;my@lcols=map {lc $_}@$cols;$h->{NAME_lc}=\@lcols;my@ucols=map {uc $_}@$cols;$h->{NAME_uc}=\@ucols;return$h->FETCH($key)}if ($key =~ /^NAME.*_hash$/){my$i=0;for my$c(@{$h->FETCH('NAME')||[]}){$h->{'NAME_hash'}->{$c}=$i;$h->{'NAME_lc_hash'}->{"\L$c"}=$i;$h->{'NAME_uc_hash'}->{"\U$c"}=$i;$i++}return$h->{$key}}if (!defined$v &&!exists$h->{$key}){return ($h->FETCH('TaintIn')&& $h->FETCH('TaintOut'))if$key eq'Taint';return (1==0)if$is_flag_attribute{$key};return$DBI::dbi_debug if$key eq 'TraceLevel';return []if$key eq 'ChildHandles' && $HAS_WEAKEN;if ($key eq 'Type'){return "dr" if$h->isa('DBI::dr');return "db" if$h->isa('DBI::db');return "st" if$h->isa('DBI::st');Carp::carp(sprintf "Can't determine Type for %s",$h)}if (!$is_valid_attribute{$key}and $key =~ m/^[A-Z]/){local $^W;Carp::carp(sprintf "Can't get %s->{%s}: unrecognised attribute (@{[ %$h ]})",$h,$key)}}return$v}sub STORE {my ($h,$key,$value)=@_;if ($key eq 'AutoCommit'){Carp::croak("DBD driver has not implemented the AutoCommit attribute")unless$value==-900 || $value==-901;$value=($value==-901)}elsif ($key =~ /^Taint/){Carp::croak(sprintf "Can't set %s->{%s}: Taint mode not supported by DBI::PurePerl",$h,$key)if$value}elsif ($key eq 'TraceLevel'){$h->trace($value);return 1}elsif ($key eq 'NUM_OF_FIELDS'){$h->{$key}=$value;if ($value){my$fbav=DBD::_::st::dbih_setup_fbav($h);@$fbav=(undef)x $value if @$fbav!=$value}return 1}elsif (!$is_valid_attribute{$key}&& $key =~ /^[A-Z]/ &&!exists$h->{$key}){Carp::carp(sprintf "Can't set %s->{%s}: unrecognised attribute or invalid value %s",$h,$key,$value)}$h->{$key}=$is_flag_attribute{$key}?!!$value : $value;Scalar::Util::weaken($h->{$key})if$key eq 'CachedKids';return 1}sub DELETE {my ($h,$key)=@_;return$h->FETCH($key)unless$key =~ /^private_/;return delete$h->{$key}}sub err {return shift->{err}}sub errstr {return shift->{errstr}}sub state {return shift->{state}}sub set_err {my ($h,$errnum,$msg,$state,$method,$rv)=@_;$h=tied(%$h)|| $h;if (my$hss=$h->{HandleSetErr}){return if$hss->($h,$errnum,$msg,$state,$method)}if (!defined$errnum){$h->{err}=$DBI::err=undef;$h->{errstr}=$DBI::errstr=undef;$h->{state}=$DBI::state='';return}if ($h->{errstr}){$h->{errstr}.= sprintf " [err was %s now %s]",$h->{err},$errnum if$h->{err}&& $errnum && $h->{err}ne $errnum;$h->{errstr}.= sprintf " [state was %s now %s]",$h->{state},$state if$h->{state}and $h->{state}ne "S1000" && $state && $h->{state}ne $state;$h->{errstr}.= "\n$msg" if$h->{errstr}ne $msg;$DBI::errstr=$h->{errstr}}else {$h->{errstr}=$DBI::errstr=$msg}my$err_changed;if ($errnum or!defined$h->{err}or defined$errnum && length($errnum)> length($h->{err})){$h->{err}=$DBI::err=$errnum;++$h->{ErrCount}if$errnum;++$err_changed}if ($err_changed){$state ||= "S1000" if$DBI::err;$h->{state}=$DBI::state=($state eq "00000")? "" : $state if$state}if (my$p=$h->{Database}){$p->{err}=$DBI::err;$p->{errstr}=$DBI::errstr;$p->{state}=$DBI::state}$h->{'dbi_pp_last_method'}=$method;return$rv}sub trace_msg {my ($h,$msg,$minlevel)=@_;$minlevel=1 unless defined$minlevel;return unless$minlevel <= ($DBI::dbi_debug & 0xF);print$DBI::tfh $msg;return 1}sub private_data {warn "private_data @_"}sub take_imp_data {my$dbh=shift;require Storable;croak("Can't take_imp_data from handle that's not Active")unless$dbh->{Active};for my$sth (@{$dbh->{ChildHandles}|| []}){next unless$sth;$sth->finish if$sth->{Active};bless$sth,'DBI::zombie'}delete$dbh->{$_}for (keys%is_valid_attribute);delete$dbh->{$_}for grep {m/^dbi_/}keys %$dbh;local$Storable::forgive_me=1;my$imp_data=Storable::freeze($dbh);return$imp_data}sub rows {return -1}sub DESTROY {}package DBD::_::dr;sub dbixs_revision {return 0}package DBD::_::db;sub connected {}package DBD::_::st;sub fetchrow_arrayref {my$h=shift;my@row=$h->fetchrow_array or return;return$h->_set_fbav(\@row)}*fetch=\&fetchrow_arrayref;*fetch=\&fetchrow_arrayref;sub fetchrow_array {my$h=shift;my$row=$h->fetch or return;return @$row}*fetchrow=\&fetchrow_array;*fetchrow=\&fetchrow_array;sub fetchrow_hashref {my$h=shift;my$row=$h->fetch or return;my$FetchCase=shift;my$FetchHashKeyName=$FetchCase || $h->{'FetchHashKeyName'}|| 'NAME';my$FetchHashKeys=$h->FETCH($FetchHashKeyName);my%rowhash;@rowhash{@$FetchHashKeys }=@$row;return \%rowhash}sub dbih_setup_fbav {my$h=shift;return$h->{'_fbav'}|| do {$DBI::rows=$h->{'_rows'}=0;my$fields=$h->{'NUM_OF_FIELDS'}or DBI::croak("NUM_OF_FIELDS not set");my@row=(undef)x $fields;\@row}}sub _get_fbav {my$h=shift;my$av=$h->{'_fbav'}||= dbih_setup_fbav($h);$DBI::rows=++$h->{'_rows'};return$av}sub _set_fbav {my$h=shift;my$fbav=$h->{'_fbav'};if ($fbav){$DBI::rows=++$h->{'_rows'}}else {$fbav=$h->_get_fbav}my$row=shift;if (my$bc=$h->{'_bound_cols'}){for my$i (0..@$row-1){my$bound=$bc->[$i];$fbav->[$i]=($bound)? ($$bound=$row->[$i]): $row->[$i]}}else {@$fbav=@$row}return$fbav}sub bind_col {my ($h,$col,$value_ref,$from_bind_columns)=@_;my$fbav=$h->{'_fbav'}||= dbih_setup_fbav($h);my$num_of_fields=@$fbav;DBI::croak("bind_col: column $col is not a valid column (1..$num_of_fields)")if$col < 1 or $col > $num_of_fields;return 1 if not defined$value_ref;DBI::croak("bind_col($col,$value_ref) needs a reference to a scalar")unless ref$value_ref eq 'SCALAR';$h->{'_bound_cols'}->[$col-1]=$value_ref;return 1}sub finish {my$h=shift;$h->{'_fbav'}=undef;$h->{'Active'}=0;return 1}sub rows {my$h=shift;my$rows=$h->{'_rows'};return -1 unless defined$rows;return$rows}1;
DBI_PUREPERL

$fatpacked{"DBI/SQL/Nano.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_SQL_NANO';
  package DBI::SQL::Nano;use strict;use warnings;use vars qw($VERSION $versions);use Carp qw(croak);require DBI;BEGIN {$VERSION="0.03";$versions->{nano_version}=$VERSION;if ($ENV{DBI_SQL_NANO}||!eval {require SQL::Statement;$SQL::Statement::VERSION ge '1.400'}){@DBI::SQL::Nano::Statement::ISA=qw(DBI::SQL::Nano::Statement_);@DBI::SQL::Nano::Table::ISA=qw(DBI::SQL::Nano::Table_)}else {@DBI::SQL::Nano::Statement::ISA=qw(SQL::Statement);@DBI::SQL::Nano::Table::ISA=qw(SQL::Eval::Table);$versions->{statement_version}=$SQL::Statement::VERSION}}package DBI::SQL::Nano::Statement_;use Carp qw(croak);use Errno;if (eval {require Clone}){Clone->import("clone")}else {require Storable;*clone=\&Storable::dclone}sub new {my ($class,$sql)=@_;my$self={};bless$self,$class;return$self->prepare($sql)}sub prepare {my ($self,$sql)=@_;$sql =~ s/\s+$//;$sql =~ s/\s*;$//;for ($sql){/^\s*CREATE\s+TABLE\s+(.*?)\s*\((.+)\)\s*$/is && do {$self->{command}='CREATE';$self->{table_name}=$1;defined $2 and $2 ne "" and $self->{column_names}=parse_coldef_list($2);$self->{column_names}or croak "Can't find columns"};/^\s*DROP\s+TABLE\s+(IF\s+EXISTS\s+)?(.*?)\s*$/is && do {$self->{command}='DROP';$self->{table_name}=$2;defined $1 and $1 ne "" and $self->{ignore_missing_table}=1};/^\s*SELECT\s+(.*?)\s+FROM\s+(\S+)((.*))?/is && do {$self->{command}='SELECT';defined $1 and $1 ne "" and $self->{column_names}=parse_comma_list($1);$self->{column_names}or croak "Can't find columns";$self->{table_name}=$2;if (my$clauses=$4){if ($clauses =~ /^(.*)\s+ORDER\s+BY\s+(.*)$/is){$clauses=$1;$self->{order_clause}=$self->parse_order_clause($2)}$self->{where_clause}=$self->parse_where_clause($clauses)if ($clauses)}};/^\s*INSERT\s+(?:INTO\s+)?(\S+)\s*(\((.*?)\))?\s*VALUES\s*\((.+)\)/is && do {$self->{command}='INSERT';$self->{table_name}=$1;defined $2 and $2 ne "" and $self->{column_names}=parse_comma_list($2);defined $4 and $4 ne "" and $self->{values}=$self->parse_values_list($4);$self->{values}or croak "Can't parse values"};/^\s*DELETE\s+FROM\s+(\S+)((.*))?/is && do {$self->{command}='DELETE';$self->{table_name}=$1;defined $3 and $3 ne "" and $self->{where_clause}=$self->parse_where_clause($3)};/^\s*UPDATE\s+(\S+)\s+SET\s+(.+)(\s+WHERE\s+.+)/is && do {$self->{command}='UPDATE';$self->{table_name}=$1;defined $2 and $2 ne "" and $self->parse_set_clause($2);defined $3 and $3 ne "" and $self->{where_clause}=$self->parse_where_clause($3)}}croak "Couldn't parse" unless ($self->{command}and $self->{table_name});return$self}sub parse_order_clause {my ($self,$str)=@_;my@clause=split /\s+/,$str;return {$clause[0]=>'ASC' }if (@clause==1);croak "Bad ORDER BY clause '$str'" if (@clause > 2);$clause[1]||= '';return {$clause[0]=>uc$clause[1]}if$clause[1]=~ /^ASC$/i or $clause[1]=~ /^DESC$/i;croak "Bad ORDER BY clause '$clause[1]'"}sub parse_coldef_list {my@col_defs;for (split ',',shift){my$col=clean_parse_str($_);if ($col =~ /^(\S+?)\s+.+/){$col=$1}else {croak "No column definition for '$_'"}push@col_defs,$col}return \@col_defs}sub parse_comma_list {[map {clean_parse_str($_)}split(',',shift)]}sub clean_parse_str {local $_=shift;s/\(//;s/\)//;s/^\s+//;s/\s+$//;$_}sub parse_values_list {my ($self,$str)=@_;[map {$self->parse_value(clean_parse_str($_))}split(',',$str)]}sub parse_set_clause {my$self=shift;my@cols=split /,/,shift;my$set_clause;for my$col (@cols){my ($col_name,$value)=$col =~ /^\s*(.+?)\s*=\s*(.+?)\s*$/s;push @{$self->{column_names}},$col_name;push @{$self->{values}},$self->parse_value($value)}croak "Can't parse set clause" unless ($self->{column_names}and $self->{values})}sub parse_value {my ($self,$str)=@_;return unless (defined$str);$str =~ s/\s+$//;$str =~ s/^\s+//;if ($str =~ /^\?$/){push @{$self->{params}},'?';return {value=>'?',type=>'placeholder' }}return {value=>undef,type=>'NULL' }if ($str =~ /^NULL$/i);return {value=>$1,type=>'string' }if ($str =~ /^'(.+)'$/s);return {value=>$str,type=>'number' }if (DBI::looks_like_number($str));return {value=>$str,type=>'column' }}sub parse_where_clause {my ($self,$str)=@_;$str =~ s/\s+$//;if ($str =~ /^\s*WHERE\s+(.*)/i){$str=$1}else {croak "Couldn't find WHERE clause in '$str'"}my ($neg)=$str =~ s/^\s*(NOT)\s+//is;my$opexp='=|<>|<=|>=|<|>|LIKE|CLIKE|IS';my ($val1,$op,$val2)=$str =~ /^(.+?)\s*($opexp)\s*(.+)\s*$/iso;croak "Couldn't parse WHERE expression '$str'" unless (defined$val1 and defined$op and defined$val2);return {arg1=>$self->parse_value($val1),arg2=>$self->parse_value($val2),op=>$op,neg=>$neg,}}sub execute {my ($self,$data,$params)=@_;my$num_placeholders=$self->params;my$num_params=scalar @$params || 0;croak "Number of params '$num_params' does not match number of placeholders '$num_placeholders'" unless ($num_placeholders==$num_params);if (scalar @$params){for my$i (0 .. $#{$self->{values}}){if ($self->{values}->[$i]->{type}eq 'placeholder'){$self->{values}->[$i]->{value}=shift @$params}}if ($self->{where_clause}){if ($self->{where_clause}->{arg1}->{type}eq 'placeholder'){$self->{where_clause}->{arg1}->{value}=shift @$params}if ($self->{where_clause}->{arg2}->{type}eq 'placeholder'){$self->{where_clause}->{arg2}->{value}=shift @$params}}}my$command=$self->{command};($self->{'NUM_OF_ROWS'},$self->{'NUM_OF_FIELDS'},$self->{'data'},)=$self->$command($data,$params);$self->{NAME}||= $self->{column_names};return$self->{'NUM_OF_ROWS'}|| '0E0'}my$enoentstr="Cannot open .*\(" .Errno::ENOENT ."\)";my$enoentrx=qr/$enoentstr/;sub DROP ($$$) {my ($self,$data,$params)=@_;my$table;my@err;eval {local$SIG{__WARN__}=sub {push@err,@_};($table)=$self->open_tables($data,0,1)};if ($self->{ignore_missing_table}and ($@ or @err)and grep {$_ =~ $enoentrx}(@err,$@)){$@='';return (-1,0)}croak($@ || $err[0])if ($@ || @err);return (-1,0)unless$table;$table->drop($data);(-1,0)}sub CREATE ($$$) {my ($self,$data,$params)=@_;my$table=$self->open_tables($data,1,1);$table->push_names($data,$self->{column_names});(0,0)}sub INSERT ($$$) {my ($self,$data,$params)=@_;my$table=$self->open_tables($data,0,1);$self->verify_columns($table);my$all_columns=$table->{col_names};$table->seek($data,0,2)unless ($table->can('insert_one_row'));my ($array)=[];my ($val,$col,$i);$self->{column_names}=$table->col_names()unless ($self->{column_names});my$cNum=scalar(@{$self->{column_names}})if ($self->{column_names});my$param_num=0;$cNum or croak "Bad col names in INSERT";my$maxCol=$#$all_columns;for ($i=0;$i < $cNum;$i++ ){$col=$self->{column_names}->[$i];$array->[$self->column_nums($table,$col)]=$self->row_values($i)}$#$array < $maxCol and $array->[$maxCol]=undef;$table->can('insert_new_row')? $table->insert_new_row($data,$array): $table->push_row($data,$array);return (1,0)}sub DELETE ($$$) {my ($self,$data,$params)=@_;my$table=$self->open_tables($data,0,1);$self->verify_columns($table);my ($affected)=0;my (@rows,$array);my$can_dor=$table->can('delete_one_row');while ($array=$table->fetch_row($data)){if ($self->eval_where($table,$array)){++$affected;if ($self->{fetched_from_key}){$array=$self->{fetched_value};$table->delete_one_row($data,$array);return ($affected,0)}push(@rows,$array)if ($can_dor)}else {push(@rows,$array)unless ($can_dor)}}if ($can_dor){for$array (@rows){$table->delete_one_row($data,$array)}}else {$table->seek($data,0,0);for$array (@rows){$table->push_row($data,$array)}$table->truncate($data)}return ($affected,0)}sub _anycmp($$;$) {my ($a,$b,$case_fold)=@_;if (!defined($a)||!defined($b)){return defined($a)- defined($b)}elsif (DBI::looks_like_number($a)&& DBI::looks_like_number($b)){return$a <=> $b}else {return$case_fold ? lc($a)cmp lc($b)|| $a cmp $b : $a cmp $b}}sub SELECT ($$$) {my ($self,$data,$params)=@_;my$table=$self->open_tables($data,0,0);$self->verify_columns($table);my$tname=$self->{table_name};my ($affected)=0;my (@rows,%cols,$array,$val,$col,$i);while ($array=$table->fetch_row($data)){if ($self->eval_where($table,$array)){$array=$self->{fetched_value}if ($self->{fetched_from_key});unless (keys%cols){my$col_nums=$self->column_nums($table);%cols=reverse %{$col_nums}}my$rowhash;for (sort keys%cols){$rowhash->{$cols{$_}}=$array->[$_]}my@newarray;for ($i=0;$i < @{$self->{column_names}};$i++ ){$col=$self->{column_names}->[$i];push@newarray,$rowhash->{$col}}push(@rows,\@newarray);return (scalar(@rows),scalar @{$self->{column_names}},\@rows)if ($self->{fetched_from_key})}}if ($self->{order_clause}){my ($sort_col,$desc)=each %{$self->{order_clause}};my@sortCols=($self->column_nums($table,$sort_col,1));$sortCols[1]=uc$desc eq 'DESC' ? 1 : 0;@rows=sort {my ($result,$colNum,$desc);my$i=0;do {$colNum=$sortCols[$i++ ];$desc=$sortCols[$i++ ];$result=_anycmp($a->[$colNum],$b->[$colNum]);$result=-$result if ($desc)}while (!$result && $i < @sortCols);$result}@rows}(scalar(@rows),scalar @{$self->{column_names}},\@rows)}sub UPDATE ($$$) {my ($self,$data,$params)=@_;my$table=$self->open_tables($data,0,1);$self->verify_columns($table);return undef unless$table;my$affected=0;my$can_usr=$table->can('update_specific_row');my$can_uor=$table->can('update_one_row');my$can_rwu=$can_usr || $can_uor;my (@rows,$array,$f_array,$val,$col,$i);while ($array=$table->fetch_row($data)){if ($self->eval_where($table,$array)){$array=$self->{fetched_value}if ($self->{fetched_from_key}and $can_rwu);my$orig_ary=clone($array)if ($can_usr);for ($i=0;$i < @{$self->{column_names}};$i++ ){$col=$self->{column_names}->[$i];$array->[$self->column_nums($table,$col)]=$self->row_values($i)}$affected++;if ($self->{fetched_value}){if ($can_usr){$table->update_specific_row($data,$array,$orig_ary)}elsif ($can_uor){$table->update_one_row($data,$array)}return ($affected,0)}push(@rows,$can_usr ? [$array,$orig_ary ]: $array)}else {push(@rows,$array)unless ($can_rwu)}}if ($can_rwu){for my$array (@rows){if ($can_usr){$table->update_specific_row($data,@$array)}elsif ($can_uor){$table->update_one_row($data,$array)}}}else {$table->seek($data,0,0);for my$array (@rows){$table->push_row($data,$array)}$table->truncate($data)}return ($affected,0)}sub verify_columns {my ($self,$table)=@_;my@cols=@{$self->{column_names}};if ($self->{where_clause}){if (my$col=$self->{where_clause}->{arg1}){push@cols,$col->{value}if$col->{type}eq 'column'}if (my$col=$self->{where_clause}->{arg2}){push@cols,$col->{value}if$col->{type}eq 'column'}}for (@cols){$self->column_nums($table,$_)}}sub column_nums {my ($self,$table,$stmt_col_name,$find_in_stmt)=@_;my%dbd_nums=%{$table->col_nums()};my@dbd_cols=@{$table->col_names()};my%stmt_nums;if ($stmt_col_name and!$find_in_stmt){while (my ($k,$v)=each%dbd_nums){return$v if uc$k eq uc$stmt_col_name}croak "No such column '$stmt_col_name'"}if ($stmt_col_name and $find_in_stmt){for my$i (0 .. @{$self->{column_names}}){return$i if uc$stmt_col_name eq uc$self->{column_names}->[$i]}croak "No such column '$stmt_col_name'"}for my$i (0 .. $#dbd_cols){for my$stmt_col (@{$self->{column_names}}){$stmt_nums{$stmt_col}=$i if uc$dbd_cols[$i]eq uc$stmt_col}}return \%stmt_nums}sub eval_where {my ($self,$table,$rowary)=@_;my$where=$self->{"where_clause"}|| return 1;my$col_nums=$table->col_nums();my%cols=reverse %{$col_nums};my$rowhash;for (sort keys%cols){$rowhash->{uc$cols{$_}}=$rowary->[$_]}return$self->process_predicate($where,$table,$rowhash)}sub process_predicate {my ($self,$pred,$table,$rowhash)=@_;my$val1=$pred->{arg1};if ($val1->{type}eq 'column'){$val1=$rowhash->{uc$val1->{value}}}else {$val1=$val1->{value}}my$val2=$pred->{arg2};if ($val2->{type}eq 'column'){$val2=$rowhash->{uc$val2->{value}}}else {$val2=$val2->{value}}my$op=$pred->{op};my$neg=$pred->{neg};if ($op eq '=' and!$neg and $table->can('fetch_one_row')){my$key_col=$table->fetch_one_row(1,1);if ($pred->{arg1}->{value}=~ /^$key_col$/i){$self->{fetched_from_key}=1;$self->{fetched_value}=$table->fetch_one_row(0,$pred->{arg2}->{value});return 1}}my$match=$self->is_matched($val1,$op,$val2)|| 0;if ($neg){$match=$match ? 0 : 1}return$match}sub is_matched {my ($self,$val1,$op,$val2)=@_;if ($op eq 'IS'){return 1 if (!defined$val1 or $val1 eq '');return 0}$val1='' unless (defined$val1);$val2='' unless (defined$val2);if ($op =~ /LIKE|CLIKE/i){$val2=quotemeta($val2);$val2 =~ s/\\%/.*/g;$val2 =~ s/_/./g}if ($op eq 'LIKE'){return$val1 =~ /^$val2$/s}if ($op eq 'CLIKE'){return$val1 =~ /^$val2$/si}if (DBI::looks_like_number($val1)&& DBI::looks_like_number($val2)){if ($op eq '<'){return$val1 < $val2}if ($op eq '>'){return$val1 > $val2}if ($op eq '='){return$val1==$val2}if ($op eq '<>'){return$val1!=$val2}if ($op eq '<='){return$val1 <= $val2}if ($op eq '>='){return$val1 >= $val2}}else {if ($op eq '<'){return$val1 lt $val2}if ($op eq '>'){return$val1 gt $val2}if ($op eq '='){return$val1 eq $val2}if ($op eq '<>'){return$val1 ne $val2}if ($op eq '<='){return$val1 ge $val2}if ($op eq '>='){return$val1 le $val2}}}sub params {my ($self,$val_num)=@_;if (!$self->{"params"}){return 0}if (defined$val_num){return$self->{"params"}->[$val_num]}return wantarray ? @{$self->{"params"}}: scalar @{$self->{"params"}}}sub open_tables {my ($self,$data,$createMode,$lockMode)=@_;my$table_name=$self->{table_name};my$table;eval {$table=$self->open_table($data,$table_name,$createMode,$lockMode)};if ($@){chomp $@;croak $@}croak "Couldn't open table '$table_name'" unless$table;if (!$self->{column_names}or $self->{column_names}->[0]eq '*'){$self->{column_names}=$table->col_names()}return$table}sub row_values {my ($self,$val_num)=@_;if (!$self->{"values"}){return 0}if (defined$val_num){return$self->{"values"}->[$val_num]->{value}}if (wantarray){return map {$_->{"value"}}@{$self->{"values"}}}else {return scalar @{$self->{"values"}}}}sub column_names {my ($self)=@_;my@col_names;if ($self->{column_names}and $self->{column_names}->[0]ne '*'){@col_names=@{$self->{column_names}}}return@col_names}package DBI::SQL::Nano::Table_;use Carp qw(croak);sub new ($$) {my ($proto,$attr)=@_;my ($self)={%$attr};defined($self->{col_names})and "ARRAY" eq ref($self->{col_names})or croak("attribute 'col_names' must be defined as an array");exists($self->{col_nums})or $self->{col_nums}=_map_colnums($self->{col_names});defined($self->{col_nums})and "HASH" eq ref($self->{col_nums})or croak("attribute 'col_nums' must be defined as a hash");bless($self,(ref($proto)|| $proto));return$self}sub _map_colnums {my$col_names=$_[0];my%col_nums;for my$i (0 .. $#$col_names){next unless$col_names->[$i];$col_nums{$col_names->[$i]}=$i}return \%col_nums}sub row() {return $_[0]->{row}}sub column($) {return $_[0]->{row}->[$_[0]->column_num($_[1])]}sub column_num($) {$_[0]->{col_nums}->{$_[1]}}sub col_nums() {$_[0]->{col_nums}}sub col_names() {$_[0]->{col_names}}sub drop ($$) {croak "Abstract method " .ref($_[0])."::drop called"}sub fetch_row ($$$) {croak "Abstract method " .ref($_[0])."::fetch_row called"}sub push_row ($$$) {croak "Abstract method " .ref($_[0])."::push_row called"}sub push_names ($$$) {croak "Abstract method " .ref($_[0])."::push_names called"}sub truncate ($$) {croak "Abstract method " .ref($_[0])."::truncate called"}sub seek ($$$$) {croak "Abstract method " .ref($_[0])."::seek called"}1;
DBI_SQL_NANO

$fatpacked{"DBI/Util/CacheMemory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_UTIL_CACHEMEMORY';
  package DBI::Util::CacheMemory;use strict;use warnings;our$VERSION="0.03";my%cache;sub new {my ($class,%options)=@_;my$namespace=$options{namespace}||= 'Default';my$self=bless \%options=>$class;$cache{$namespace }||= {};return$self}sub set {my ($self,$key,$value)=@_;$cache{$self->{namespace}}->{$key}=$value}sub get {my ($self,$key)=@_;return$cache{$self->{namespace}}->{$key}}sub exists {my ($self,$key)=@_;return exists$cache{$self->{namespace}}->{$key}}sub remove {my ($self,$key)=@_;return delete$cache{$self->{namespace}}->{$key}}sub purge {return shift->clear}sub clear {$cache{shift->{namespace}}={}}sub count {return scalar keys %{$cache{shift->{namespace}}}}sub size {my$c=$cache{shift->{namespace}};my$size=0;while (my ($k,$v)=each %$c){$size += length($k)+ length($v)}return$size}1;
DBI_UTIL_CACHEMEMORY

$fatpacked{"DBI/Util/_accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_UTIL__ACCESSOR';
  package DBI::Util::_accessor;use strict;use Carp;our$VERSION="0.03";sub new {my($proto,$fields)=@_;my($class)=ref$proto || $proto;$fields ||= {};my@dubious=grep {!m/^_/ &&!$proto->can($_)}keys %$fields;carp "$class doesn't have accessors for fields: @dubious" if@dubious;bless {%$fields},$class}sub mk_accessors {my($self,@fields)=@_;$self->mk_accessors_using('make_accessor',@fields)}sub mk_accessors_using {my($self,$maker,@fields)=@_;my$class=ref$self || $self;$maker=$self->can($maker)unless ref$maker;no strict 'refs';for my$field (@fields){my$accessor=$self->$maker($field);*{$class."\:\:$field"}=$accessor unless defined &{$class."\:\:$field"}}return}sub make_accessor {my($class,$field)=@_;return sub {my$self=shift;return$self->{$field}unless @_;croak "Too many arguments to $field" if @_ > 1;return$self->{$field}=shift}}sub make_accessor_autoviv_hashref {my($class,$field)=@_;return sub {my$self=shift;return$self->{$field}||= {}unless @_;croak "Too many arguments to $field" if @_ > 1;return$self->{$field}=shift}}1;
DBI_UTIL__ACCESSOR

$fatpacked{"DBI/W32ODBC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DBI_W32ODBC';
  package DBI;${'DBI::VERSION'}="0.01";my$Revision=sprintf("12.%06d",q$Revision: 8696 $ =~ /(\d+)/o);sub DBI::W32ODBC::import {}use Carp;use Win32::ODBC;@ISA=qw(Win32::ODBC);use strict;$DBI::dbi_debug=$ENV{PERL_DBI_DEBUG}|| 0;carp "Loaded (W32ODBC) DBI.pm ${'DBI::VERSION'} (debug $DBI::dbi_debug)" if$DBI::dbi_debug;sub connect {my ($class,$dbname,$dbuser,$dbpasswd,$module,$attr)=@_;$dbname .= ";UID=$dbuser" if$dbuser;$dbname .= ";PWD=$dbpasswd" if$dbpasswd;my$h=new Win32::ODBC$dbname;warn "Error connecting to $dbname: ".Win32::ODBC::Error()."\n" unless$h;bless$h,$class if$h;$h}sub quote {my ($h,$string)=@_;return "NULL" if!defined$string;$string =~ s/'/''/g;$string =~ s/\r/' & chr\$(13) & '/g;$string =~ s/\n/' & chr\$(10) & '/g;"'$string'"}sub do {my($h,$statement,$attribs,@params)=@_;Carp::carp "\$h->do() attribs unused" if$attribs;my$new_h=$h->prepare($statement)or return undef;pop @{$h->{'___sths'}};$new_h->execute(@params)or return undef;my$rows=$new_h->rows;$new_h->finish;($rows==0)? "0E0" : $rows}sub prepare {my ($h,$sql)=@_;my$new_h=new Win32::ODBC$h->{DSN};return undef if not $new_h;bless$new_h;$new_h->{'__prepare'}=$sql;$new_h->{NAME}=[];$new_h->{NUM_OF_FIELDS}=-1;push @{$h->{'___sths'}},$new_h;return$new_h}sub execute {my ($h)=@_;my$rc=$h->Sql($h->{'__prepare'});return undef if$rc;my@fields=$h->FieldNames;$h->{NAME}=\@fields;$h->{NUM_OF_FIELDS}=scalar@fields;$h}sub fetchrow_hashref {my$h=shift;my$NAME=shift || "NAME";my$row=$h->fetchrow_arrayref or return undef;my%hash;@hash{@{$h->{$NAME}}}=@$row;return \%hash}sub fetchrow {my$h=shift;return unless$h->FetchRow();my$fields_r=$h->{NAME};return$h->Data(@$fields_r)}sub fetch {my@row=shift->fetchrow;return undef unless@row;return \@row}*fetchrow_arrayref=\&fetch;*fetchrow_array=\&fetchrow;sub rows {shift->RowCount}sub finish {shift->Close}sub commit {shift->Transact(ODBC::SQL_COMMIT)}sub rollback {shift->Transact(ODBC::SQL_ROLLBACK)}sub disconnect {my ($h)=shift;for (@{$h->{'___sths'}}){$_->Close if $_->{DSN}}$h->Close}sub err {(shift->Error)[0]}sub errstr {scalar(shift->Error)}1;
DBI_W32ODBC

$fatpacked{"Docopt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DOCOPT';
  use 5.008005;use strict;use warnings FATAL=>'all';package Docopt;use Docopt::Util qw(string_partition in serialize defined_or);package Docopt::Pattern;use Docopt::Util qw(defined_or);sub new {my$class=shift;bless [],$class}sub fix {my$self=shift;$self->fix_identities();$self->fix_repeating_arguments();return$self}use Docopt::Util qw(in serialize);sub fix_identities {my ($self,$uniq)=@_;if (!$self->can('children')){return$self}$uniq=defined_or($uniq,$self->flat);for (my$i=0;$i<@{$self->children};$i++){my$child=$self->children->[$i];if (not $child->can('children')){local$Storable::canonical=1;in(serialize($child),[map {serialize($_)}@$uniq])or die;($self->children->[$i],)=grep {serialize($_)eq serialize($child)}@$uniq}else {$child->fix_identities($uniq)}}}use Scalar::Util qw(refaddr);use Docopt::Util qw(repl serialize);sub fix_repeating_arguments {my$self=shift;my$list_count=sub {my ($list,$stuff)=@_;my$n=0;for (@$list){$n++ if serialize($stuff)eq serialize($_)}return$n};my@either=map {$_->children}@{Docopt::transform($self)->children};for my$case (@either){for my$e (grep {$list_count->($case,$_)> 1}@$case){if ($e->isa('Docopt::Argument')|| ($e->isa('Docopt::Option')&& $e->argcount)){if (not defined$e->value){$e->value([])}elsif (ref($e->value)ne 'ARRAY'){$e->value([split /\s+/,$e->value])}}if ($e->isa('Docopt::Command')|| ($e->isa('Docopt::Option')&& $e->argcount==0)){$e->value(0)}}}return$self}package Docopt;use parent qw(Exporter);our@EXPORT=qw(docopt);use List::MoreUtils qw(any);use Scalar::Util qw(blessed refaddr);use Docopt::Util qw(repl pyprint serialize);sub transform {my ($pattern)=@_;my@results;my@groups=[$pattern];while (@groups){my$children=shift@groups;my@parents=qw(Docopt::Required Docopt::Optional Docopt::OptionsShortcut Docopt::Either Docopt::OneOrMore);if (any {in($_,[map {blessed $_}@$children])}@parents){my$child=[grep {in(blessed $_,\@parents)}@$children]->[0];$children=[grep {refaddr($child)ne refaddr($_)}@$children ];if ($child->isa('Docopt::Either')){for (@{$child->children}){push@groups,[$_,@{$children}]}}elsif ($child->isa('Docopt::OneOrMore')){push@groups,[@{$child->children},@{Storable::dclone($child->children)},@$children]}else {push@groups,[@{$child->children},@$children]}}else {push@results,$children}}return Docopt::Either->new([map {Docopt::Required->new($_)}@results])}package Docopt::LeafPattern;use parent -norequire,qw(Docopt::Pattern);use Docopt::Util qw(repl class_name True False is_number);use Class::Accessor::Lite (rw=>[qw(name)],);sub value {my$self=shift;return$self->{value}if @_==0;if (@_==1){$self->{value}=$_[0]}else {Carp::confess("Too much arguments")}}sub new {my ($class,$name,$value)=@_;bless {name=>$name,value=>$value,},$class}sub __repl__ {my$self=shift;sprintf '%s(%s, %s)',class_name($self),repl($self->name),repl($self->value)}sub flat {my ($self,$types)=@_;if (!defined($types)|| $self->isa($types)){return [$self]}else {return []}}sub match {my$self=shift;my@left=@{+shift};my@collected=@{+shift || +[]};my ($pos,$match)=$self->single_match(\@left);unless ($match){return (False,\@left,\@collected)}my@left_=(@left[0..$pos-1],@left[$pos+1..@left-1]);my@same_name=grep {$_->name eq $self->name}@collected;if (is_number($self->value)|| ref($self->value)eq 'ARRAY'){my$increment;if (is_number($self->value)){$increment=1}else {$increment=ref($match->value)eq 'ARRAY' ? $match->value : [$match->value]}unless (@same_name){$match->value($increment);return (True,\@left_,[@collected,$match])}if (ref$same_name[0]->value eq 'ARRAY'){$same_name[0]->value([@{$same_name[0]->value},ref($increment)eq 'ARRAY' ? @$increment : $increment])}else {ref($increment)ne 'ARRAY' or Carp::confess("Invalid addition");$same_name[0]->value($same_name[0]->value + $increment)}return (True,\@left_,\@collected)}return (True,\@left_,[@collected,$match])}package Docopt::BranchPattern;use parent -norequire,qw(Docopt::Pattern);use Carp;use Docopt::Util qw(repl class_name);use Scalar::Util qw(blessed);sub new {my ($class,$children)=@_;Carp::croak("Too much arguments")unless @_==2;Carp::confess "Children must be arrayref: $class, $children" unless ref$children eq 'ARRAY';$children=[map {ref($_)eq 'ARRAY' ? @$_ : $_}@$children];bless {children=>[@$children],},$class}sub children {my$self=shift;return$self->{children}if @_==0;if (@_==1){ref($_[0])eq 'ARRAY' or Carp::confess("Argument must be ArrayRef but: " .$_[0]);$self->{children}=$_[0]}else {Carp::confess("Too much arguments")}}sub __repl__ {my$self=shift;sprintf '%s(%s)',class_name($self),join(', ',map {repl($_)}@{$self->{children}})}sub flat {my$self=shift;my$types=shift;if (defined($types)&& $self->isa($types)){return [$self]}my@ret=map {ref($_)eq 'ARRAY' ? @$_ : $_}map {$_->flat($types)}@{$self->children};return \@ret}package Docopt::Argument;use parent -norequire,qw(Docopt::LeafPattern);sub single_match {my ($self,$left)=@_;ref$left eq 'ARRAY' or die;for (my$n=0;$n<@$left;$n++){my$pattern=$left->[$n];if ($pattern->isa(Docopt::Argument::)){return ($n,Docopt::Argument->new($self->name,$pattern->value))}}return (undef,undef)}sub parse {my ($class,$source)=@_;$source =~ /(<\S*?>)/;my$name=$1;$source =~ /\[default: (.*)\]/i;my$value=$1;return$class->new($name,$value)}package Docopt::Command;use parent -norequire,qw(Docopt::Argument);use Class::Accessor::Lite (rw=>[qw(name value)]);use boolean;sub new {my ($class,$name,$value)=@_;bless {name=>$name,value=>$value,},$class}sub single_match {my ($self,$left)=@_;ref$left eq 'ARRAY' or die;for (my$n=0;$n<@$left;$n++){my$pattern=$left->[$n];if ($pattern->isa(Docopt::Argument::)){if ($pattern->value eq $self->name){return ($n,Docopt::Command->new($self->name,true))}else {last}}}return (undef,undef)}package Docopt::Required;use parent -norequire,qw(Docopt::BranchPattern);use boolean;sub match {my ($self,$left,$collected)=@_;$collected ||= [];my$l=$left;my$c=$collected;for my$pattern (@{$self->children}){my$matched;($matched,$l,$c)=$pattern->match($l,$c);unless ($matched){ref($c)eq 'ARRAY' or Carp::confess("c is not arrayref");return (false,$left,$collected)}}ref($c)eq 'ARRAY' or Carp::confess("c is not arrayref: " .join(', ',@{$self->children}));return (true,$l,$c)}package Docopt::Optional;use parent -norequire,qw(Docopt::BranchPattern);use boolean;sub match {my ($self,$left,$collected)=@_;$collected ||= [];ref($collected)eq 'ARRAY' or Carp::confess("collected is not arrayref: " .join(', ',@{$self->children}));my$m;for my$pattern (@{$self->children}){($m,$left,$collected)=$pattern->match($left,$collected)}ref($collected)eq 'ARRAY' or Carp::confess("collected is not arrayref: " .join(', ',@{$self->children}));return (true,$left,$collected)}package Docopt::OptionsShortcut;use parent -norequire,qw(Docopt::Optional);package Docopt::OneOrMore;use parent -norequire,qw(Docopt::BranchPattern);use boolean;use Storable;use Docopt::Util qw(serialize);sub match {my ($self,$left,$collected)=@_;@{$self->children}==1 or die;$collected ||= [];my$l=$left;my$c=$collected;my$l_=undef;my$matched=true;my$times=0;while ($matched){($matched,$l,$c)=$self->children->[0]->match($l,$c);$times++ if$matched;if (serialize(\$l_)eq serialize(\$l)){last}$l_=$l}if ($times >= 1){return (true,$l,$c)}return (false,$left,$collected)}package Docopt::Either;use parent -norequire,qw(Docopt::BranchPattern);use boolean;sub match {my ($self,$left,$collected)=@_;$collected ||= [];my@outcomes;for my$pattern (@{$self->children}){my@outcome=$pattern->match($left,$collected);my$matched=$outcome[0];if ($matched){push@outcomes,\@outcome}}if (@outcomes){my$retval=shift@outcomes;for (@outcomes){if (@{$_->[1]}< @{$retval->[1]}){$retval=$_}}return @$retval}return (false,$left,$collected)}package Docopt::Tokens;use Docopt::Util qw(repl);use Class::Accessor::Lite 0.05 (rw=>[qw(error source)],);sub new {my ($class,$source,$error)=@_;$error ||= 'Docopt::Exceptions::DocoptExit';unless (ref$source){$source=[split /\s+/,$source]}bless {source=>[@$source],error=>$error},$class}sub from_pattern {my ($class,$source)=@_;$source =~ s/([\[\]\(\)\|]|\.\.\.)/ $1 /g;my@source=grep {defined($_)&& length $_ > 0}split /\s+|(\S*<.*?>)/,$source;return Docopt::Tokens->new(\@source,'Docopt::Exceptions::DocoptLanguageError')}sub move {my$self=shift;shift @{$self->{source}}}sub current {my$self=shift;$self->source->[0]}sub __repl__ {my$self=shift;'[' .join(', ',map {repl($_)}@{$self->source}).']'}package Docopt;our$VERSION="0.03";package Docopt::Option;use parent -norequire,qw(Docopt::LeafPattern);use Docopt::Util qw(repl string_strip string_partition defined_or);use Class::Accessor::Lite 0.05 (rw=>[qw(short long argcount)],);sub new {my ($class,$short,$long,$argcount,$value)=@_;if (@_<= 3){$argcount=0}return bless {short=>$short,long=>$long,argcount=>$argcount,value=>!defined($value)&& $argcount ? undef : $value,},$class}sub value {my$self=shift;return$self->{value}if @_==0;if (@_==1){$self->{value}=$_[0]}else {Carp::confess("Too much arguments")}}sub single_match {my ($self,$left)=@_;ref$left eq 'ARRAY' or die;for (my$n=0;$n<@$left;$n++){my$pattern=$left->[$n];if ($self->name eq defined_or($pattern->name,'')){return ($n,$pattern)}}return (undef,undef)}sub name {my$self=shift;if (defined($self->long)&&!ref($self->long)){$self->long}else {$self->short}}sub parse {my ($class,$option_description)=@_;my ($short,$long,$argcount,$value)=(undef,undef,0,undef);my ($options,undef,$description)=string_partition(string_strip($option_description),'  ');$options =~ s/,/ /g;$options =~ s/=/ /g;for my$s (split /\s+/,$options){if ($s =~ /^--/){$long=$s}elsif ($s =~ /^-/){$short=$s}else {$argcount=1}}if ($argcount){if (defined($description)&& $description =~ /\[default: (.*)\]/i){$value=$1}}return$class->new($short,$long,$argcount,$value)}sub __repl__ {my ($self)=@_;sprintf 'Option(%s, %s, %s, %s)',repl($self->{short}),repl($self->{long}),repl($self->{argcount}),repl($self->{value})}package Docopt;use boolean;sub parse_long {my ($tokens,$options)=@_;ref($options)eq 'ARRAY' or Carp::confess "Options must be arrayref";my ($long,$eq,$value)=string_partition($tokens->move,'=');$long =~ /\A--/ or die;$value=$eq eq '' && $value eq '' ? undef : $value;my@similar=grep {$_->long && $_->long eq $long}@$options;if ($tokens->error eq 'Docopt::Exceptions::DocoptExit' && @similar==0){@similar=grep {$_->long && $_->long =~ /$long/}@$options}my$o;if (@similar > 1){$tokens->error->throw(sprintf '%s is not a unique prefix: %s?',$long,join(', ',map {$_->long}@similar))}elsif (@similar < 1){my$argcount=$eq eq '=' ? 1 : 0;$o=Docopt::Option->new(undef,$long,$argcount);push @$options,$o;if ($tokens->error eq 'Docopt::Exceptions::DocoptExit'){$o=Docopt::Option->new(undef,$long,$argcount,$argcount ? $value : true)}}else {$o=Docopt::Option->new($similar[0]->short,$similar[0]->long,$similar[0]->argcount,$similar[0]->value,);if ($o->argcount==0){if (defined$value){$tokens->error->throw(sprintf "%s must not have an argument",$o->long)}}else {if (not defined$value){if ((not defined$tokens->current())|| $tokens->current eq '--'){$tokens->error->throw(sprintf "%s requires argument",$o->long)}$value=$tokens->move}}if ($tokens->error eq 'Docopt::Exceptions::DocoptExit'){$o->value(defined($value)? $value : true)}}return [$o]}sub parse_shorts {my ($tokens,$options)=@_;my$token=$tokens->move;(my$left=$token)=~ s/^-//;my@parsed;while ($left ne ''){my$o;$left =~ s/\A(.)//;my$short='-' .$1;my@similar=grep {defined_or($_->short,'')eq $short}@$options;if (@similar > 1){$tokens->error->throw(sprintf "%s is specified ambiguously %d times",$short,0+@similar)}elsif (@similar < 1){$o=Docopt::Option->new($short,undef,0);push @$options,$o;if ($tokens->error eq 'Docopt::Exceptions::DocoptExit'){$o=Docopt::Option->new($short,undef,0,undef)}}else {$o=Docopt::Option->new($short,$similar[0]->long,$similar[0]->argcount,$similar[0]->value);my$value=undef;if ($o->argcount!=0){if ($left eq ''){if (!defined($tokens->current)|| $tokens->current eq '--'){$tokens->error->throw("$short requires argument")}$value=$tokens->move}else {$value=$left;$left=''}}if ($tokens->error eq 'Docopt::Exceptions::DocoptExit'){$o->value(defined($value)? $value : true)}}push@parsed,$o}return \@parsed}use Docopt::Util qw(repl);sub parse_pattern {my ($source,$options)=@_;my$tokens=Docopt::Tokens->from_pattern($source);my$result=parse_expr($tokens,$options);if (defined$tokens->current()){$tokens->error->throw("unexpected ending: " .repl(join(' ',$tokens)))}return Docopt::Required->new($result)}sub parse_expr {my ($tokens,$options)=@_;my$seq=parse_seq($tokens,$options);if (!defined($tokens->current)|| $tokens->current ne '|'){return$seq}my@result=@$seq > 1 ? Docopt::Required->new($seq): @$seq;while (defined($tokens->current)&& $tokens->current eq '|'){$tokens->move();$seq=parse_seq($tokens,$options);push@result,@$seq > 1 ? Docopt::Required->new($seq): @$seq}return@result > 1 ? [Docopt::Either->new([map {ref($_)eq 'ARRAY' ? @$_ : $_}@result])]: \@result}sub parse_seq {my ($tokens,$options)=@_;my@result;while (not in($tokens->current,[undef,']',')','|'])){my$atom=parse_atom($tokens,$options);if (defined($tokens->current)&& $tokens->current eq '...'){$atom=Docopt::OneOrMore->new($atom);$tokens->move}push@result,$atom}return [map {ref($_)eq 'ARRAY' ? @$_ : $_}@result]}sub parse_atom {my ($tokens,$options)=@_;my$token=$tokens->current();my@result;if ($token eq '(' || $token eq '['){$tokens->move;my ($matching,$pattern)=@{{'('=>[')',Docopt::Required::],'['=>[']',Docopt::Optional::]}->{$token}};my$expr=parse_expr($tokens,$options);my$result=$pattern->new($expr);if (($tokens->move ||'')ne $matching){Docopt::Exceptions::DocoptLanguageError->throw("unmatched '$token'")}return [$result]}elsif ($token eq 'options'){$tokens->move;return [Docopt::OptionsShortcut->new([])]}elsif ($token =~ /^--/ && $token ne '--'){return parse_long($tokens,$options)}elsif ($token =~ /^-/ && ($token ne '-' && $token ne '--')){return parse_shorts($tokens,$options)}elsif (($token =~ /^</ && $token =~ />$/)or $token =~ /\A[A-Z]+\z/){return [Docopt::Argument->new($tokens->move)]}else {return [Docopt::Command->new($tokens->move)]}}sub parse_argv {my ($tokens,$options,$options_first)=@_;ref($options)eq 'ARRAY' or Carp::confess "Options must be arrayref";my@parsed;while (defined$tokens->current()){if ($tokens->current()eq '--'){return [@parsed,map {Docopt::Argument->new(undef,$_)}@{$tokens->source}]}elsif ($tokens->current()=~ /\A--/){push@parsed,@{parse_long($tokens,$options)}}elsif ($tokens->current()=~ /\A-/ && $tokens->current ne '-'){push@parsed,@{parse_shorts($tokens,$options)}}elsif ($options_first){return [@parsed,map {Docopt::Argument->new(undef,$_)}@{$tokens->source}]}else {push@parsed,Docopt::Argument->new(undef,$tokens->move)}}return \@parsed}sub parse_defaults {my ($doc)=@_;my@defaults;for my$s (parse_section('options:',$doc)){(undef,undef,$s)=string_partition($s,':');my@split=split /\n *(-\S+?)/,"\n" .$s;shift@split;my@split2;for (my$i=0;$i<@split;$i+=2){push@split2,$split[$i].defined_or($split[$i+1],'')}for my$s (grep /^-/,@split2){push@defaults,Docopt::Option->parse($s)}}return@defaults}sub parse_section {my ($name,$source)=@_;defined($source)or Carp::confess("Missing source");my@s;while ($source =~ /^([^\n]*${name}[^\n]*\n?(?:[ \t].*?(?:\n|$))*)/img){local $_=$1;s/\A\s+//;s/\s+\z//;push@s,$_}return@s}sub formal_usage {my ($section)=@_;(undef,undef,$section)=string_partition($section,':');my@pu=grep {/\S/}split /\s+/,$section;my$cmd=shift@pu;return '( ' .join(' ',map {$_ eq $cmd ? ') | (' : $_}@pu).' )'}use List::MoreUtils qw(any);sub extras {my ($help,$version,$options,$doc)=@_;if ($help && any {in($_->name,['-h','--help'])&& $_->value}@$options){print$doc ."\n";exit(0)}if ($version && grep {defined($_->name)&& $_->name eq '--version'}@$options){print "$version\n";exit(0)}}sub docopt {@_%2==0 or Carp::confess("You need to pass arguments are hash");my%args=@_;my$doc=delete$args{doc};my$argv=delete$args{argv}|| \@ARGV;my$help=exists($args{help})? delete$args{help}: true;my$version=delete$args{version};my$option_first=delete$args{option_first};if (%args){Carp::confess("Unknown argument passed to docopt(): " .join(", ",keys%args))}if (not defined$doc){require Pod::Usage;open my$fh,'>',\$doc or die $!;my$parser=Pod::Usage->new(USAGE_OPTIONS=>+{});$parser->select('(?:SYNOPSIS|USAGE)\s*');$parser->parse_from_file($0,$fh)}my@usage_sections=parse_section('usage:',$doc);if (@usage_sections==0){Docopt::Exceptions::DocoptLanguageError->throw('"usage:" (case-insensitive) not found.')}if (@usage_sections > 1){Docopt::Exceptions::DocoptLanguageError->throw('More than one "usage:" (case-insensitive).')}$Docopt::Exceptions::DocoptExit::USAGE=$usage_sections[0];my$options=[parse_defaults($doc)];my$pattern=parse_pattern(formal_usage($usage_sections[0]),$options);$argv=parse_argv(Docopt::Tokens->new($argv),$options,$option_first);my$parse_options=$pattern->flat(Docopt::Option::);for my$options_shortcut (@{$pattern->flat(Docopt::OptionsShortcut::)}){my@doc_options=parse_defaults($doc);$options_shortcut->children([grep {!in(serialize($_),[map {serialize($_)}@$parse_options])}@doc_options])}extras($help,$version,$argv,$doc);my ($matched,$left,$collected)=$pattern->fix->match($argv);if ($matched && serialize($left)eq serialize([])){return +{map {$_->name=>$_->value}@{$pattern->flat},@$collected }}Docopt::Exceptions::DocoptExit->throw()}package Docopt::Exception;use overload (q{""}=>'stringify',);sub stringify {my$self=shift;sprintf "[%s] %s",ref$self,$self->{message}|| 'Died'}sub new {my ($class,$message)=@_;bless {message=>$message},$class}sub throw {my ($class,$message)=@_;die$class->new($message)}package Docopt::Exceptions::DocoptLanguageError;use parent -norequire,qw(Docopt::Exception);package Docopt::Exceptions::DocoptExit;use parent -norequire,qw(Docopt::Exception);our$USAGE;sub stringify {my$self=shift;sprintf "%s\n%s\n",$self->{message}|| '',$USAGE}1;
DOCOPT

$fatpacked{"Docopt/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DOCOPT_UTIL';
  package Docopt::Util;use strict;use warnings;use utf8;use parent qw(Exporter);use boolean;our@EXPORT_OK=qw(repl class_name string_strip string_partition in True False is_number defined_or serialize pyprint);sub True() {true}sub False() {false}use Data::Dumper;use Scalar::Util ();use Storable ();use B;sub pyprint {print Docopt::Util::repl($_[0]),$/}sub serialize($) {local$Storable::canonical=1;return Storable::nfreeze($_[0])}sub is_number {my$value=shift;my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK | B::SVp_NOK)and!($flags & B::SVp_POK);return 0}sub in {my ($val,$patterns)=@_;for (@$patterns){if (defined $_){return 0 if not defined$val;return 1 if$val eq $_}else {return 1 if not defined$val}}return 0}sub repl($) {my ($val)=@_;if (Scalar::Util::blessed($val)&& $val->can('__repl__')){$val->__repl__}elsif ((Scalar::Util::blessed($val)||'')eq 'boolean'){$val ? 'True' : 'False'}elsif (ref($val)eq 'ARRAY'){return '[' .join(', ',map {&repl($_)}@$val).']'}else {local$Data::Dumper::Terse=1;local$Data::Dumper::Indent=0;local$Data::Dumper::Useqq=1;Dumper($val)}}sub class_name {my$name=ref $_[0]|| $_[0];$name =~ s/^Docopt:://;$name}sub string_strip($) {local $_=shift;s/^\s+//;s/\s+$//;$_}sub string_partition($$) {my ($str,$sep)=@_;if ($str =~ /\A(.*?)$sep(.*)\z/s){return ($1,$sep,$2)}else {return ($str,'','')}}sub defined_or {defined($_[0])? $_[0]: $_[1]}1;
DOCOPT_UTIL

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;use 5.006001;use strict;use warnings;use Exporter::Tiny ();our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.03';sub import {my$me=shift;my$caller=caller;(my$nominal_file=$caller)=~ s(::)(/)g;$INC{"$nominal_file\.pm"}||= __FILE__;if (@_==2 and $_[0]eq -setup){my (undef,$opts)=@_;@_=@{delete($opts->{exports})|| []};if (%$opts){Exporter::Tiny::_croak('Unsupported Sub::Exporter-style options: %s',join(q[, ],sort keys %$opts),)}}ref($_)&& Exporter::Tiny::_croak('Expected sub name, got ref %s',$_)for @_;no strict qw(refs);push @{"$caller\::ISA"},'Exporter::Tiny';push @{"$caller\::EXPORT_OK"},@_}1;
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;use 5.006001;use strict;use warnings;no warnings qw(void once uninitialized numeric redefine);our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.03';our@EXPORT_OK=qw<mkopt mkopt_hash _croak _carp>;sub _croak ($;@) {require Carp;my$fmt=shift;@_=sprintf($fmt,@_);goto \&Carp::croak}sub _carp ($;@) {require Carp;my$fmt=shift;@_=sprintf($fmt,@_);goto \&Carp::carp}my$_process_optlist=sub {my$class=shift;my ($global_opts,$opts,$want,$not_want)=@_;while (@$opts){my$opt=shift @{$opts};my ($name,$value)=@$opt;($name =~ m{\A\!(/.+/[msixpodual]+)\z})? do {my@not=$class->_exporter_expand_regexp($1,$value,$global_opts);++$not_want->{$_->[0]}for@not}: ($name =~ m{\A\!(.+)\z})? (++$not_want->{$1}): ($name =~ m{\A[:-](.+)\z})? push(@$opts,$class->_exporter_expand_tag($1,$value,$global_opts)): ($name =~ m{\A/.+/[msixpodual]+\z})? push(@$opts,$class->_exporter_expand_regexp($name,$value,$global_opts)): push(@$want,$opt)}};sub import {my$class=shift;my$global_opts=+{@_ && ref($_[0])eq q(HASH) ? %{+shift}: ()};$global_opts->{into}=caller unless exists$global_opts->{into};my@want;my%not_want;$global_opts->{not}=\%not_want;my@args=do {no strict qw(refs);@_ ? @_ : @{"$class\::EXPORT"}};my$opts=mkopt(\@args);$class->$_process_optlist($global_opts,$opts,\@want,\%not_want);my$permitted=$class->_exporter_permitted_regexp($global_opts);$class->_exporter_validate_opts($global_opts);for my$wanted (@want){next if$not_want{$wanted->[0]};my%symbols=$class->_exporter_expand_sub(@$wanted,$global_opts,$permitted);$class->_exporter_install_sub($_,$wanted->[1],$global_opts,$symbols{$_})for keys%symbols}}sub unimport {my$class=shift;my$global_opts=+{@_ && ref($_[0])eq q(HASH) ? %{+shift}: ()};$global_opts->{into}=caller unless exists$global_opts->{into};$global_opts->{is_unimport}=1;my@want;my%not_want;$global_opts->{not}=\%not_want;my@args=do {our%TRACKED;@_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}})};my$opts=mkopt(\@args);$class->$_process_optlist($global_opts,$opts,\@want,\%not_want);my$permitted=$class->_exporter_permitted_regexp($global_opts);$class->_exporter_validate_unimport_opts($global_opts);my$expando=$class->can('_exporter_expand_sub');$expando=undef if$expando==\&_exporter_expand_sub;for my$wanted (@want){next if$not_want{$wanted->[0]};if ($wanted->[1]){_carp("Passing options to unimport '%s' makes no sense",$wanted->[0])unless (ref($wanted->[1])eq 'HASH' and not keys %{$wanted->[1]})}my%symbols=defined($expando)? $class->$expando(@$wanted,$global_opts,$permitted): ($wanted->[0]=>sub {"dummy"});$class->_exporter_uninstall_sub($_,$wanted->[1],$global_opts)for keys%symbols}}sub _exporter_validate_opts {1}sub _exporter_validate_unimport_opts {1}sub _exporter_merge_opts {my$class=shift;my ($tag_opts,$global_opts,@stuff)=@_;$tag_opts={}unless ref($tag_opts)eq q(HASH);_croak('Cannot provide an -as option for tags')if exists$tag_opts->{-as};my$optlist=mkopt(\@stuff);for my$export (@$optlist){next if defined($export->[1])&& ref($export->[1])ne q(HASH);my%sub_opts=(%{$export->[1]or {}},%$tag_opts);$sub_opts{-prefix}=sprintf('%s%s',$tag_opts->{-prefix},$export->[1]{-prefix})if exists($export->[1]{-prefix})&& exists($tag_opts->{-prefix});$sub_opts{-suffix}=sprintf('%s%s',$export->[1]{-suffix},$tag_opts->{-suffix})if exists($export->[1]{-suffix})&& exists($tag_opts->{-suffix});$export->[1]=\%sub_opts}return @$optlist}sub _exporter_expand_tag {no strict qw(refs);my$class=shift;my ($name,$value,$globals)=@_;my$tags=\%{"$class\::EXPORT_TAGS"};return$class->_exporter_merge_opts($value,$globals,$tags->{$name}->($class,@_))if ref($tags->{$name})eq q(CODE);return$class->_exporter_merge_opts($value,$globals,@{$tags->{$name}})if exists$tags->{$name};return$class->_exporter_merge_opts($value,$globals,@{"$class\::EXPORT"},@{"$class\::EXPORT_OK"})if$name eq 'all';return$class->_exporter_merge_opts($value,$globals,@{"$class\::EXPORT"})if$name eq 'default';$globals->{$name}=$value || 1;return}sub _exporter_expand_regexp {no strict qw(refs);our%TRACKED;my$class=shift;my ($name,$value,$globals)=@_;my$compiled=eval("qr$name");my@possible=$globals->{is_unimport}? keys(%{$TRACKED{$class}{$globals->{into}}}): @{"$class\::EXPORT_OK"};$class->_exporter_merge_opts($value,$globals,grep /$compiled/,@possible)}sub _exporter_permitted_regexp {no strict qw(refs);my$class=shift;my$re=join "|",map quotemeta,sort {length($b)<=> length($a)or $a cmp $b}@{"$class\::EXPORT"},@{"$class\::EXPORT_OK"};qr{^(?:$re)$}ms}sub _exporter_expand_sub {my$class=shift;my ($name,$value,$globals,$permitted)=@_;$permitted ||= $class->_exporter_permitted_regexp($globals);no strict qw(refs);if ($name =~ $permitted){my$generator=$class->can("_generate_$name");return$name=>$class->$generator($name,$value,$globals)if$generator;my$sub=$class->can($name);return$name=>$sub if$sub}$class->_exporter_fail(@_)}sub _exporter_fail {my$class=shift;my ($name,$value,$globals)=@_;return if$globals->{is_unimport};_croak("Could not find sub '%s' exported by %s",$name,$class)}sub _exporter_install_sub {my$class=shift;my ($name,$value,$globals,$sym)=@_;my$into=$globals->{into};my$installer=$globals->{installer}|| $globals->{exporter};$name=$value->{-as}|| $name;unless (ref($name)eq q(SCALAR)){my ($prefix)=grep defined,$value->{-prefix},$globals->{prefix},q();my ($suffix)=grep defined,$value->{-suffix},$globals->{suffix},q();$name="$prefix$name$suffix"}return ($$name=$sym)if ref($name)eq q(SCALAR);return ($into->{$name}=$sym)if ref($into)eq q(HASH);no strict qw(refs);if (exists &{"$into\::$name"}and \&{"$into\::$name"}!=$sym){my ($level)=grep defined,$value->{-replace},$globals->{replace},q(0);my$action={carp=>\&_carp,0=>\&_carp,''=>\&_carp,warn=>\&_carp,nonfatal=>\&_carp,croak=>\&_croak,fatal=>\&_croak,die=>\&_croak,}->{$level}|| sub {};$action->($action==\&_croak ? "Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s" : "Overwriting existing sub '%s::%s' with sub '%s' exported by %s",$into,$name,$_[0],$class,)}our%TRACKED;$TRACKED{$class}{$into}{$name}=$sym;no warnings qw(prototype);$installer ? $installer->($globals,[$name,$sym]): (*{"$into\::$name"}=$sym)}sub _exporter_uninstall_sub {our%TRACKED;my$class=shift;my ($name,$value,$globals,$sym)=@_;my$into=$globals->{into};ref$into and return;no strict qw(refs);my$our_coderef=$TRACKED{$class}{$into}{$name};my$cur_coderef=exists(&{"$into\::$name"})? \&{"$into\::$name"}: -1;return unless$our_coderef==$cur_coderef;my$stash=\%{"$into\::"};my$old=delete$stash->{$name};my$full_name=join('::',$into,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});*$full_name=*{$old}{$type}}delete$TRACKED{$class}{$into}{$name}}sub mkopt {my$in=shift or return [];my@out;$in=[map(($_=>ref($in->{$_})? $in->{$_}: ()),sort keys %$in)]if ref($in)eq q(HASH);for (my$i=0;$i < @$in;$i++){my$k=$in->[$i];my$v;($i==$#$in)? ($v=undef): !defined($in->[$i+1])? (++$i,($v=undef)): !ref($in->[$i+1])? ($v=undef): ($v=$in->[++$i]);push@out,[$k=>$v ]}\@out}sub mkopt_hash {my$in=shift or return;my%out=map +($_->[0]=>$_->[1]),@{mkopt($in)};\%out}1;
EXPORTER_TINY

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.03';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.03';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.03';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.03';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.03';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.03';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,blib=>'blib',create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my (%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"List/MoreUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS';
  package List::MoreUtils;use 5.006;use strict;use warnings;BEGIN {our$VERSION='0.03';eval {require List::MoreUtils::XS}unless$ENV{LIST_MOREUTILS_PP};use List::MoreUtils::PP qw()}use Exporter::Tiny qw();my@junctions=qw(any all none notall);my@v0_22=qw(true false firstidx lastidx insert_after insert_after_string apply indexes after after_incl before before_incl firstval lastval each_array each_arrayref pairwise natatime mesh uniq minmax part _XScompiled);my@v0_24=qw(bsearch);my@v0_33=qw(sort_by nsort_by);my@v0_400=qw(one any_u all_u none_u notall_u one_u firstres onlyidx onlyval onlyres lastres singleton bsearchidx);my@all_functions=(@junctions,@v0_22,@v0_24,@v0_33,@v0_400);no strict "refs";List::MoreUtils->can($_)or *$_=List::MoreUtils::PP->can($_)for(@all_functions);use strict;my%alias_list=(v0_22=>{first_index=>"firstidx",last_index=>"lastidx",first_value=>"firstval",last_value=>"lastval",zip=>"mesh",},v0_33=>{distinct=>"uniq",},v0_400=>{first_result=>"firstres",only_index=>"onlyidx",only_value=>"onlyval",only_result=>"onlyres",last_result=>"lastres",bsearch_index=>"bsearchidx",},);our@ISA=qw(Exporter::Tiny);our@EXPORT_OK=(@all_functions,map {keys %$_}values%alias_list);our%EXPORT_TAGS=(all=>\@EXPORT_OK,'like_0.22'=>[any_u=>{-as=>'any' },all_u=>{-as=>'all' },none_u=>{-as=>'none' },notall_u=>{-as=>'notall' },@v0_22,keys %{$alias_list{v0_22}},],'like_0.24'=>[any_u=>{-as=>'any' },all_u=>{-as=>'all' },notall_u=>{-as=>'notall' },'none',@v0_22,@v0_24,keys %{$alias_list{v0_22}},],'like_0.33'=>[@junctions,@v0_22,@v0_33,keys %{$alias_list{v0_22}},keys %{$alias_list{v0_33}},],);for my$set (values%alias_list){for my$alias (keys %$set){no strict qw(refs);*$alias=__PACKAGE__->can($set->{$alias})}}1;
LIST_MOREUTILS

$fatpacked{"List/MoreUtils/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS_PP';
  package List::MoreUtils::PP;use 5.006;use strict;use warnings;our$VERSION='0.03';sub any (&@) {my$f=shift;for (@_){return 1 if$f->()}return 0}sub all (&@) {my$f=shift;for (@_){return 0 unless$f->()}return 1}sub none (&@) {my$f=shift;for (@_){return 0 if$f->()}return 1}sub notall (&@) {my$f=shift;for (@_){return 1 unless$f->()}return 0}sub one (&@) {my$f=shift;my$found=0;for (@_){$f->()and $found++ and return 0}$found}sub any_u (&@) {my$f=shift;return if!@_;$f->()and return 1 foreach (@_);return 0}sub all_u (&@) {my$f=shift;return if!@_;$f->()or return 0 foreach (@_);return 1}sub none_u (&@) {my$f=shift;return if!@_;$f->()and return 0 foreach (@_);return 1}sub notall_u (&@) {my$f=shift;return if!@_;$f->()or return 1 foreach (@_);return 0}sub one_u (&@) {my$f=shift;return if!@_;my$found=0;for (@_){$f->()and $found++ and return 0}$found}sub true (&@) {my$f=shift;my$count=0;$f->()and ++$count foreach (@_);return$count}sub false (&@) {my$f=shift;my$count=0;$f->()or ++$count foreach (@_);return$count}sub firstidx (&@) {my$f=shift;for my$i (0 .. $#_){local*_=\$_[$i];return$i if$f->()}return -1}sub firstval (&@) {my$test=shift;for (@_){return $_ if$test->()}return undef}sub firstres (&@) {my$test=shift;for (@_){my$testval=$test->();$testval and return$testval}return undef}sub onlyidx (&@) {my$f=shift;my$found;for my$i (0 .. $#_){local*_=\$_[$i];$f->()or next;defined$found and return -1;$found=$i}return defined$found ? $found : -1}sub onlyval (&@) {my$test=shift;my$result=undef;my$found=0;for (@_){$test->()or next;$result=$_;$found++ and return undef}return$result}sub onlyres (&@) {my$test=shift;my$result=undef;my$found=0;for (@_){my$rv=$test->()or next;$result=$rv;$found++ and return undef}return$found ? $result : undef}sub lastidx (&@) {my$f=shift;for my$i (reverse 0 .. $#_){local*_=\$_[$i];return$i if$f->()}return -1}sub lastval (&@) {my$test=shift;my$ix;for ($ix=$#_;$ix >= 0;$ix-- ){local*_=\$_[$ix];my$testval=$test->();$_[$ix]=$_;return $_ if$testval}return undef}sub lastres (&@) {my$test=shift;my$ix;for ($ix=$#_;$ix >= 0;$ix-- ){local*_=\$_[$ix];my$testval=$test->();$_[$ix]=$_;return$testval if$testval}return undef}sub insert_after (&$\@) {my ($f,$val,$list)=@_;my$c=&firstidx($f,@$list);@$list=(@{$list}[0 .. $c ],$val,@{$list}[$c + 1 .. $#$list ],)and return 1 if$c!=-1;return 0}sub insert_after_string ($$\@) {my ($string,$val,$list)=@_;my$c=firstidx {defined $_ and $string eq $_}@$list;@$list=(@{$list}[0 .. $c ],$val,@{$list}[$c + 1 .. $#$list ],)and return 1 if$c!=-1;return 0}sub apply (&@) {my$action=shift;&$action foreach my@values=@_;wantarray ? @values : $values[-1]}sub after (&@) {my$test=shift;my$started;my$lag;grep$started ||= do {my$x=$lag;$lag=$test->();$x},@_}sub after_incl (&@) {my$test=shift;my$started;grep$started ||= $test->(),@_}sub before (&@) {my$test=shift;my$more=1;grep$more &&=!$test->(),@_}sub before_incl (&@) {my$test=shift;my$more=1;my$lag=1;grep$more &&= do {my$x=$lag;$lag=!$test->();$x},@_}sub indexes (&@) {my$test=shift;grep {local*_=\$_[$_];$test->()}0 .. $#_}sub pairwise (&\@\@) {my$op=shift;use vars qw{@A @B};local (*A,*B)=@_;my ($caller_a,$caller_b)=do {my$pkg=caller();no strict 'refs';\*{$pkg .'::a'},\*{$pkg .'::b'}};my$limit=$#A > $#B ? $#A : $#B;local (*$caller_a,*$caller_b);map {(*$caller_a,*$caller_b)=\($A[$_],$B[$_]);$op->()}0 .. $limit}sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {return each_arrayref(@_)}sub each_arrayref {my@list=@_;my$index=0;my$max=0;for (@list){unless (ref $_ eq 'ARRAY'){require Carp;Carp::croak("each_arrayref: argument is not an array reference\n")}$max=@$_ if @$_ > $max}return sub {if (@_){my$method=shift;unless ($method eq 'index'){require Carp;Carp::croak("each_array: unknown argument '$method' passed to iterator.")}return undef if$index==0 || $index > $max;return$index - 1}return if$index >= $max;my$i=$index++;return map $_->[$i],@list}}sub natatime ($@) {my$n=shift;my@list=@_;return sub {return splice@list,0,$n}}sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {my$max=-1;$max < $#$_ && ($max=$#$_)foreach @_;map {my$ix=$_;map $_->[$ix],@_}0 .. $max}sub uniq (@) {my%seen=();my$k;my$seen_undef;grep {defined $_ ? not $seen{$k=$_ }++ : not $seen_undef++}@_}sub singleton (@) {my%seen=();my$k;my$seen_undef;grep {1==(defined $_ ? $seen{$k=$_ }: $seen_undef)}grep {defined $_ ? not $seen{$k=$_ }++ : not $seen_undef++}@_}sub minmax (@) {return unless @_;my$min=my$max=$_[0];for (my$i=1;$i < @_;$i += 2 ){if ($_[$i - 1 ]<= $_[$i]){$min=$_[$i - 1 ]if$min > $_[$i - 1 ];$max=$_[$i]if$max < $_[$i]}else {$min=$_[$i]if$min > $_[$i];$max=$_[$i - 1 ]if$max < $_[$i - 1 ]}}if (@_ & 1){my$i=$#_;if ($_[$i - 1 ]<= $_[$i]){$min=$_[$i - 1 ]if$min > $_[$i - 1 ];$max=$_[$i]if$max < $_[$i]}else {$min=$_[$i]if$min > $_[$i];$max=$_[$i - 1 ]if$max < $_[$i - 1 ]}}return ($min,$max)}sub part (&@) {my ($code,@list)=@_;my@parts;push @{$parts[$code->($_)]},$_ foreach@list;return@parts}sub bsearch(&@) {my$code=shift;my$rc;my$i=0;my$j=@_;do {my$k=int(($i + $j)/ 2);$k >= @_ and return;local*_=\$_[$k];$rc=$code->();$rc==0 and return wantarray ? $_ : 1;if ($rc < 0){$i=$k + 1}else {$j=$k - 1}}until$i > $j;return}sub bsearchidx(&@) {my$code=shift;my$rc;my$i=0;my$j=@_;do {my$k=int(($i + $j)/ 2);$k >= @_ and return -1;local*_=\$_[$k];$rc=$code->();$rc==0 and return$k;if ($rc < 0){$i=$k + 1}else {$j=$k - 1}}until$i > $j;return -1}sub sort_by(&@) {my ($code,@list)=@_;return map {$_->[0]}sort {$a->[1]cmp $b->[1]}map {[$_,scalar($code->())]}@list}sub nsort_by(&@) {my ($code,@list)=@_;return map {$_->[0]}sort {$a->[1]<=> $b->[1]}map {[$_,scalar($code->())]}@list}sub _XScompiled {0}1;
LIST_MOREUTILS_PP

$fatpacked{"List/MoreUtils/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS_XS';
  package List::MoreUtils::XS;use 5.006;use strict;use warnings;use vars qw{$VERSION @ISA};$VERSION='0.03';local$ENV{PERL_DL_NONLAZY}=0 if$ENV{PERL_DL_NONLAZY};use XSLoader ();XSLoader::load("List::MoreUtils","$VERSION");1;
LIST_MOREUTILS_XS

$fatpacked{"Module/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD';
  package Module::Build;use if $] >= 5.019,'deprecate';use 5.006;use strict;use warnings;use File::Spec ();use File::Path ();use File::Basename ();use Perl::OSType ();use Module::Build::Base;our@ISA=qw(Module::Build::Base);our$VERSION='0.03';$VERSION=eval$VERSION;sub _interpose_module {my ($self,$mod)=@_;eval "use $mod";die $@ if $@;no strict 'refs';my$top_class=$mod;while (@{"${top_class}::ISA"}){last if ${"${top_class}::ISA"}[0]eq $ISA[0];$top_class=${"${top_class}::ISA"}[0]}@{"${top_class}::ISA"}=@ISA;@ISA=($mod)}if (grep {-e File::Spec->catfile($_,qw(Module Build Platform),$^O).'.pm'}@INC){__PACKAGE__->_interpose_module("Module::Build::Platform::$^O")}elsif (my$ostype=os_type()){__PACKAGE__->_interpose_module("Module::Build::Platform::$ostype")}else {warn "Unknown OS type '$^O' - using default settings\n"}sub os_type {return Perl::OSType::os_type()}sub is_vmsish {return Perl::OSType::is_os_type('VMS')}sub is_windowsish {return Perl::OSType::is_os_type('Windows')}sub is_unixish {return Perl::OSType::is_os_type('Unix')}1;
MODULE_BUILD

$fatpacked{"Module/Build/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_BASE';
  package Module::Build::Base;use 5.006;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Carp;use Cwd ();use File::Copy ();use File::Find ();use File::Path ();use File::Basename ();use File::Spec 0.82 ();use File::Compare ();use Module::Build::Dumper ();use Text::ParseWords ();use Module::Metadata;use Module::Build::Notes;use Module::Build::Config;use version;sub new {my$self=shift()->_construct(@_);$self->{invoked_action}=$self->{action}||= 'Build_PL';$self->cull_args(@ARGV);die "Too early to specify a build action '$self->{action}'.  Do 'Build $self->{action}' instead.\n" if$self->{action}&& $self->{action}ne 'Build_PL';$self->check_manifest;$self->auto_require;if(grep {!$_}$self->check_prereq,$self->check_autofeatures){$self->log_warn(<<EOF);unless ($self->dist_name eq 'Module-Build' || $ENV{PERL5_CPANPLUS_IS_RUNNING}|| $ENV{PERL5_CPAN_IS_RUNNING}){$self->log_warn("Run 'Build installdeps' to install missing prerequisites.\n\n")}}$self->{properties}{_added_to_INC}=[$self->_added_to_INC ];$self->set_bundle_inc;$self->dist_name;$self->dist_version;$self->release_status;$self->_guess_module_name unless$self->module_name;$self->_find_nested_builds;return$self}sub resume {my$package=shift;my$self=$package->_construct(@_);$self->read_config;my@added_earlier=@{$self->{properties}{_added_to_INC}|| []};@INC=($self->_added_to_INC,@added_earlier,$self->_default_INC);unless ($package->isa($self->build_class)){my$build_class=$self->build_class;my$config_dir=$self->config_dir || '_build';my$build_lib=File::Spec->catdir($config_dir,'lib');unshift(@INC,$build_lib);unless ($build_class->can('new')){eval "require $build_class; 1" or die "Failed to re-load '$build_class': $@"}return$build_class->resume(@_)}unless ($self->_perl_is_same($self->{properties}{perl})){my$perl=$self->find_perl_interpreter;die(<<"DIEFATAL")}$self->cull_args(@ARGV);unless ($self->allow_mb_mismatch){my$mb_version=$Module::Build::VERSION;if ($mb_version ne $self->{properties}{mb_version}){$self->log_warn(<<"MISMATCH")}}$self->{invoked_action}=$self->{action}||= 'build';return$self}sub new_from_context {my ($package,%args)=@_;$package->run_perl_script('Build.PL',[],[$package->unparse_args(\%args)]);return$package->resume}sub current {local@ARGV;return shift()->resume}sub _construct {my ($package,%input)=@_;my$args=delete$input{args}|| {};my$config=delete$input{config}|| {};my$self=bless {args=>{%$args},config=>Module::Build::Config->new(values=>$config),properties=>{base_dir=>$package->cwd,mb_version=>$Module::Build::VERSION,%input,},phash=>{},stash=>{},},$package;$self->_set_defaults;my ($p,$ph)=($self->{properties},$self->{phash});for (qw(notes config_data features runtime_params cleanup auto_features)){my$file=File::Spec->catfile($self->config_dir,$_);$ph->{$_}=Module::Build::Notes->new(file=>$file);$ph->{$_}->restore if -e $file;if (exists$p->{$_}){my$vals=delete$p->{$_};for my$k (sort keys %$vals){$self->$_($k,$vals->{$k})}}}$p->{perl}=$self->find_perl_interpreter or $self->log_warn("Warning: Can't locate your perl binary");my$blibdir=sub {File::Spec->catdir($p->{blib},@_)};$p->{bindoc_dirs}||= [$blibdir->("script")];$p->{libdoc_dirs}||= [$blibdir->("lib"),$blibdir->("arch")];$p->{dist_author}=[$p->{dist_author}]if defined$p->{dist_author}and not ref$p->{dist_author};$p->{requires}=delete$p->{prereq}if defined$p->{prereq};$p->{script_files}=delete$p->{scripts}if defined$p->{scripts};for ('extra_compiler_flags','extra_linker_flags'){$p->{$_}=[$self->split_like_shell($p->{$_})]if exists$p->{$_}}for ('include_dirs'){$p->{$_}=[$p->{$_}]if exists$p->{$_}&&!ref$p->{$_}}$self->add_to_cleanup(@{delete$p->{add_to_cleanup}})if$p->{add_to_cleanup};return$self}sub log_info {my$self=shift;print @_ if ref($self)&& ($self->verbose ||!$self->quiet)}sub log_verbose {my$self=shift;print @_ if ref($self)&& $self->verbose}sub log_debug {my$self=shift;print @_ if ref($self)&& $self->debug}sub log_warn {shift;if (@_ and $_[-1]!~ /\n$/){my (undef,$file,$line)=caller();warn @_," at $file line $line.\n"}else {warn @_}}sub _default_install_paths {my$self=shift;my$c=$self->{config};my$p={};my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');my$bindoc=$c->get('installman1dir')|| undef;my$libdoc=$c->get('installman3dir')|| undef;my$binhtml=$c->get('installhtml1dir')|| $c->get('installhtmldir')|| undef;my$libhtml=$c->get('installhtml3dir')|| $c->get('installhtmldir')|| undef;$p->{install_sets}={core=>{lib=>$c->get('installprivlib'),arch=>$c->get('installarchlib'),bin=>$c->get('installbin'),script=>$c->get('installscript'),bindoc=>$bindoc,libdoc=>$libdoc,binhtml=>$binhtml,libhtml=>$libhtml,},site=>{lib=>$c->get('installsitelib'),arch=>$c->get('installsitearch'),bin=>$c->get('installsitebin')|| $c->get('installbin'),script=>$c->get('installsitescript')|| $c->get('installsitebin')|| $c->get('installscript'),bindoc=>$c->get('installsiteman1dir')|| $bindoc,libdoc=>$c->get('installsiteman3dir')|| $libdoc,binhtml=>$c->get('installsitehtml1dir')|| $binhtml,libhtml=>$c->get('installsitehtml3dir')|| $libhtml,},vendor=>{lib=>$c->get('installvendorlib'),arch=>$c->get('installvendorarch'),bin=>$c->get('installvendorbin')|| $c->get('installbin'),script=>$c->get('installvendorscript')|| $c->get('installvendorbin')|| $c->get('installscript'),bindoc=>$c->get('installvendorman1dir')|| $bindoc,libdoc=>$c->get('installvendorman3dir')|| $libdoc,binhtml=>$c->get('installvendorhtml1dir')|| $binhtml,libhtml=>$c->get('installvendorhtml3dir')|| $libhtml,},};$p->{original_prefix}={core=>$c->get('installprefixexp')|| $c->get('installprefix')|| $c->get('prefixexp')|| $c->get('prefix')|| '',site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',};$p->{original_prefix}{site}||= $p->{original_prefix}{core};$p->{install_base_relpaths}={lib=>['lib','perl5'],arch=>['lib','perl5',$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],};$p->{prefix_relpaths}={core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},};return$p}sub _find_nested_builds {my$self=shift;my$r=$self->recurse_into or return;my ($file,@r);if (!ref($r)&& $r eq 'auto'){local*DH;opendir DH,$self->base_dir or die "Can't scan directory " .$self->base_dir ." for nested builds: $!";while (defined($file=readdir DH)){my$subdir=File::Spec->catdir($self->base_dir,$file);next unless -d $subdir;push@r,$subdir if -e File::Spec->catfile($subdir,'Build.PL')}}$self->recurse_into(\@r)}sub cwd {return Cwd::cwd()}sub _quote_args {my ($self,@args)=@_;my@quoted;for (@args){if (/^[^\s*?!\$<>;\\|'"\[\]\{\}]+$/){push@quoted,$_}else {s/('+)/'"$1"'/g;push@quoted,qq('$_')}}return join " ",@quoted}sub _backticks {my ($self,@cmd)=@_;if ($self->have_forkpipe){local*FH;my$pid=open*FH,"-|";if ($pid){return wantarray ? <FH> : join '',<FH>}else {die "Can't execute @cmd: $!\n" unless defined$pid;exec {$cmd[0]}@cmd}}else {my$cmd=$self->_quote_args(@cmd);return `$cmd`}}sub have_forkpipe {1}sub _perl_is_same {my ($self,$perl)=@_;my@cmd=($perl);if ($ENV{PERL_CORE}){push@cmd,'-I' .File::Spec->catdir(File::Basename::dirname($perl),'lib')}push@cmd,qw(-MConfig=myconfig -e print -e myconfig);return$self->_backticks(@cmd)eq Config->myconfig}{my$known_perl;sub find_perl_interpreter {my$self=shift;return$known_perl if defined($known_perl);return$known_perl=$self->_discover_perl_interpreter}}sub _discover_perl_interpreter {my$proto=shift;my$c=ref($proto)? $proto->{config}: 'Module::Build::Config';my$perl=$^X;my$perl_basename=File::Basename::basename($perl);my@potential_perls;push(@potential_perls,$perl)if File::Spec->file_name_is_absolute($perl);my$abs_perl=File::Spec->rel2abs($perl);push(@potential_perls,$abs_perl);if ($ENV{PERL_CORE}){require ExtUtils::CBuilder;my$perl_src=Cwd::realpath(ExtUtils::CBuilder->perl_src);if (defined($perl_src)&& length($perl_src)){my$uninstperl=File::Spec->rel2abs(File::Spec->catfile($perl_src,$perl_basename));push(@potential_perls,$uninstperl)}}else {push(@potential_perls,$c->get('perlpath'));push(@potential_perls,map File::Spec->catfile($_,$perl_basename),File::Spec->path())}my$exe=$c->get('exe_ext');for my$thisperl (@potential_perls){if (defined$exe){$thisperl .= $exe unless$thisperl =~ m/$exe$/i}if (-f $thisperl && $proto->_perl_is_same($thisperl)){return$thisperl}}my@paths=map File::Basename::dirname($_),@potential_perls;die "Can't locate the perl binary used to run this script " ."in (@paths)\n"}sub find_command {my ($self,$command)=@_;if(File::Spec->file_name_is_absolute($command)){return$self->_maybe_command($command)}else {for my$dir (File::Spec->path){my$abs=File::Spec->catfile($dir,$command);return$abs if$abs=$self->_maybe_command($abs)}}}sub _maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d $file;return}sub _is_interactive {return -t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT))}sub _is_unattended {my$self=shift;return$ENV{PERL_MM_USE_DEFAULT}|| (!$self->_is_interactive && eof STDIN)}sub _readline {my$self=shift;return undef if$self->_is_unattended;my$answer=<STDIN>;chomp$answer if defined$answer;return$answer}sub prompt {my$self=shift;my$mess=shift or die "prompt() called without a prompt message";my@def;@def=(shift)if @_;my@dispdef=scalar(@def)? ('[',(defined($def[0])? $def[0].' ' : ''),']'): (' ','');local $|=1;print "$mess ",@dispdef;if ($self->_is_unattended &&!@def){die <<EOF}my$ans=$self->_readline();if (!defined($ans)or!length($ans)){print "$dispdef[1]\n";$ans=scalar(@def)? $def[0]: ''}return$ans}sub y_n {my$self=shift;my ($mess,$def)=@_;die "y_n() called without a prompt message" unless$mess;die "Invalid default value: y_n() default must be 'y' or 'n'" if$def && $def !~ /^[yn]/i;my$answer;while (1){$answer=$self->prompt(@_);return 1 if$answer =~ /^y/i;return 0 if$answer =~ /^n/i;local $|=1;print "Please answer 'y' or 'n'.\n"}}sub current_action {shift->{action}}sub invoked_action {shift->{invoked_action}}sub notes {shift()->{phash}{notes}->access(@_)}sub config_data {shift()->{phash}{config_data}->access(@_)}sub runtime_params {shift->{phash}{runtime_params}->read(@_ ? shift : ())}sub auto_features {shift()->{phash}{auto_features}->access(@_)}sub features {my$self=shift;my$ph=$self->{phash};if (@_){my$key=shift;if ($ph->{features}->exists($key)){return$ph->{features}->access($key,@_)}if (my$info=$ph->{auto_features}->access($key)){my$disabled;for my$type (@{$self->prereq_action_types}){next if$type eq 'description' || $type eq 'recommends' ||!exists$info->{$type};my$prereqs=$info->{$type};for my$modname (sort keys %$prereqs){my$spec=$prereqs->{$modname};my$status=$self->check_installed_status($modname,$spec);if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}return$ph->{features}->access($key,@_)}my%features;my%auto_features=$ph->{auto_features}->access();while (my ($name,$info)=each%auto_features){my$failures=$self->prereq_failures($info);my$disabled=grep(/^(?:\w+_)?(?:requires|conflicts)$/,keys %$failures)? 1 : 0;$features{$name}=$disabled ? 0 : 1}%features=(%features,$ph->{features}->access());return wantarray ? %features : \%features}BEGIN {*feature=\&features}sub _mb_feature {my$self=shift;if (($self->module_name || '')eq 'Module::Build'){return$self->feature(@_)}else {require Module::Build::ConfigData;return Module::Build::ConfigData->feature(@_)}}sub _warn_mb_feature_deps {my$self=shift;my$name=shift;$self->log_warn("The '$name' feature is not available.  Please install missing\n" ."feature dependencies and try again.\n".$self->_feature_deps_msg($name)."\n")}sub add_build_element {my ($self,$elem)=@_;my$elems=$self->build_elements;push @$elems,$elem unless grep {$_ eq $elem}@$elems}sub ACTION_config_data {my$self=shift;return unless$self->has_config_data;my$module_name=$self->module_name or die "The config_data feature requires that 'module_name' be set";my$notes_name=$module_name .'::ConfigData';my$notes_pm=File::Spec->catfile($self->blib,'lib',split /::/,"$notes_name.pm");return if$self->up_to_date(['Build.PL',$self->config_file('config_data'),$self->config_file('features')],$notes_pm);$self->log_verbose("Writing config notes to $notes_pm\n");File::Path::mkpath(File::Basename::dirname($notes_pm));Module::Build::Notes->write_config_data (file=>$notes_pm,module=>$module_name,config_module=>$notes_name,config_data=>scalar$self->config_data,feature=>scalar$self->{phash}{features}->access(),auto_features=>scalar$self->auto_features,)}{my%valid_properties=(__PACKAGE__,{});my%additive_properties;sub _mb_classes {my$class=ref($_[0])|| $_[0];return ($class,$class->mb_parents)}sub valid_property {my ($class,$prop)=@_;return grep exists($valid_properties{$_}{$prop}),$class->_mb_classes}sub valid_properties {return keys %{shift->valid_properties_defaults()}}sub valid_properties_defaults {my%out;for my$class (reverse shift->_mb_classes){@out{keys %{$valid_properties{$class}}}=map {$_->()}values %{$valid_properties{$class}}}return \%out}sub array_properties {map {exists$additive_properties{$_}->{ARRAY}? @{$additive_properties{$_}->{ARRAY}}: ()}shift->_mb_classes}sub hash_properties {map {exists$additive_properties{$_}->{HASH}? @{$additive_properties{$_}->{HASH}}: ()}shift->_mb_classes}sub add_property {my ($class,$property)=(shift,shift);die "Property '$property' already exists" if$class->valid_property($property);my%p=@_==1 ? (default=>shift): @_;my$type=ref$p{default};$valid_properties{$class}{$property}=$type eq 'CODE' ? $p{default}: $type eq 'HASH' ? sub {return {%{$p{default}}}}: $type eq 'ARRAY'? sub {return [@{$p{default}}]}: sub {return$p{default}};push @{$additive_properties{$class}->{$type}},$property if$type;unless ($class->can($property)){my$sub=$type eq 'HASH' ? _make_hash_accessor($property,\%p): _make_accessor($property,\%p);no strict 'refs';*{"$class\::$property"}=$sub}return$class}sub property_error {my$self=shift;die 'ERROR: ',@_}sub _set_defaults {my$self=shift;$self->{properties}{build_class}||= ref$self;$self->{properties}{orig_dir}||= $self->{properties}{base_dir};my$defaults=$self->valid_properties_defaults;for my$prop (keys %$defaults){$self->{properties}{$prop}=$defaults->{$prop}unless exists$self->{properties}{$prop}}for my$prop ($self->array_properties){$self->{properties}{$prop}=[@{$defaults->{$prop}}]unless exists$self->{properties}{$prop}}for my$prop ($self->hash_properties){$self->{properties}{$prop}={%{$defaults->{$prop}}}unless exists$self->{properties}{$prop}}}}sub _make_hash_accessor {my ($property,$p)=@_;my$check=$p->{check}|| sub {1};return sub {my$self=shift;unless(ref($self)){carp("\n$property not a class method (@_)");return}my$x=$self->{properties};return$x->{$property}unless @_;my$prop=$x->{$property};if (defined $_[0]&&!ref $_[0]){if (@_==1){return exists$prop->{$_[0]}? $prop->{$_[0]}: undef}elsif (@_ % 2==0){my%new=(%{$prop},@_);local $_=\%new;$x->{$property}=\%new if$check->($self);return$x->{$property}}else {die "Unexpected arguments for property '$property'\n"}}else {die "Unexpected arguments for property '$property'\n" if defined $_[0]&& ref $_[0]ne 'HASH';local $_=$_[0];$x->{$property}=shift if$check->($self)}}}sub _make_accessor {my ($property,$p)=@_;my$check=$p->{check}|| sub {1};return sub {my$self=shift;unless(ref($self)){carp("\n$property not a class method (@_)");return}my$x=$self->{properties};return$x->{$property}unless @_;local $_=$_[0];$x->{$property}=shift if$check->($self);return$x->{$property}}}__PACKAGE__->add_property(auto_configure_requires=>1);__PACKAGE__->add_property(blib=>'blib');__PACKAGE__->add_property(build_class=>'Module::Build');__PACKAGE__->add_property(build_elements=>[qw(PL support pm xs share_dir pod script)]);__PACKAGE__->add_property(build_script=>'Build');__PACKAGE__->add_property(build_bat=>0);__PACKAGE__->add_property(bundle_inc=>[]);__PACKAGE__->add_property(bundle_inc_preload=>[]);__PACKAGE__->add_property(config_dir=>'_build');__PACKAGE__->add_property(dynamic_config=>1);__PACKAGE__->add_property(include_dirs=>[]);__PACKAGE__->add_property(license=>'unknown');__PACKAGE__->add_property(metafile=>'META.yml');__PACKAGE__->add_property(mymetafile=>'MYMETA.yml');__PACKAGE__->add_property(metafile2=>'META.json');__PACKAGE__->add_property(mymetafile2=>'MYMETA.json');__PACKAGE__->add_property(recurse_into=>[]);__PACKAGE__->add_property(use_rcfile=>1);__PACKAGE__->add_property(create_packlist=>1);__PACKAGE__->add_property(allow_mb_mismatch=>0);__PACKAGE__->add_property(config=>undef);__PACKAGE__->add_property(test_file_exts=>['.t']);__PACKAGE__->add_property(use_tap_harness=>0);__PACKAGE__->add_property(cpan_client=>'cpan');__PACKAGE__->add_property(tap_harness_args=>{});__PACKAGE__->add_property(pureperl_only=>0);__PACKAGE__->add_property(allow_pureperl=>0);__PACKAGE__->add_property('installdirs',default=>'site',check=>sub {return 1 if /^(core|site|vendor)$/;return shift->property_error($_ eq 'perl' ? 'Perhaps you meant installdirs to be "core" rather than "perl"?' : 'installdirs must be one of "core", "site", or "vendor"');return shift->property_error("Perhaps you meant 'core'?")if $_ eq 'perl';return 0},);{__PACKAGE__->add_property(html_css=>'')}{my@prereq_action_types=qw(requires build_requires test_requires conflicts recommends);for my$type (@prereq_action_types){__PACKAGE__->add_property($type=>{})}__PACKAGE__->add_property(prereq_action_types=>\@prereq_action_types)}__PACKAGE__->add_property($_=>{})for qw(get_options install_base_relpaths install_path install_sets meta_add meta_merge original_prefix prefix_relpaths configure_requires);__PACKAGE__->add_property($_)for qw(PL_files autosplit base_dir bindoc_dirs c_source cover create_license create_makefile_pl create_readme debugger destdir dist_abstract dist_author dist_name dist_suffix dist_version dist_version_from extra_compiler_flags extra_linker_flags has_config_data install_base libdoc_dirs magic_number mb_version module_name needs_compiler orig_dir perl pm_files pod_files pollute prefix program_name quiet recursive_test_files release_status script_files scripts share_dir sign test_files verbose debug xs_files extra_manify_args);sub config {my$self=shift;my$c=ref($self)? $self->{config}: 'Module::Build::Config';return$c->all_config unless @_;my$key=shift;return$c->get($key)unless @_;my$val=shift;return$c->set($key=>$val)}sub mb_parents {my@in_stack=(shift);my%seen=($in_stack[0]=>1);my ($current,@out);while (@in_stack){next unless defined($current=shift@in_stack)&& $current->isa('Module::Build::Base');push@out,$current;next if$current eq 'Module::Build::Base';no strict 'refs';unshift@in_stack,map {my$c=$_;substr($c,0,2)="main::" if substr($c,0,2)eq '::';$seen{$c}++ ? (): $c}@{"$current\::ISA"}}shift@out;return@out}sub extra_linker_flags {shift->_list_accessor('extra_linker_flags',@_)}sub extra_compiler_flags {shift->_list_accessor('extra_compiler_flags',@_)}sub _list_accessor {(my$self,local $_)=(shift,shift);my$p=$self->{properties};$p->{$_}=[@_]if @_;$p->{$_}=[]unless exists$p->{$_};return ref($p->{$_})? $p->{$_}: [$p->{$_}]}sub subclass {my ($pack,%opts)=@_;my$build_dir='_build';$pack->delete_filetree($build_dir)if -e $build_dir;die "Must provide 'code' or 'class' option to subclass()\n" unless$opts{code}or $opts{class};$opts{code}||= '';$opts{class}||= 'MyModuleBuilder';my$filename=File::Spec->catfile($build_dir,'lib',split '::',$opts{class}).'.pm';my$filedir=File::Basename::dirname($filename);$pack->log_verbose("Creating custom builder $filename in $filedir\n");File::Path::mkpath($filedir);die "Can't create directory $filedir: $!" unless -d $filedir;open(my$fh,'>',$filename)or die "Can't create $filename: $!";print$fh <<EOF;close$fh;unshift@INC,File::Spec->catdir(File::Spec->rel2abs($build_dir),'lib');eval "use $opts{class}";die $@ if $@;return$opts{class}}sub _guess_module_name {my$self=shift;my$p=$self->{properties};return if$p->{module_name};if ($p->{dist_version_from}&& -e $p->{dist_version_from}){my$mi=Module::Metadata->new_from_file($self->dist_version_from);$p->{module_name}=$mi->name}else {my$mod_path=my$mod_name=$p->{dist_name};$mod_name =~ s{-}{::}g;$mod_path =~ s{-}{/}g;$mod_path .= ".pm";if (-e $mod_path || -e "lib/$mod_path"){$p->{module_name}=$mod_name}else {$self->log_warn(<< 'END_WARN')}}}sub dist_name {my$self=shift;my$p=$self->{properties};my$me='dist_name';return$p->{$me}if defined$p->{$me};die "Can't determine distribution name, must supply either 'dist_name' or 'module_name' parameter" unless$self->module_name;($p->{$me}=$self->module_name)=~ s/::/-/g;return$p->{$me}}sub release_status {my ($self)=@_;my$me='release_status';my$p=$self->{properties};if (!defined$p->{$me}){$p->{$me}=$self->_is_dev_version ? 'testing' : 'stable'}unless ($p->{$me}=~ qr/\A(?:stable|testing|unstable)\z/){die "Illegal value '$p->{$me}' for $me\n"}if ($p->{$me}eq 'stable' && $self->_is_dev_version){my$version=$self->dist_version;die "Illegal value '$p->{$me}' with version '$version'\n"}return$p->{$me}}sub dist_suffix {my ($self)=@_;my$p=$self->{properties};my$me='dist_suffix';return$p->{$me}if defined$p->{$me};if ($self->release_status eq 'stable'){$p->{$me}=""}else {$p->{$me}=$self->_is_dev_version ? "" : "TRIAL" }return$p->{$me}}sub dist_version_from {my ($self)=@_;my$p=$self->{properties};my$me='dist_version_from';if ($self->module_name){$p->{$me}||= join('/','lib',split(/::/,$self->module_name)).'.pm'}return$p->{$me}|| undef}sub dist_version {my ($self)=@_;my$p=$self->{properties};my$me='dist_version';return$p->{$me}if defined$p->{$me};if (my$dist_version_from=$self->dist_version_from){my$version_from=File::Spec->catfile(split(qr{/},$dist_version_from));my$pm_info=Module::Metadata->new_from_file($version_from)or die "Can't find file $version_from to determine version";$p->{$me}=$self->normalize_version($pm_info->version());unless (defined$p->{$me}){die "Can't determine distribution version from $version_from"}}die ("Can't determine distribution version, must supply either 'dist_version',\n"."'dist_version_from', or 'module_name' parameter")unless defined$p->{$me};return$p->{$me}}sub _is_dev_version {my ($self)=@_;my$dist_version=$self->dist_version;my$version_obj=eval {version->new($dist_version)};return $@ ? 0 : $version_obj->is_alpha}sub dist_author {shift->_pod_parse('author')}sub dist_abstract {shift->_pod_parse('abstract')}sub _pod_parse {my ($self,$part)=@_;my$p=$self->{properties};my$member="dist_$part";return$p->{$member}if defined$p->{$member};my$docfile=$self->_main_docfile or return;open(my$fh,'<',$docfile)or return;require Module::Build::PodParser;my$parser=Module::Build::PodParser->new(fh=>$fh);my$method="get_$part";return$p->{$member}=$parser->$method()}sub version_from_file {return Module::Metadata->new_from_file($_[1])->version()}sub find_module_by_name {return Module::Metadata->find_module_by_name(@_[1,2])}{my%unlink_list_for_pid;sub _unlink_on_exit {my$self=shift;for my$f (@_){push @{$unlink_list_for_pid{$$}},$f if -f $f}return 1}END {for my$f (map glob($_),@{$unlink_list_for_pid{$$}|| []}){next unless -e $f;File::Path::rmtree($f,0,0)}}}sub add_to_cleanup {my$self=shift;my%files=map {$self->localize_file_path($_),1}@_;$self->{phash}{cleanup}->write(\%files)}sub cleanup {my$self=shift;my$all=$self->{phash}{cleanup}->read;return wantarray ? sort keys %$all : keys %$all}sub config_file {my$self=shift;return unless -d $self->config_dir;return File::Spec->catfile($self->config_dir,@_)}sub read_config {my ($self)=@_;my$file=$self->config_file('build_params')or die "Can't find 'build_params' in " .$self->config_dir;open(my$fh,'<',$file)or die "Can't read '$file': $!";my$ref=eval do {local $/;<$fh>};die if $@;close$fh;my$c;($self->{args},$c,$self->{properties})=@$ref;$self->{config}=Module::Build::Config->new(values=>$c)}sub has_config_data {my$self=shift;return scalar grep$self->{phash}{$_}->has_data(),qw(config_data features auto_features)}sub _write_data {my ($self,$filename,$data)=@_;my$file=$self->config_file($filename);open(my$fh,'>',$file)or die "Can't create '$file': $!";unless (ref($data)){print$fh $data;return}print {$fh}Module::Build::Dumper->_data_dump($data);close$fh}sub write_config {my ($self)=@_;File::Path::mkpath($self->{properties}{config_dir});-d $self->{properties}{config_dir}or die "Can't mkdir $self->{properties}{config_dir}: $!";my@items=@{$self->prereq_action_types};$self->_write_data('prereqs',{map {$_,$self->$_()}@items });$self->_write_data('build_params',[$self->{args},$self->{config}->values_set,$self->{properties}]);$self->_write_data('magicnum',$self->magic_number(int rand 1_000_000));$self->{phash}{$_}->write()foreach qw(notes cleanup features auto_features config_data runtime_params)}{my%packlist_map=('^File::Spec'=>'Cwd','^Devel::AssertOS'=>'Devel::CheckOS',);sub _find_packlist {my ($self,$inst,$mod)=@_;my$lookup=$mod;my$packlist=eval {$inst->packlist($lookup)};if (!$packlist){while (my ($re,$new_mod)=each%packlist_map){if ($mod =~ qr/$re/){$lookup=$new_mod;$packlist=eval {$inst->packlist($lookup)};last}}}return$packlist ? $lookup : undef}sub set_bundle_inc {my$self=shift;my$bundle_inc=$self->{properties}{bundle_inc};my$bundle_inc_preload=$self->{properties}{bundle_inc_preload};return unless inc::latest->can('loaded_modules');require ExtUtils::Installed;my$inst=eval {ExtUtils::Installed->new(extra_libs=>[@INC])};if ($@){$self->log_warn(<< "EUI_ERROR");return}my@bundle_list=map {[$_,0 ]}inc::latest->loaded_modules;while(@bundle_list){my ($mod,$prereq)=@{shift@bundle_list};my$lookup=$self->_find_packlist($inst,$mod);if (!$lookup){die << "NO_PACKLIST"}else {push @{$prereq ? $bundle_inc_preload : $bundle_inc},$lookup}}}}sub check_autofeatures {my ($self)=@_;my$features=$self->auto_features;return 1 unless %$features;my$longest=sub {my@str=@_ or croak("no strings given");my@len=map({length($_)}@str);my$max=0;my$longest;for my$i (0..$#len){($max,$longest)=($len[$i],$str[$i])if($len[$i]> $max)}return($longest)};my$max_name_len=length($longest->(keys %$features));my ($num_disabled,$log_text)=(0,"\nChecking optional features...\n");for my$name (sort keys %$features){$log_text .= $self->_feature_deps_msg($name,$max_name_len)}$num_disabled=()=$log_text =~ /disabled/g;if ($num_disabled){$self->log_warn($log_text);return 0}else {$self->log_verbose($log_text);return 1}}sub _feature_deps_msg {my ($self,$name,$max_name_len)=@_;$max_name_len ||= length$name;my$features=$self->auto_features;my$info=$features->{$name};my$feature_text="$name" .'.' x ($max_name_len - length($name)+ 4);my ($log_text,$disabled)=('','');if (my$failures=$self->prereq_failures($info)){$disabled=grep(/^(?:\w+_)?(?:requires|conflicts)$/,keys %$failures)? 1 : 0;$feature_text .= $disabled ? "disabled\n" : "enabled\n";for my$type (@{$self->prereq_action_types}){next unless exists$failures->{$type};$feature_text .= "  $type:\n";my$prereqs=$failures->{$type};for my$module (sort keys %$prereqs){my$status=$prereqs->{$module};my$required=($type =~ /^(?:\w+_)?(?:requires|conflicts)$/)? 1 : 0;my$prefix=($required)? '!' : '*';$feature_text .= "    $prefix $status->{message}\n"}}}else {$feature_text .= "enabled\n"}$log_text .= $feature_text if$disabled || $self->verbose;return$log_text}sub auto_config_requires {my ($self)=@_;my$p=$self->{properties};if ($self->dist_name ne 'Module-Build' && $self->auto_configure_requires &&!exists$p->{configure_requires}{'Module::Build'}){(my$ver=$VERSION)=~ s/^(\d+\.\d\d).*$/$1/;$self->log_warn(<<EOM);$self->_add_prereq('configure_requires','Module::Build',$ver)}if (inc::latest->can('loaded_module')){for my$mod (inc::latest->loaded_modules){next if exists$p->{configure_requires}{$mod};$self->_add_prereq('configure_requires',$mod,$mod->VERSION)}}return}sub auto_require {my ($self)=@_;my$p=$self->{properties};my$xs_files=$self->find_xs_files;if (!defined$p->{needs_compiler}){$self->needs_compiler(keys %$xs_files || defined$self->c_source)}if ($self->needs_compiler){$self->_add_prereq('build_requires','ExtUtils::CBuilder',0);if (!$self->have_c_compiler){$self->log_warn(<<'EOM')}}if ($self->share_dir){$self->_add_prereq('requires','File::ShareDir','1.00')}return}sub _add_prereq {my ($self,$type,$module,$version)=@_;my$p=$self->{properties};$version=0 unless defined$version;if (exists$p->{$type}{$module}){return if$self->compare_versions($version,'<=',$p->{$type}{$module})}$self->log_verbose("Adding to $type\: $module => $version\n");$p->{$type}{$module}=$version;return 1}sub prereq_failures {my ($self,$info)=@_;my@types=@{$self->prereq_action_types};$info ||= {map {$_,$self->$_()}@types};my$out;for my$type (@types){my$prereqs=$info->{$type};for my$modname (keys %$prereqs){my$spec=$prereqs->{$modname};my$status=$self->check_installed_status($modname,$spec);if ($type =~ /^(?:\w+_)?conflicts$/){next if!$status->{ok};$status->{conflicts}=delete$status->{need};$status->{message}="$modname ($status->{have}) conflicts with this distribution"}elsif ($type =~ /^(?:\w+_)?recommends$/){next if$status->{ok};$status->{message}=(!ref($status->{have})&& $status->{have}eq '<none>' ? "$modname is not installed" : "$modname ($status->{have}) is installed, but we prefer to have $spec")}else {next if$status->{ok}}$out->{$type}{$modname}=$status}}return$out}sub _enum_prereqs {my$self=shift;my%prereqs;for my$type (@{$self->prereq_action_types}){if ($self->can($type)){my$prereq=$self->$type()|| {};$prereqs{$type}=$prereq if %$prereq}}return \%prereqs}sub check_prereq {my$self=shift;my$info=$self->_enum_prereqs;return 1 unless$info;my$log_text="Checking prerequisites...\n";my$failures=$self->prereq_failures($info);if ($failures){$self->log_warn($log_text);for my$type (@{$self->prereq_action_types}){my$prereqs=$failures->{$type};$self->log_warn("  ${type}:\n")if keys %$prereqs;for my$module (sort keys %$prereqs){my$status=$prereqs->{$module};my$prefix=($type =~ /^(?:\w+_)?recommends$/)? "* " : "! ";$self->log_warn("    $prefix $status->{message}\n")}}return 0}else {$self->log_verbose($log_text ."Looks good\n\n");return 1}}sub perl_version {my ($self)=@_;return $^V ? $self->perl_version_to_float(sprintf "%vd",$^V): $]}sub perl_version_to_float {my ($self,$version)=@_;return$version if grep(/\./,$version)< 2;$version =~ s/\./../;$version =~ s/\.(\d+)/sprintf '%03d', $1/eg;return$version}sub _parse_conditions {my ($self,$spec)=@_;return ">= 0" if not defined$spec;if ($spec =~ /^\s*([\w.]+)\s*$/){return (">= $spec")}else {return split /\s*,\s*/,$spec}}sub try_require {my ($self,$modname,$spec)=@_;my$status=$self->check_installed_status($modname,defined($spec)? $spec : 0);return unless$status->{ok};my$path=$modname;$path =~ s{::}{/}g;$path .= ".pm";if (defined$INC{$path}){return 1}elsif (exists$INC{$path}){return}else {return eval "require $modname"}}sub check_installed_status {my ($self,$modname,$spec)=@_;my%status=(need=>$spec);if ($modname eq 'perl'){$status{have}=$self->perl_version}elsif (eval {no strict;$status{have}=${"${modname}::VERSION"}}){}else {my$pm_info=Module::Metadata->new_from_module($modname);unless (defined($pm_info)){@status{qw(have message) }=('<none>',"$modname is not installed");return \%status}$status{have}=eval {$pm_info->version()};if ($spec and!defined($status{have})){@status{qw(have message) }=(undef,"Couldn't find a \$VERSION in prerequisite $modname");return \%status}}my@conditions=$self->_parse_conditions($spec);for (@conditions){my ($op,$version)=/^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x or die "Invalid prerequisite condition '$_' for $modname";$version=$self->perl_version_to_float($version)if$modname eq 'perl';next if$op eq '>=' and!$version;unless ($self->compare_versions($status{have},$op,$version)){$status{message}="$modname ($status{have}) is installed, but we need version $op $version";return \%status}}$status{ok}=1;return \%status}sub compare_versions {my$self=shift;my ($v1,$op,$v2)=@_;$v1=version->new($v1)unless eval {$v1->isa('version')};my$eval_str="\$v1 $op \$v2";my$result=eval$eval_str;$self->log_warn("error comparing versions: '$eval_str' $@")if $@;return$result}sub check_installed_version {my ($self,$modname,$spec)=@_;my$status=$self->check_installed_status($modname,$spec);if ($status->{ok}){return$status->{have}if$status->{have}and "$status->{have}" ne '<none>';return '0 but true'}$@=$status->{message};return 0}sub make_executable {my$self=shift;for (@_){my$current_mode=(stat $_)[2];chmod$current_mode | oct(111),$_}}sub is_executable {my ($self,$file)=@_;return -x $file}sub _startperl {shift()->config('startperl')}sub _added_to_INC {my$self=shift;my%seen;$seen{$_}++ foreach$self->_default_INC;return grep!$seen{$_}++,@INC}{my@default_inc;sub _default_INC {my$self=shift;return@default_inc if@default_inc;local$ENV{PERL5LIB};my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;my@inc=$self->_backticks($perl,'-le','print for @INC');chomp@inc;return@default_inc=@inc}}sub print_build_script {my ($self,$fh)=@_;my$build_package=$self->build_class;my$closedata="";my$config_requires;if (-f $self->metafile){my$meta=eval {$self->read_metafile($self->metafile)};$config_requires=$meta && $meta->{prereqs}{configure}{requires}{'Module::Build'}}$config_requires ||= 0;my%q=map {$_,$self->$_()}qw(config_dir base_dir);$q{base_dir}=Win32::GetShortPathName($q{base_dir})if$self->is_windowsish;$q{magic_numfile}=$self->config_file('magicnum');my@myINC=$self->_added_to_INC;for (@myINC,values%q){$_=File::Spec->canonpath($_)unless$self->is_vmsish;s/([\\\'])/\\$1/g}my$quoted_INC=join ",\n",map "     '$_'",@myINC;my$shebang=$self->_startperl;my$magic_number=$self->magic_number;print$fh <<EOF}sub create_mymeta {my ($self)=@_;my ($meta_obj,$mymeta);my@metafiles=($self->metafile2,$self->metafile,);my@mymetafiles=($self->mymetafile2,$self->mymetafile,);for my$f (@mymetafiles){if ($self->delete_filetree($f)){$self->log_verbose("Removed previous '$f'\n")}}if ($self->try_require("CPAN::Meta","2.142060")){for my$file (@metafiles){next unless -f $file;$meta_obj=eval {CPAN::Meta->load_file($file,{lazy_validation=>0 })};last if$meta_obj}}my$mymeta_obj;if ($meta_obj){my%updated=(%{$meta_obj->as_struct({version=>2.0 })},prereqs=>$self->_normalize_prereqs,dynamic_config=>0,generated_by=>"Module::Build version $Module::Build::VERSION",);$mymeta_obj=CPAN::Meta->new(\%updated,{lazy_validation=>0 })}else {$mymeta_obj=$self->_get_meta_object(quiet=>0,dynamic=>0,fatal=>1,auto=>0)}my@created=$self->_write_meta_files($mymeta_obj,'MYMETA');$self->log_warn("Could not create MYMETA files\n")unless@created;return 1}sub create_build_script {my ($self)=@_;$self->write_config;$self->create_mymeta;my ($build_script,$dist_name,$dist_version)=map$self->$_(),qw(build_script dist_name dist_version);if ($self->delete_filetree($build_script)){$self->log_verbose("Removed previous script '$build_script'\n")}$self->log_info("Creating new '$build_script' script for ","'$dist_name' version '$dist_version'\n");open(my$fh,'>',$build_script)or die "Can't create '$build_script': $!";$self->print_build_script($fh);close$fh;$self->make_executable($build_script);return 1}sub check_manifest {my$self=shift;return unless -e 'MANIFEST';require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);$self->log_verbose("Checking whether your kit is complete...\n");if (my@missed=ExtUtils::Manifest::manicheck()){$self->log_warn("WARNING: the following files are missing in your kit:\n","\t",join("\n\t",@missed),"\n","Please inform the author.\n\n")}else {$self->log_verbose("Looks good\n\n")}}sub dispatch {my$self=shift;local$self->{_completed_actions}={};if (@_){my ($action,%p)=@_;my$args=$p{args}? delete($p{args}): {};local$self->{invoked_action}=$action;local$self->{args}={%{$self->{args}},%$args};local$self->{properties}={%{$self->{properties}},%p};return$self->_call_action($action)}die "No build action specified" unless$self->{action};local$self->{invoked_action}=$self->{action};$self->_call_action($self->{action})}sub _call_action {my ($self,$action)=@_;return if$self->{_completed_actions}{$action}++;local$self->{action}=$action;my$method=$self->can_action($action);die "No action '$action' defined, try running the 'help' action.\n" unless$method;$self->log_debug("Starting ACTION_$action\n");my$rc=$self->$method();$self->log_debug("Finished ACTION_$action\n");return$rc}sub can_action {my ($self,$action)=@_;return$self->can("ACTION_$action")}sub cull_options {my$self=shift;my (@argv)=@_;return({},@argv)unless(ref($self));my$specs=$self->get_options;return({},@argv)unless($specs and %$specs);require Getopt::Long;my@specs;my$args={};for my$k (sort keys %$specs){my$v=$specs->{$k};die "Option specification '$k' conflicts with a " .ref$self ." option of the same name" if$self->valid_property($k);push@specs,$k .(defined$v->{type}? $v->{type}: '');push@specs,$v->{store}if exists$v->{store};$args->{$k}=$v->{default}if exists$v->{default}}local@ARGV=@argv;if (@specs){Getopt::Long::Configure('pass_through');Getopt::Long::GetOptions($args,@specs)}return$args,@ARGV}sub unparse_args {my ($self,$args)=@_;my@out;for my$k (sort keys %$args){my$v=$args->{$k};push@out,(ref$v eq 'HASH' ? map {+"--$k","$_=$v->{$_}"}sort keys %$v : ref$v eq 'ARRAY' ? map {+"--$k",$_}@$v : ("--$k",$v))}return@out}sub args {my$self=shift;return wantarray ? %{$self->{args}}: $self->{args}unless @_;my$key=shift;$self->{args}{$key}=shift if @_;return$self->{args}{$key}}sub _translate_option {my$self=shift;my$opt=shift;(my$tr_opt=$opt)=~ tr/-/_/;return$tr_opt if grep$tr_opt =~ /^(?:no_?)?$_$/,qw(create_license create_makefile_pl create_readme extra_compiler_flags extra_linker_flags install_base install_path meta_add meta_merge test_files use_rcfile use_tap_harness tap_harness_args cpan_client pureperl_only allow_pureperl);return$opt}my%singular_argument=map {($_=>1)}qw/install_base prefix destdir installdirs verbose quiet uninst debug sign/;sub _read_arg {my ($self,$args,$key,$val)=@_;$key=$self->_translate_option($key);if (exists$args->{$key}and not $singular_argument{$key}){$args->{$key}=[$args->{$key}]unless ref$args->{$key};push @{$args->{$key}},$val}else {$args->{$key}=$val}}sub _optional_arg {my$self=shift;my$opt=shift;my$argv=shift;$opt=$self->_translate_option($opt);my@bool_opts=qw(build_bat create_license create_readme pollute quiet uninst use_rcfile verbose debug sign use_tap_harness pureperl_only allow_pureperl);if (grep$opt =~ /^no[-_]?$_$/,@bool_opts){$opt =~ s/^no-?//;return ($opt,0)}return ($opt,shift(@$argv))unless grep $_ eq $opt,@bool_opts;my$arg=1;$arg=shift(@$argv)if @$argv && $argv->[0]=~ /^\d+$/;return ($opt,$arg)}sub read_args {my$self=shift;(my$args,@_)=$self->cull_options(@_);my%args=%$args;my$opt_re=qr/[\w\-]+/;my ($action,@argv);while (@_){local $_=shift;if (/^(?:--)?($opt_re)=(.*)$/){$self->_read_arg(\%args,$1,$2)}elsif (/^--($opt_re)$/){my($opt,$arg)=$self->_optional_arg($1,\@_);$self->_read_arg(\%args,$opt,$arg)}elsif (/^($opt_re)$/ and!defined($action)){$action=$1}else {push@argv,$_}}$args{ARGV}=\@argv;for ('extra_compiler_flags','extra_linker_flags'){$args{$_}=[$self->split_like_shell($args{$_})]if exists$args{$_}}for ('include_dirs'){$args{$_}=[$args{$_}]if exists$args{$_}&&!ref$args{$_}}for ($self->hash_properties,'config'){next unless exists$args{$_};my%hash;$args{$_}||= [];$args{$_}=[$args{$_}]unless ref$args{$_};for my$arg (@{$args{$_}}){$arg =~ /($opt_re)=(.*)/ or die "Malformed '$_' argument: '$arg' should be something like 'foo=bar'";$hash{$1}=$2}$args{$_}=\%hash}for my$key (qw(prefix install_base destdir)){next if!defined$args{$key};$args{$key}=$self->_detildefy($args{$key})}for my$key (qw(install_path)){next if!defined$args{$key};for my$subkey (keys %{$args{$key}}){next if!defined$args{$key}{$subkey};my$subkey_ext=$self->_detildefy($args{$key}{$subkey});if ($subkey eq 'html'){$args{$key}{binhtml}=$subkey_ext;$args{$key}{libhtml}=$subkey_ext}else {$args{$key}{$subkey}=$subkey_ext}}}if ($args{makefile_env_macros}){require Module::Build::Compat;%args=(%args,Module::Build::Compat->makefile_to_build_macros)}return \%args,$action}sub _detildefy {}sub _merge_arglist {my($self,$opts1,$opts2)=@_;$opts1 ||= {};$opts2 ||= {};my%new_opts=%$opts1;while (my ($key,$val)=each %$opts2){if (exists($opts1->{$key})){if (ref($val)eq 'HASH'){while (my ($k,$v)=each %$val){$new_opts{$key}{$k}=$v unless exists($opts1->{$key}{$k})}}}else {$new_opts{$key}=$val}}return%new_opts}sub _home_dir {my@home_dirs;push(@home_dirs,$ENV{HOME})if$ENV{HOME};push(@home_dirs,File::Spec->catpath($ENV{HOMEDRIVE},$ENV{HOMEPATH},''))if$ENV{HOMEDRIVE}&& $ENV{HOMEPATH};my@other_home_envs=qw(USERPROFILE APPDATA WINDIR SYS$LOGIN);push(@home_dirs,map$ENV{$_},grep$ENV{$_},@other_home_envs);my@real_home_dirs=grep -d,@home_dirs;return wantarray ? @real_home_dirs : shift(@real_home_dirs)}sub _find_user_config {my$self=shift;my$file=shift;for my$dir ($self->_home_dir){my$path=File::Spec->catfile($dir,$file);return$path if -e $path}return undef}sub read_modulebuildrc {my($self,$action)=@_;return ()unless$self->use_rcfile;my$modulebuildrc;if (exists($ENV{MODULEBUILDRC})&& $ENV{MODULEBUILDRC}eq 'NONE'){return ()}elsif (exists($ENV{MODULEBUILDRC})&& -e $ENV{MODULEBUILDRC}){$modulebuildrc=$ENV{MODULEBUILDRC}}elsif (exists($ENV{MODULEBUILDRC})){$self->log_warn("WARNING: Can't find resource file " ."'$ENV{MODULEBUILDRC}' defined in environment.\n" ."No options loaded\n");return ()}else {$modulebuildrc=$self->_find_user_config('.modulebuildrc');return ()unless$modulebuildrc}open(my$fh,'<',$modulebuildrc)or die "Can't open $modulebuildrc: $!";my%options;my$buffer='';while (defined(my$line=<$fh>)){chomp($line);$line =~ s/#.*$//;next unless length($line);if ($line =~ /^\S/){if ($buffer){my($action,$options)=split(/\s+/,$buffer,2);$options{$action}.= $options .' ';$buffer=''}$buffer=$line}else {$buffer .= $line}}if ($buffer){my($action,$options)=split(/\s+/,$buffer,2);$options{$action}.= $options .' '}my ($global_opts)=$self->read_args($self->split_like_shell($options{'*'}|| ''));if ($action eq 'fakeinstall' &&!exists$options{fakeinstall}){$action='install'}my ($action_opts)=$self->read_args($self->split_like_shell($options{$action}|| ''));return$self->_merge_arglist($action_opts,$global_opts)}sub merge_modulebuildrc {my($self,$action,%cmdline_opts)=@_;my%rc_opts=$self->read_modulebuildrc($action || $self->{action}|| 'build');my%new_opts=$self->_merge_arglist(\%cmdline_opts,\%rc_opts);$self->merge_args($action,%new_opts)}sub merge_args {my ($self,$action,%args)=@_;$self->{action}=$action if defined$action;my%additive=map {$_=>1}$self->hash_properties;while (my ($key,$val)=each%args){$self->{phash}{runtime_params}->access($key=>$val)if$self->valid_property($key);if ($key eq 'config'){$self->config($_=>$val->{$_})foreach keys %$val}else {my$add_to=$additive{$key}? $self->{properties}{$key}: $self->valid_property($key)? $self->{properties}: $self->{args};if ($additive{$key}){$add_to->{$_}=$val->{$_}foreach keys %$val}else {$add_to->{$key}=$val}}}}sub cull_args {my$self=shift;my@arg_list=@_;unshift@arg_list,$self->split_like_shell($ENV{PERL_MB_OPT})if$ENV{PERL_MB_OPT};my ($args,$action)=$self->read_args(@arg_list);$self->merge_args($action,%$args);$self->merge_modulebuildrc($action,%$args)}sub super_classes {my ($self,$class,$seen)=@_;$class ||= ref($self)|| $self;$seen ||= {};no strict 'refs';my@super=grep {not $seen->{$_}++}$class,@{$class .'::ISA'};return@super,map {$self->super_classes($_,$seen)}@super}sub known_actions {my ($self)=@_;my%actions;no strict 'refs';for my$class ($self->super_classes){for (keys %{$class .'::'}){$actions{$1}++ if /^ACTION_(\w+)/}}return wantarray ? sort keys%actions : \%actions}sub get_action_docs {my ($self,$action)=@_;my$actions=$self->known_actions;die "No known action '$action'" unless$actions->{$action};my ($files_found,@docs)=(0);for my$class ($self->super_classes){(my$file=$class)=~ s{::}{/}g;$file=$INC{$file .'.pm'}or next;open(my$fh,'<',$file)or next;$files_found++;local $_;while (<$fh>){last if /^=head1 ACTIONS\s/}my$style;while (<$fh>){last if /^=head1 /;if(/^=(item|head2)\s+\Q$action\E\b/){$style=$1;push@docs,$_;last}}$style or next;if($style eq 'item'){my ($found,$inlist)=(0,0);while (<$fh>){if (/^=(item|back)/){last unless$inlist}push@docs,$_;++$inlist if /^=over/;--$inlist if /^=back/}}else {while (<$fh>){last if(/^=(?:head[12]|cut)/);push@docs,$_}}}unless ($files_found){$@="Couldn't find any documentation to search";return}unless (@docs){$@="Couldn't find any docs for action '$action'";return}return join '',@docs}sub ACTION_prereq_report {my$self=shift;$self->log_info($self->prereq_report)}sub ACTION_prereq_data {my$self=shift;$self->log_info(Module::Build::Dumper->_data_dump($self->prereq_data))}sub prereq_data {my$self=shift;my@types=('configure_requires',@{$self->prereq_action_types});my$info={map {$_=>$self->$_()}grep {%{$self->$_()}}@types };return$info}sub prereq_report {my$self=shift;my$info=$self->prereq_data;my$output='';for my$type (sort keys %$info){my$prereqs=$info->{$type};$output .= "\n$type:\n";my$mod_len=2;my$ver_len=4;my%mods;for my$modname (sort keys %$prereqs){my$spec=$prereqs->{$modname};my$len=length$modname;$mod_len=$len if$len > $mod_len;$spec ||= '0';$len=length$spec;$ver_len=$len if$len > $ver_len;my$mod=$self->check_installed_status($modname,$spec);$mod->{name}=$modname;$mod->{ok}||= 0;$mod->{ok}=!$mod->{ok}if$type =~ /^(\w+_)?conflicts$/;$mods{lc$modname}=$mod}my$space=q{ } x ($mod_len - 3);my$vspace=q{ } x ($ver_len - 3);my$sline=q{-} x ($mod_len - 3);my$vline=q{-} x ($ver_len - 3);my$disposition=($type =~ /^(\w+_)?conflicts$/)? 'Clash' : 'Need';$output .= "    Module $space  $disposition $vspace  Have\n"."    ------$sline+------$vline-+----------\n";for my$k (sort keys%mods){my$mod=$mods{$k};my$space=q{ } x ($mod_len - length$k);my$vspace=q{ } x ($ver_len - length$mod->{need});my$f=$mod->{ok}? ' ' : '!';$output .= "  $f $mod->{name} $space     $mod->{need}  $vspace   ".(defined($mod->{have})? $mod->{have}: "")."\n"}}return$output}sub ACTION_help {my ($self)=@_;my$actions=$self->known_actions;if (@{$self->{args}{ARGV}}){my$msg=eval {$self->get_action_docs($self->{args}{ARGV}[0],$actions)};print $@ ? "$@\n" : $msg;return}print <<EOF;print$self->_action_listing($actions);print "\nRun `Build help <action>` for details on an individual action.\n";print "See `perldoc Module::Build` for complete documentation.\n"}sub _action_listing {my ($self,$actions)=@_;my@actions=sort keys %$actions;@actions=map$actions[($_ + ($_ % 2)* @actions)/ 2],0..$#actions;my$out='';while (my ($one,$two)=splice@actions,0,2){$out .= sprintf("  %-12s                   %-12s\n",$one,$two||'')}$out =~ s{\s*$}{}mg;return$out}sub ACTION_retest {my ($self)=@_;local@INC=@INC;@INC=grep {ref()|| -d}@INC if@INC > 100;$self->do_tests}sub ACTION_testall {my ($self)=@_;my@types;for my$action (grep {$_ ne 'all'}$self->get_test_types){push(@types,$action)}$self->generic_test(types=>['default',@types])}sub get_test_types {my ($self)=@_;my$t=$self->{properties}->{test_types};return (defined$t ? (wantarray ? sort keys %$t : keys %$t): ())}sub ACTION_test {my ($self)=@_;$self->generic_test(type=>'default')}sub generic_test {my$self=shift;(@_ % 2)and croak('Odd number of elements in argument hash');my%args=@_;my$p=$self->{properties};my@types=((exists($args{type})? $args{type}: ()),(exists($args{types})? @{$args{types}}: ()),);@types or croak "need some types of tests to check";my%test_types=(default=>$p->{test_file_exts},(defined($p->{test_types})? %{$p->{test_types}}: ()),);for my$type (@types){croak "$type not defined in test_types!" unless defined$test_types{$type }}local$p->{test_file_exts}=[map {ref $_ ? @$_ : $_}@test_types{@types}];$self->depends_on('code');local@INC=@INC;unshift@INC,(File::Spec->catdir($p->{base_dir},$self->blib,'lib'),File::Spec->catdir($p->{base_dir},$self->blib,'arch'));@INC=grep {ref()|| -d}@INC if@INC > 100;$self->do_tests}sub do_tests {my$self=shift;my$tests=$self->find_test_files;local$ENV{PERL_DL_NONLAZY}=1;if(@$tests){my$args=$self->tap_harness_args;if($self->use_tap_harness or ($args and %$args)){my$aggregate=$self->run_tap_harness($tests);if ($aggregate->has_errors){die "Errors in testing.  Cannot continue.\n"}}else {$self->run_test_harness($tests)}}else {$self->log_info("No tests defined.\n")}$self->run_visual_script}sub run_tap_harness {my ($self,$tests)=@_;require TAP::Harness::Env;my$aggregate=TAP::Harness::Env->create({lib=>[@INC],verbosity=>$self->{properties}{verbose},switches=>[$self->harness_switches ],%{$self->tap_harness_args},})->runtests(@$tests);return$aggregate}sub run_test_harness {my ($self,$tests)=@_;require Test::Harness;local$Test::Harness::verbose=$self->verbose || 0;local$Test::Harness::switches=join ' ',$self->harness_switches;Test::Harness::runtests(@$tests)}sub run_visual_script {my$self=shift;$self->run_perl_script('visual.pl','-Mblib='.$self->blib)if -e 'visual.pl'}sub harness_switches {my$self=shift;my@res;push@res,qw(-w -d) if$self->{properties}{debugger};push@res,'-MDevel::Cover' if$self->{properties}{cover};return@res}sub test_files {my$self=shift;my$p=$self->{properties};if (@_){return$p->{test_files}=(@_==1 ? shift : [@_])}return$self->find_test_files}sub expand_test_dir {my ($self,$dir)=@_;my$exts=$self->{properties}{test_file_exts};return sort map {@{$self->rscan_dir($dir,qr{^[^.].*\Q$_\E$})}}@$exts if$self->recursive_test_files;return sort map {glob File::Spec->catfile($dir,"*$_")}@$exts}sub ACTION_testdb {my ($self)=@_;local$self->{properties}{debugger}=1;$self->depends_on('test')}sub ACTION_testcover {my ($self)=@_;unless (Module::Metadata->find_module_by_name('Devel::Cover')){warn("Cannot run testcover action unless Devel::Cover is installed.\n");return}$self->add_to_cleanup('coverage','cover_db');$self->depends_on('code');if (-e 'cover_db'){my$pm_files=$self->rscan_dir (File::Spec->catdir($self->blib,'lib'),$self->file_qr('\.pm$'));my$cover_files=$self->rscan_dir('cover_db',sub {-f $_ and not /\.html$/});$self->do_system(qw(cover -delete))unless$self->up_to_date($pm_files,$cover_files)&& $self->up_to_date($self->test_files,$cover_files)}local$self->{properties}{cover}=1;$self->depends_on('test');$self->do_system('cover')}sub ACTION_code {my ($self)=@_;my$blib=$self->blib;$self->add_to_cleanup($blib);File::Path::mkpath(File::Spec->catdir($blib,'arch'));if (my$split=$self->autosplit){$self->autosplit_file($_,$blib)for ref($split)? @$split : ($split)}for my$element (@{$self->build_elements}){my$method="process_${element}_files";$method="process_files_by_extension" unless$self->can($method);$self->$method($element)}$self->depends_on('config_data')}sub ACTION_build {my$self=shift;$self->log_info("Building " .$self->dist_name ."\n");$self->depends_on('code');$self->depends_on('docs')}sub process_files_by_extension {my ($self,$ext)=@_;my$method="find_${ext}_files";my$files=$self->can($method)? $self->$method(): $self->_find_file_by_type($ext,'lib');for my$file (sort keys %$files){$self->copy_if_modified(from=>$file,to=>File::Spec->catfile($self->blib,$files->{$file}))}}sub process_support_files {my$self=shift;my$p=$self->{properties};return unless$p->{c_source};my$files;if (ref($p->{c_source})eq "ARRAY"){push @{$p->{include_dirs}},@{$p->{c_source}};for my$path (@{$p->{c_source}}){push @$files,@{$self->rscan_dir($path,$self->file_qr('\.c(c|p|pp|xx|\+\+)?$'))}}}else {push @{$p->{include_dirs}},$p->{c_source};$files=$self->rscan_dir($p->{c_source},$self->file_qr('\.c(c|p|pp|xx|\+\+)?$'))}for my$file (@$files){push @{$p->{objects}},$self->compile_c($file)}}sub process_share_dir_files {my$self=shift;my$files=$self->_find_share_dir_files;return unless$files;my$share_prefix=File::Spec->catdir($self->blib,qw/lib auto share/);for my$file (sort keys %$files){$self->copy_if_modified(from=>$file,to=>File::Spec->catfile($share_prefix,$files->{$file}))}}sub _find_share_dir_files {my$self=shift;my$share_dir=$self->share_dir;return unless$share_dir;my@file_map;if ($share_dir->{dist}){my$prefix="dist/".$self->dist_name;push@file_map,$self->_share_dir_map($prefix,$share_dir->{dist})}if ($share_dir->{module}){for my$mod (sort keys %{$share_dir->{module}}){(my$altmod=$mod)=~ s{::}{-}g;my$prefix="module/$altmod";push@file_map,$self->_share_dir_map($prefix,$share_dir->{module}{$mod})}}return {@file_map }}sub _share_dir_map {my ($self,$prefix,$list)=@_;my%files;for my$dir (@$list){for my$f (@{$self->rscan_dir($dir,sub {-f})}){$f =~ s{\A.*?\Q$dir\E/}{};$files{"$dir/$f"}="$prefix/$f"}}return%files}sub process_PL_files {my ($self)=@_;my$files=$self->find_PL_files;for my$file (sort keys %$files){my$to=$files->{$file};unless ($self->up_to_date($file,$to)){$self->run_perl_script($file,[],[@$to])or die "$file failed";$self->add_to_cleanup(@$to)}}}sub process_xs_files {my$self=shift;return if$self->pureperl_only && $self->allow_pureperl;my$files=$self->find_xs_files;croak 'Can\'t build xs files under --pureperl-only' if %$files && $self->pureperl_only;for my$from (sort keys %$files){my$to=$files->{$from};unless ($from eq $to){$self->add_to_cleanup($to);$self->copy_if_modified(from=>$from,to=>$to)}$self->process_xs($to)}}sub process_pod_files {shift()->process_files_by_extension(shift())}sub process_pm_files {shift()->process_files_by_extension(shift())}sub process_script_files {my$self=shift;my$files=$self->find_script_files;return unless keys %$files;my$script_dir=File::Spec->catdir($self->blib,'script');File::Path::mkpath($script_dir);for my$file (sort keys %$files){my$result=$self->copy_if_modified($file,$script_dir,'flatten')or next;$self->fix_shebang_line($result)unless$self->is_vmsish;$self->make_executable($result)}}sub find_PL_files {my$self=shift;if (my$files=$self->{properties}{PL_files}){if (ref$files eq 'ARRAY'){return {map {$_,[/^(.*)\.PL$/]}map$self->localize_file_path($_),@$files }}elsif (ref$files eq 'HASH'){my%out;while (my ($file,$to)=each %$files){$out{$self->localize_file_path($file)}=[map$self->localize_file_path($_),ref$to ? @$to : ($to)]}return \%out}else {die "'PL_files' must be a hash reference or array reference"}}return unless -d 'lib';return {map {$_,[/^(.*)\.PL$/i ]}@{$self->rscan_dir('lib',$self->file_qr('\.PL$'))}}}sub find_pm_files {shift->_find_file_by_type('pm','lib')}sub find_pod_files {shift->_find_file_by_type('pod','lib')}sub find_xs_files {shift->_find_file_by_type('xs','lib')}sub find_script_files {my$self=shift;if (my$files=$self->script_files){return {map {$self->localize_file_path($_),$files->{$_}}keys %$files }}return {}}sub find_test_files {my$self=shift;my$p=$self->{properties};if (my$files=$p->{test_files}){$files=[sort keys %$files]if ref$files eq 'HASH';$files=[map {-d $_ ? $self->expand_test_dir($_): $_}map glob,$self->split_like_shell($files)];return [map$self->localize_file_path($_),@$files ]}else {my@tests;push@tests,'test.pl' if -e 'test.pl';push@tests,$self->expand_test_dir('t')if -e 't' and -d _;return \@tests}}sub _find_file_by_type {my ($self,$type,$dir)=@_;if (my$files=$self->{properties}{"${type}_files"}){return {map$self->localize_file_path($_),%$files }}return {}unless -d $dir;return {map {$_,$_}map$self->localize_file_path($_),grep!/\.\#/,@{$self->rscan_dir($dir,$self->file_qr("\\.$type\$"))}}}sub localize_file_path {my ($self,$path)=@_;return File::Spec->catfile(split m{/},$path)}sub localize_dir_path {my ($self,$path)=@_;return File::Spec->catdir(split m{/},$path)}sub fix_shebang_line {my ($self,@files)=@_;my$c=ref($self)? $self->{config}: 'Module::Build::Config';my ($does_shbang)=$c->get('sharpbang')=~ /^\s*\#\!/;for my$file (@files){open(my$FIXIN,'<',$file)or die "Can't process '$file': $!";local $/="\n";chomp(my$line=<$FIXIN>);next unless$line =~ s/^\s*\#!\s*//;my ($cmd,$arg)=(split(' ',$line,2),'');next unless$cmd =~ /perl/i;my$interpreter=$self->{properties}{perl};$self->log_verbose("Changing sharpbang in $file to $interpreter\n");my$shb='';$shb .= $c->get('sharpbang')."$interpreter $arg\n" if$does_shbang;open(my$FIXOUT,'>',"$file.new")or die "Can't create new $file: $!\n";local $\;undef $/;print$FIXOUT $shb,<$FIXIN>;close$FIXIN;close$FIXOUT;rename($file,"$file.bak")or die "Can't rename $file to $file.bak: $!";rename("$file.new",$file)or die "Can't rename $file.new to $file: $!";$self->delete_filetree("$file.bak")or $self->log_warn("Couldn't clean up $file.bak, leaving it there");$self->do_system($c->get('eunicefix'),$file)if$c->get('eunicefix')ne ':'}}sub ACTION_testpod {my$self=shift;$self->depends_on('docs');eval q{use Test::Pod 0.95; 1} or die "The 'testpod' action requires Test::Pod version 0.95";my@files=sort keys %{$self->_find_pods($self->libdoc_dirs)},keys %{$self->_find_pods ($self->bindoc_dirs,exclude=>[$self->file_qr('\.bat$')])}or die "Couldn't find any POD files to test\n";{package Module::Build::PodTester;Test::Pod->import(tests=>scalar@files);pod_file_ok($_)foreach@files}}sub ACTION_testpodcoverage {my$self=shift;$self->depends_on('docs');eval q{use Test::Pod::Coverage 1.00; 1} or die "The 'testpodcoverage' action requires ","Test::Pod::Coverage version 1.00";local@INC=@INC;my$p=$self->{properties};unshift(@INC,File::Spec->catdir($p->{base_dir},$self->blib,'lib'),);all_pod_coverage_ok()}sub ACTION_docs {my$self=shift;$self->depends_on('code');$self->depends_on('manpages','html')}sub _is_default_installable {my$self=shift;my$type=shift;return ($self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs)->{$type}))? 1 : 0}sub _is_ActivePerl {my$self=shift;unless (exists($self->{_is_ActivePerl})){$self->{_is_ActivePerl}=(eval {require ActivePerl::DocTools}|| 0)}return$self->{_is_ActivePerl}}sub _is_ActivePPM {my$self=shift;unless (exists($self->{_is_ActivePPM})){$self->{_is_ActivePPM}=(eval {require ActivePerl::PPM}|| 0)}return$self->{_is_ActivePPM}}sub ACTION_manpages {my$self=shift;return unless$self->_mb_feature('manpage_support');$self->depends_on('code');my%extra_manify_args=$self->{properties}{'extra_manify_args'}? %{$self->{properties}{'extra_manify_args'}}: ();for my$type (qw(bin lib)){next unless ($self->invoked_action eq 'manpages' || $self->_is_default_installable("${type}doc"));my$files=$self->_find_pods($self->{properties}{"${type}doc_dirs"},exclude=>[$self->file_qr('\.bat$')]);next unless %$files;my$sub=$self->can("manify_${type}_pods");$self->$sub(%extra_manify_args)if defined($sub)}}sub manify_bin_pods {my$self=shift;my%podman_args=(section=>1,@_);my$files=$self->_find_pods($self->{properties}{bindoc_dirs},exclude=>[$self->file_qr('\.bat$')]);return unless keys %$files;my$mandir=File::Spec->catdir($self->blib,'bindoc');File::Path::mkpath($mandir,0,oct(777));require Pod::Man;for my$file (sort keys %$files){my$parser=Pod::Man->new(%podman_args);my$manpage=$self->man1page_name($file).'.' .$self->config('man1ext');my$outfile=File::Spec->catfile($mandir,$manpage);next if$self->up_to_date($file,$outfile);$self->log_verbose("Manifying $file -> $outfile\n");eval {$parser->parse_from_file($file,$outfile);1}or $self->log_warn("Error creating '$outfile': $@\n");$files->{$file}=$outfile}}sub manify_lib_pods {my$self=shift;my%podman_args=(section=>3,@_);my$files=$self->_find_pods($self->{properties}{libdoc_dirs});return unless keys %$files;my$mandir=File::Spec->catdir($self->blib,'libdoc');File::Path::mkpath($mandir,0,oct(777));require Pod::Man;for my$file (sort keys %$files){my$parser=Pod::Man->new(%podman_args);my$manpage=$self->man3page_name($files->{$file}).'.' .$self->config('man3ext');my$outfile=File::Spec->catfile($mandir,$manpage);next if$self->up_to_date($file,$outfile);$self->log_verbose("Manifying $file -> $outfile\n");eval {$parser->parse_from_file($file,$outfile);1}or $self->log_warn("Error creating '$outfile': $@\n");$files->{$file}=$outfile}}sub _find_pods {my ($self,$dirs,%args)=@_;my%files;for my$spec (@$dirs){my$dir=$self->localize_dir_path($spec);next unless -e $dir;FILE: foreach my$file (@{$self->rscan_dir($dir)}){for my$regexp (@{$args{exclude}}){next FILE if$file =~ $regexp}$file=$self->localize_file_path($file);$files{$file}=File::Spec->abs2rel($file,$dir)if$self->contains_pod($file)}}return \%files}sub contains_pod {my ($self,$file)=@_;return '' unless -T $file;open(my$fh,'<',$file)or die "Can't open $file: $!";while (my$line=<$fh>){return 1 if$line =~ /^\=(?:head|pod|item)/}return ''}sub ACTION_html {my$self=shift;return unless$self->_mb_feature('HTML_support');$self->depends_on('code');for my$type (qw(bin lib)){next unless ($self->invoked_action eq 'html' || $self->_is_default_installable("${type}html"));$self->htmlify_pods($type)}}sub htmlify_pods {my$self=shift;my$type=shift;my$htmldir=shift || File::Spec->catdir($self->blib,"${type}html");$self->add_to_cleanup('pod2htm*');my$pods=$self->_find_pods($self->{properties}{"${type}doc_dirs"},exclude=>[$self->file_qr('\.(?:bat|com|html)$')]);return unless %$pods;unless (-d $htmldir){File::Path::mkpath($htmldir,0,oct(755))or die "Couldn't mkdir $htmldir: $!"}my@rootdirs=($type eq 'bin')? qw(bin) : $self->installdirs eq 'core' ? qw(lib) : qw(site lib);my$podroot=$ENV{PERL_CORE}? File::Basename::dirname($ENV{PERL_CORE}): $self->original_prefix('core');my$htmlroot=$self->install_sets('core')->{libhtml};my$podpath;unless (defined$self->args('html_links')and!$self->args('html_links')){my@podpath=((map {File::Spec->abs2rel($_,$podroot)}grep {-d}($self->install_sets('core','lib'),$self->install_sets('core','bin'),$self->install_sets('site','lib'),)),File::Spec->rel2abs($self->blib));$podpath=$ENV{PERL_CORE}? File::Spec->catdir($podroot,'lib'): join(":",map {tr,:\\,|/,;$_}@podpath)}my$blibdir=join('/',File::Spec->splitdir((File::Spec->splitpath(File::Spec->rel2abs($htmldir),1))[1]),'');my ($with_ActiveState,$htmltool);if ($with_ActiveState=$self->_is_ActivePerl && eval {require ActivePerl::DocTools::Pod;1}){my$tool_v=ActiveState::DocTools::Pod->VERSION;$htmltool="ActiveState::DocTools::Pod";$htmltool .= " $tool_v" if$tool_v && length$tool_v}else {require Module::Build::PodParser;require Pod::Html;$htmltool="Pod::Html " .Pod::Html->VERSION}$self->log_verbose("Converting Pod to HTML with $htmltool\n");my$errors=0;POD: foreach my$pod (sort keys %$pods){my ($name,$path)=File::Basename::fileparse($pods->{$pod},$self->file_qr('\.(?:pm|plx?|pod)$'));my@dirs=File::Spec->splitdir(File::Spec->canonpath($path));pop(@dirs)if scalar(@dirs)&& $dirs[-1]eq File::Spec->curdir;my$fulldir=File::Spec->catdir($htmldir,@rootdirs,@dirs);my$tmpfile=File::Spec->catfile($fulldir,"${name}.tmp");my$outfile=File::Spec->catfile($fulldir,"${name}.html");my$infile=File::Spec->abs2rel($pod);next if$self->up_to_date($infile,$outfile);unless (-d $fulldir){File::Path::mkpath($fulldir,0,oct(755))or die "Couldn't mkdir $fulldir: $!"}$self->log_verbose("HTMLifying $infile -> $outfile\n");if ($with_ActiveState){my$depth=@rootdirs + @dirs;my%opts=(infile=>$infile,outfile=>$tmpfile,(defined($podpath)? (podpath=>$podpath): ()),podroot=>$podroot,index=>1,depth=>$depth,);eval {ActivePerl::DocTools::Pod::pod2html(map {($_,$opts{$_})}sort keys%opts);1}or $self->log_warn("[$htmltool] pod2html (" .join(", ",map {"q{$_} => q{$opts{$_}}"}(sort keys%opts)).") failed: $@")}else {my$path2root=File::Spec->catdir((File::Spec->updir)x @dirs);open(my$fh,'<',$infile)or die "Can't read $infile: $!";my$abstract=Module::Build::PodParser->new(fh=>$fh)->get_abstract();my$title=join('::',(@dirs,$name));$title .= " - $abstract" if$abstract;my@opts=("--title=$title",(defined($podpath)? "--podpath=$podpath" : ()),"--infile=$infile","--outfile=$tmpfile","--podroot=$podroot",($path2root ? "--htmlroot=$path2root" : ()),);unless (eval{Pod::Html->VERSION(1.12)}){push(@opts,('--flush'))}if (eval{Pod::Html->VERSION(1.12)}){push(@opts,('--header','--backlink'))}elsif (eval{Pod::Html->VERSION(1.03)}){push(@opts,('--header','--backlink=Back to Top'))}$self->log_verbose("P::H::pod2html @opts\n");{my$orig=Cwd::getcwd();eval {Pod::Html::pod2html(@opts);1}or $self->log_warn("[$htmltool] pod2html( " .join(", ",map {"q{$_}"}@opts).") failed: $@");chdir($orig)}}if (!-r $tmpfile){$errors++;next POD}open(my$fh,'<',$tmpfile)or die "Can't read $tmpfile: $!";my$html=join('',<$fh>);close$fh;if (!$self->_is_ActivePerl){$html =~ s#^<!DOCTYPE .*?>#<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">#im;$html =~ s#<html xmlns="http://www.w3.org/1999/xhtml">#<html>#i;$html =~ s#<head>#<head>\n<!-- saved from url=(0017)http://localhost/ -->#i}$html =~ s/\Q$blibdir\E//g;open($fh,'>',$outfile)or die "Can't write $outfile: $!";print$fh $html;close$fh;unlink($tmpfile)}return!$errors}sub man1page_name {my$self=shift;return File::Basename::basename(shift)}sub man3page_name {my$self=shift;my ($vol,$dirs,$file)=File::Spec->splitpath(shift);my@dirs=File::Spec->splitdir(File::Spec->canonpath($dirs));$file =~ s/\.p(?:od|m|l)\z//i;return join($self->manpage_separator,@dirs,$file)}sub manpage_separator {return '::'}sub ACTION_diff {my$self=shift;$self->depends_on('build');my$local_lib=File::Spec->rel2abs('lib');my@myINC=grep {$_ ne $local_lib}@INC;push@myINC,map$self->install_destination($_),qw(lib arch);my@flags=@{$self->{args}{ARGV}};@flags=$self->split_like_shell($self->{args}{flags}|| '')unless@flags;my$installmap=$self->install_map;delete$installmap->{read};delete$installmap->{write};my$text_suffix=$self->file_qr('\.(pm|pod)$');for my$localdir (sort keys %$installmap){my@localparts=File::Spec->splitdir($localdir);my$files=$self->rscan_dir($localdir,sub {-f});for my$file (@$files){my@parts=File::Spec->splitdir($file);@parts=@parts[@localparts .. $#parts];my$installed=Module::Metadata->find_module_by_name(join('::',@parts),\@myINC);if (not $installed){print "Only in lib: $file\n";next}my$status=File::Compare::compare($installed,$file);next if$status==0;die "Can't compare $installed and $file: $!" if$status==-1;if ($file =~ $text_suffix){$self->do_system('diff',@flags,$installed,$file)}else {print "Binary files $file and $installed differ\n"}}}}sub ACTION_pure_install {shift()->depends_on('install')}sub ACTION_install {my ($self)=@_;require ExtUtils::Install;$self->depends_on('build');$self->_do_in_dir(".",sub {ExtUtils::Install::install($self->install_map,$self->verbose,0,$self->{args}{uninst}||0)});if ($self->_is_ActivePerl && $self->{_completed_actions}{html}){$self->log_info("Building ActivePerl Table of Contents\n");eval {ActivePerl::DocTools::WriteTOC(verbose=>$self->verbose ? 1 : 0);1}or $self->log_warn("AP::DT:: WriteTOC() failed: $@")}if ($self->_is_ActivePPM){my$F_perllocal=File::Spec->catfile($self->install_sets('core','lib'),'perllocal.pod');my$dt_stamp=time;$self->log_info("For ActivePerl's PPM: touch '$F_perllocal'\n");open my$perllocal,">>",$F_perllocal;close$perllocal;utime($dt_stamp,$dt_stamp,$F_perllocal)}}sub ACTION_fakeinstall {my ($self)=@_;require ExtUtils::Install;my$eui_version=ExtUtils::Install->VERSION;if ($eui_version < 1.32){$self->log_warn("The 'fakeinstall' action requires Extutils::Install 1.32 or later.\n" ."(You only have version $eui_version).");return}$self->depends_on('build');ExtUtils::Install::install($self->install_map,!$self->quiet,1,$self->{args}{uninst}||0)}sub ACTION_versioninstall {my ($self)=@_;die "You must have only.pm 0.25 or greater installed for this operation: $@\n" unless eval {require only;'only'->VERSION(0.25);1};$self->depends_on('build');my%onlyargs=map {exists($self->{args}{$_})? ($_=>$self->{args}{$_}): ()}qw(version versionlib);only::install::install(%onlyargs)}sub ACTION_installdeps {my ($self)=@_;my$info=$self->_enum_prereqs;if (!$info){$self->log_info("No prerequisites detected\n");return}my$failures=$self->prereq_failures($info);if (!$failures){$self->log_info("All prerequisites satisfied\n");return}my@install;for my$type (sort keys %$failures){my$prereqs=$failures->{$type};if($type =~ m/^(?:\w+_)?requires$/){push(@install,sort keys %$prereqs);next}$self->log_info("Checking optional dependencies:\n");for my$module (sort keys %$prereqs){push(@install,$module)if($self->y_n("Install $module?",'y'))}}return unless@install;my ($command,@opts)=$self->split_like_shell($self->cpan_client);if (!File::Spec->file_name_is_absolute($command)){my@loc=('site','vendor','');my@bindirs=File::Basename::dirname($self->perl);push@bindirs,map {($self->config->{"install${_}bin"},$self->config->{"install${_}script"})}@loc;for my$d (@bindirs){my$abs_cmd=$self->find_command(File::Spec->catfile($d,$command));if (defined$abs_cmd){$command=$abs_cmd;last}}}$self->do_system($command,@opts,@install)}sub ACTION_clean {my ($self)=@_;$self->log_info("Cleaning up build files\n");for my$item (map glob($_),$self->cleanup){$self->delete_filetree($item)}}sub ACTION_realclean {my ($self)=@_;$self->depends_on('clean');$self->log_info("Cleaning up configuration files\n");$self->delete_filetree($self->config_dir,$self->mymetafile,$self->mymetafile2,$self->build_script)}sub ACTION_ppd {my ($self)=@_;require Module::Build::PPMMaker;my$ppd=Module::Build::PPMMaker->new();my$file=$ppd->make_ppd(%{$self->{args}},build=>$self);$self->add_to_cleanup($file)}sub ACTION_ppmdist {my ($self)=@_;$self->depends_on('build');my$ppm=$self->ppm_name;$self->delete_filetree($ppm);$self->log_info("Creating $ppm\n");$self->add_to_cleanup($ppm,"$ppm.tar.gz");my%types=(lib=>'lib',arch=>'arch',bin=>'bin',script=>'script',bindoc=>'man1',libdoc=>'man3',binhtml=>undef,libhtml=>undef,);for my$type ($self->install_types){next if exists($types{$type})&&!defined($types{$type});my$dir=File::Spec->catdir($self->blib,$type);next unless -e $dir;my$files=$self->rscan_dir($dir);for my$file (@$files){next unless -f $file;my$rel_file=File::Spec->abs2rel(File::Spec->rel2abs($file),File::Spec->rel2abs($dir));my$to_file=File::Spec->catfile($ppm,'blib',exists($types{$type})? $types{$type}: $type,$rel_file);$self->copy_if_modified(from=>$file,to=>$to_file)}}for my$type (qw(bin lib)){$self->htmlify_pods($type,File::Spec->catdir($ppm,'blib','html'))}my$target=File::Spec->catfile(File::Spec->updir,$ppm);$self->_do_in_dir($ppm,sub {$self->make_tarball('blib',$target)});$self->depends_on('ppd');$self->delete_filetree($ppm)}sub ACTION_pardist {my ($self)=@_;if (not eval {require PAR::Dist;PAR::Dist->VERSION(0.17)}){$self->log_warn("In order to create .par distributions, you need to\n" ."install PAR::Dist first.");return()}$self->depends_on('build');return PAR::Dist::blib_to_par(name=>$self->dist_name,version=>$self->dist_version,)}sub ACTION_dist {my ($self)=@_;$self->dispatch('distdir');my$dist_dir=$self->dist_dir;$self->make_tarball($dist_dir);$self->delete_filetree($dist_dir)}sub ACTION_distcheck {my ($self)=@_;$self->_check_manifest_skip unless$self->invoked_action eq 'distclean';require ExtUtils::Manifest;local $^W;my ($missing,$extra)=ExtUtils::Manifest::fullcheck();return unless @$missing || @$extra;my$msg="MANIFEST appears to be out of sync with the distribution\n";if ($self->invoked_action eq 'distcheck'){die$msg}else {warn$msg}}sub _check_mymeta_skip {my$self=shift;my$maniskip=shift || 'MANIFEST.SKIP';require ExtUtils::Manifest;local $^W;my$skip_factory=ExtUtils::Manifest->can('maniskip')|| ExtUtils::Manifest->can('_maniskip');my$mymetafile=$self->mymetafile;for my$file ($self->mymetafile,$self->mymetafile2){unless ($skip_factory && $skip_factory->($maniskip)->($file)){$self->log_warn("File '$maniskip' does not include '$file'. Adding it now.\n");my$safe=quotemeta($file);$self->_append_maniskip("^$safe\$",$maniskip)}}}sub _add_to_manifest {my ($self,$manifest,$lines)=@_;$lines=[$lines]unless ref$lines;my$existing_files=$self->_read_manifest($manifest);return unless defined($existing_files);@$lines=grep {!exists$existing_files->{$_}}@$lines or return;my$mode=(stat$manifest)[2];chmod($mode | oct(222),$manifest)or die "Can't make $manifest writable: $!";open(my$fh,'<',$manifest)or die "Can't read $manifest: $!";my$last_line=(<$fh>)[-1]|| "\n";my$has_newline=$last_line =~ /\n$/;close$fh;open($fh,'>>',$manifest)or die "Can't write to $manifest: $!";print$fh "\n" unless$has_newline;print$fh map "$_\n",@$lines;close$fh;chmod($mode,$manifest);$self->log_verbose(map "Added to $manifest: $_\n",@$lines)}sub _sign_dir {my ($self,$dir)=@_;unless (eval {require Module::Signature;1}){$self->log_warn("Couldn't load Module::Signature for 'distsign' action:\n $@\n");return}{my$manifest=File::Spec->catfile($dir,'MANIFEST');die "Signing a distribution requires a MANIFEST file" unless -e $manifest;$self->_add_to_manifest($manifest,"SIGNATURE    Added here by Module::Build")}$self->_do_in_dir($dir,sub {local$Module::Signature::Quiet=1;Module::Signature::sign()})}sub _do_in_dir {my ($self,$dir,$do)=@_;my$start_dir=File::Spec->rel2abs($self->cwd);chdir$dir or die "Can't chdir() to $dir: $!";eval {$do->()};my@err=$@ ? ($@): ();chdir$start_dir or push@err,"Can't chdir() back to $start_dir: $!";die join "\n",@err if@err}sub ACTION_distsign {my ($self)=@_;{local$self->{properties}{sign}=0;$self->depends_on('distdir')unless -d $self->dist_dir}$self->_sign_dir($self->dist_dir)}sub ACTION_skipcheck {my ($self)=@_;require ExtUtils::Manifest;local $^W;ExtUtils::Manifest::skipcheck()}sub ACTION_distclean {my ($self)=@_;$self->depends_on('realclean');$self->depends_on('distcheck')}sub do_create_makefile_pl {my$self=shift;require Module::Build::Compat;$self->log_info("Creating Makefile.PL\n");eval {Module::Build::Compat->create_makefile_pl($self->create_makefile_pl,$self,@_)};if ($@){1 while unlink 'Makefile.PL';die "$@\n"}$self->_add_to_manifest('MANIFEST','Makefile.PL')}sub do_create_license {my$self=shift;$self->log_info("Creating LICENSE file\n");if (!$self->_mb_feature('license_creation')){$self->_warn_mb_feature_deps('license_creation');die "Aborting.\n"}my$l=$self->license or die "Can't create LICENSE file: No license specified\n";my$license=$self->_software_license_object or die << "HERE";$self->delete_filetree('LICENSE');open(my$fh,'>','LICENSE')or die "Can't write LICENSE file: $!";print$fh $license->fulltext;close$fh;$self->_add_to_manifest('MANIFEST','LICENSE')}sub do_create_readme {my$self=shift;$self->delete_filetree('README');my$docfile=$self->_main_docfile;unless ($docfile){$self->log_warn(<<EOF);return}if (eval {require Pod::Readme;Pod::Readme->can('new')}){$self->log_info("Creating README using Pod::Readme\n");my$parser=Pod::Readme->new;$parser->parse_from_file($docfile,'README',@_)}elsif (eval {require Pod::Text;1}){$self->log_info("Creating README using Pod::Text\n");if (open(my$fh,'>','README')){local $^W=0;no strict "refs";my$old_parse_file;$old_parse_file=\&{"Pod::Simple::parse_file"}and local *{"Pod::Simple::parse_file"}=sub {my$self=shift;$self->output_fh($_[1])if $_[1];$self->$old_parse_file($_[0])}if$Pod::Text::VERSION ==3.01;Pod::Text::pod2text($docfile,$fh);close$fh}else {$self->log_warn("Cannot create 'README' file: Can't open file for writing\n");return}}else {$self->log_warn("Can't load Pod::Readme or Pod::Text to create README\n");return}$self->_add_to_manifest('MANIFEST','README')}sub _main_docfile {my$self=shift;if (my$pm_file=$self->dist_version_from){(my$pod_file=$pm_file)=~ s/.pm$/.pod/;return (-e $pod_file ? $pod_file : $pm_file)}else {return undef}}sub do_create_bundle_inc {my$self=shift;my$dist_inc=File::Spec->catdir($self->dist_dir,'inc');require inc::latest;inc::latest->write($dist_inc,@{$self->bundle_inc_preload});inc::latest->bundle_module($_,$dist_inc)for @{$self->bundle_inc};return 1}sub ACTION_distdir {my ($self)=@_;if (@{$self->bundle_inc}&&!$self->_mb_feature('inc_bundling_support')){$self->_warn_mb_feature_deps('inc_bundling_support');die "Aborting.\n"}$self->depends_on('distmeta');my$dist_files=$self->_read_manifest('MANIFEST')or die "Can't create distdir without a MANIFEST file - run 'manifest' action first.\n";delete$dist_files->{SIGNATURE};die "No files found in MANIFEST - try running 'manifest' action?\n" unless ($dist_files and keys %$dist_files);my$metafile=$self->metafile;$self->log_warn("*** Did you forget to add $metafile to the MANIFEST?\n")unless exists$dist_files->{$metafile};my$dist_dir=$self->dist_dir;$self->delete_filetree($dist_dir);$self->log_info("Creating $dist_dir\n");$self->add_to_cleanup($dist_dir);for my$file (sort keys %$dist_files){next if$file =~ m{^MYMETA\.};my$new=$self->copy_if_modified(from=>$file,to_dir=>$dist_dir,verbose=>0)}$self->do_create_bundle_inc if @{$self->bundle_inc};$self->_sign_dir($dist_dir)if$self->{properties}{sign}}sub ACTION_disttest {my ($self)=@_;$self->depends_on('distdir');$self->_do_in_dir ($self->dist_dir,sub {local$ENV{AUTHOR_TESTING}=1;local$ENV{RELEASE_TESTING}=1;$self->run_perl_script('Build.PL')or die "Error executing 'Build.PL' in dist directory: $!";$self->run_perl_script($self->build_script)or die "Error executing $self->build_script in dist directory: $!";$self->run_perl_script($self->build_script,[],['test'])or die "Error executing 'Build test' in dist directory"})}sub ACTION_distinstall {my ($self,@args)=@_;$self->depends_on('distdir');$self->_do_in_dir ($self->dist_dir,sub {$self->run_perl_script('Build.PL')or die "Error executing 'Build.PL' in dist directory: $!";$self->run_perl_script($self->build_script)or die "Error executing $self->build_script in dist directory: $!";$self->run_perl_script($self->build_script,[],['install'])or die "Error executing 'Build install' in dist directory"})}sub _eumanifest_has_include {my$self=shift;require ExtUtils::Manifest;return eval {ExtUtils::Manifest->VERSION(1.50);1}}sub _default_maniskip {my$self=shift;my$default_maniskip;for my$dir (@INC){$default_maniskip=File::Spec->catfile($dir,"ExtUtils","MANIFEST.SKIP");last if -r $default_maniskip}return$default_maniskip}sub _slurp {my$self=shift;my$file=shift;my$mode=shift || "";open my$fh,"<$mode",$file or croak "Can't open $file for reading: $!";local $/;return <$fh>}sub _spew {my$self=shift;my$file=shift;my$content=shift || "";my$mode=shift || "";open my$fh,">$mode",$file or croak "Can't open $file for writing: $!";print {$fh}$content;close$fh}sub _case_tolerant {my$self=shift;if (ref$self){$self->{_case_tolerant}=File::Spec->case_tolerant unless defined($self->{_case_tolerant});return$self->{_case_tolerant}}else {return File::Spec->case_tolerant}}sub _append_maniskip {my$self=shift;my$skip=shift;my$file=shift || 'MANIFEST.SKIP';return unless defined$skip && length$skip;open(my$fh,'>>',$file)or die "Can't open $file: $!";print$fh "$skip\n";close$fh}sub _write_default_maniskip {my$self=shift;my$file=shift || 'MANIFEST.SKIP';open(my$fh,'>',$file)or die "Can't open $file: $!";my$content=$self->_eumanifest_has_include ? "#!include_default\n" : $self->_slurp($self->_default_maniskip);$content .= <<'EOF';$content .= '\b'.$self->dist_name.'-[\d\.\_]+'."\n";print$fh $content;close$fh;return}sub _check_manifest_skip {my ($self)=@_;my$maniskip='MANIFEST.SKIP';if (!-e $maniskip){$self->log_warn("File '$maniskip' does not exist: Creating a temporary '$maniskip'\n");$self->_write_default_maniskip($maniskip);$self->_unlink_on_exit($maniskip)}else {$self->_check_mymeta_skip($maniskip)}return}sub ACTION_manifest {my ($self)=@_;$self->_check_manifest_skip;require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);ExtUtils::Manifest::mkmanifest()}sub ACTION_manifest_skip {my ($self)=@_;if (-e 'MANIFEST.SKIP'){$self->log_warn("MANIFEST.SKIP already exists.\n");return 0}$self->log_info("Creating a new MANIFEST.SKIP file\n");return$self->_write_default_maniskip;return -e 'MANIFEST.SKIP'}sub file_qr {return shift->{_case_tolerant}? qr($_[0])i : qr($_[0])}sub dist_dir {my ($self)=@_;my$dir=join "-",$self->dist_name,$self->dist_version;$dir .= "-" .$self->dist_suffix if$self->dist_suffix;return$dir}sub ppm_name {my$self=shift;return 'PPM-' .$self->dist_dir}sub _files_in {my ($self,$dir)=@_;return unless -d $dir;local*DH;opendir DH,$dir or die "Can't read directory $dir: $!";my@files;while (defined (my$file=readdir DH)){my$full_path=File::Spec->catfile($dir,$file);next if -d $full_path;push@files,$full_path}return@files}sub share_dir {my$self=shift;my$p=$self->{properties};$p->{share_dir}=shift if @_;if (!defined$p->{share_dir}){return}elsif (!ref$p->{share_dir}){$p->{share_dir}={dist=>[$p->{share_dir}]}}elsif (ref$p->{share_dir}eq 'ARRAY'){$p->{share_dir}={dist=>$p->{share_dir}}}elsif (ref$p->{share_dir}eq 'HASH'){my$share_dir=$p->{share_dir};if (defined$share_dir->{dist}){if (!ref$share_dir->{dist}){$share_dir->{dist}=[$share_dir->{dist}]}elsif (ref$share_dir->{dist}ne 'ARRAY'){die "'dist' key in 'share_dir' must be scalar or arrayref"}}if (defined$share_dir->{module}){my$mod_hash=$share_dir->{module};if (ref$mod_hash eq 'HASH'){for my$k (sort keys %$mod_hash){if (!ref$mod_hash->{$k}){$mod_hash->{$k}=[$mod_hash->{$k}]}elsif(ref$mod_hash->{$k}ne 'ARRAY'){die "modules in 'module' key of 'share_dir' must be scalar or arrayref"}}}else {die "'module' key in 'share_dir' must be hashref"}}}else {die "'share_dir' must be hashref, arrayref or string"}return$p->{share_dir}}sub script_files {my$self=shift;for ($self->{properties}{script_files}){$_=shift if @_;next unless $_;return $_ if ref $_ eq 'HASH';return $_={map {$_,1}@$_ }if ref $_ eq 'ARRAY';die "'script_files' must be a hashref, arrayref, or string" if ref();return $_={map {$_,1}$self->_files_in($_)}if -d $_;return $_={$_=>1}}my%pl_files=map {File::Spec->canonpath($_)=>1}keys %{$self->PL_files || {}};my@bin_files=$self->_files_in('bin');my%bin_map=map {$_=>File::Spec->canonpath($_)}@bin_files;return $_={map {$_=>1}grep!$pl_files{$bin_map{$_}},@bin_files }}BEGIN {*scripts=\&script_files}{my%licenses=(perl=>'Perl_5',apache=>'Apache_2_0',apache_1_1=>'Apache_1_1',artistic=>'Artistic_1',artistic_2=>'Artistic_2',lgpl=>'LGPL_2_1',lgpl2=>'LGPL_2_1',lgpl3=>'LGPL_3_0',bsd=>'BSD',gpl=>'GPL_1',gpl2=>'GPL_2',gpl3=>'GPL_3',mit=>'MIT',mozilla=>'Mozilla_1_1',restrictive=>'Restricted',open_source=>undef,unrestricted=>undef,unknown=>undef,);my%license_urls=(perl=>'http://dev.perl.org/licenses/',apache=>'http://apache.org/licenses/LICENSE-2.0',apache_1_1=>'http://apache.org/licenses/LICENSE-1.1',artistic=>'http://opensource.org/licenses/artistic-license.php',artistic_2=>'http://opensource.org/licenses/artistic-license-2.0.php',lgpl=>'http://opensource.org/licenses/lgpl-license.php',lgpl2=>'http://opensource.org/licenses/lgpl-2.1.php',lgpl3=>'http://opensource.org/licenses/lgpl-3.0.html',bsd=>'http://opensource.org/licenses/bsd-license.php',gpl=>'http://opensource.org/licenses/gpl-license.php',gpl2=>'http://opensource.org/licenses/gpl-2.0.php',gpl3=>'http://opensource.org/licenses/gpl-3.0.html',mit=>'http://opensource.org/licenses/mit-license.php',mozilla=>'http://opensource.org/licenses/mozilla1.1.php',restrictive=>undef,open_source=>undef,unrestricted=>undef,unknown=>undef,);sub valid_licenses {return \%licenses}sub _license_url {return$license_urls{$_[1]}}}sub _software_license_class {my ($self,$license)=@_;if ($self->valid_licenses->{$license}&& eval {require Software::LicenseUtils;Software::LicenseUtils->VERSION(0.103009)}){my@classes=Software::LicenseUtils->guess_license_from_meta_key($license,1);if (@classes==1){eval "require $classes[0]";return$classes[0]}}LICENSE: for my$l ($self->valid_licenses->{$license },$license){next unless defined$l;my$trial="Software::License::" .$l;if (eval "require Software::License; Software::License->VERSION(0.014); require $trial; 1"){return$trial}}return}sub _software_license_object {my ($self)=@_;return unless defined(my$license=$self->license);my$class=$self->_software_license_class($license)or return;my$author=join(" & ",@{$self->dist_author})|| 'unknown';my$sl=eval {$class->new({holder=>$author})};if ($@){$self->log_warn("Error getting '$class' object: $@")}return$sl}sub _hash_merge {my ($self,$h,$k,$v)=@_;if (ref$h->{$k}eq 'ARRAY'){push @{$h->{$k}},ref$v ? @$v : $v}elsif (ref$h->{$k}eq 'HASH'){$h->{$k}{$_}=$v->{$_}foreach keys %$v}else {$h->{$k}=$v}}sub ACTION_distmeta {my ($self)=@_;$self->do_create_makefile_pl if$self->create_makefile_pl;$self->do_create_readme if$self->create_readme;$self->do_create_license if$self->create_license;$self->do_create_metafile}sub do_create_metafile {my$self=shift;return if$self->{wrote_metadata};my$p=$self->{properties};unless ($p->{license}){$self->log_warn("No license specified, setting license = 'unknown'\n");$p->{license}='unknown'}my@metafiles=($self->metafile,$self->metafile2);$self->delete_filetree($_)for@metafiles;local@INC=@INC;if (($self->module_name || '')eq 'Module::Build'){$self->depends_on('config_data');push@INC,File::Spec->catdir($self->blib,'lib')}my$meta_obj=$self->_get_meta_object(quiet=>1,fatal=>1,auto=>1);my@created=$self->_write_meta_files($meta_obj,'META');if (@created){$self->{wrote_metadata}=1;$self->_add_to_manifest('MANIFEST',$_)for@created}return 1}sub _write_meta_files {my$self=shift;my ($meta,$file)=@_;$file =~ s{\.(?:yml|json)$}{};my@created;push@created,"$file\.yml" if$meta && $meta->save("$file\.yml",{version=>"1.4"});push@created,"$file\.json" if$meta && $meta->save("$file\.json");if (@created){$self->log_info("Created " .join(" and ",@created)."\n")}return@created}sub _get_meta_object {my$self=shift;my%args=@_;return unless$self->try_require("CPAN::Meta","2.142060");my$meta;eval {my$data=$self->get_metadata(fatal=>$args{fatal},auto=>$args{auto},);$data->{dynamic_config}=$args{dynamic}if defined$args{dynamic};$meta=CPAN::Meta->create($data)};if ($@ &&!$args{quiet}){$self->log_warn("Could not get valid metadata. Error is: $@\n")}return$meta}sub read_metafile {my$self=shift;my ($metafile)=@_;return unless$self->try_require("CPAN::Meta","2.110420");my$meta=CPAN::Meta->load_file($metafile);return$meta->as_struct({version=>"2.0"})}sub normalize_version {my ($self,$version)=@_;$version=0 unless defined$version and length$version;if ($version =~ /[=<>!,]/){}elsif (ref$version eq 'version'){$version=$version->is_qv ? $version->normal : $version->stringify}elsif ($version =~ /^[^v][^.]*\.[^.]+\./){$version="v$version"}else {}return$version}my%prereq_map=(requires=>[qw/runtime requires/],configure_requires=>[qw/configure requires/],build_requires=>[qw/build requires/ ],test_requires=>[qw/test requires/ ],test_recommends=>[qw/test recommends/ ],recommends=>[qw/runtime recommends/ ],conflicts=>[qw/runtime conflicts/ ],);sub _normalize_prereqs {my ($self)=@_;my$p=$self->{properties};my%prereq_types;for my$type ('configure_requires',@{$self->prereq_action_types}){if (exists$p->{$type}and keys %{$p->{$type}}){my ($phase,$relation)=@{$prereq_map{$type}};for my$mod (keys %{$p->{$type}}){$prereq_types{$phase}{$relation}{$mod}=$self->normalize_version($p->{$type}{$mod})}}}return \%prereq_types}sub _get_license {my$self=shift;my$license=$self->license;my ($meta_license,$meta_license_url);my$valid_licenses=$self->valid_licenses();if (my$sl=$self->_software_license_object){$meta_license=$sl->meta2_name;$meta_license_url=$sl->url}elsif (exists$valid_licenses->{$license}){$meta_license=$valid_licenses->{$license}? lc$valid_licenses->{$license}: $license;$meta_license_url=$self->_license_url($license)}else {$self->log_warn("Can not determine license type for '" .$self->license ."'\nSetting META license field to 'unknown'.\n");$meta_license='unknown'}return ($meta_license,$meta_license_url)}sub get_metadata {my ($self,%args)=@_;my$fatal=$args{fatal}|| 0;my$p=$self->{properties};$self->auto_config_requires if$args{auto};for my$f (qw(dist_name dist_version dist_author dist_abstract license)){my$field=$self->$f();unless (defined$field and length$field){my$err="ERROR: Missing required field '$f' for metafile\n";if ($fatal){die$err}else {$self->log_warn($err)}}}my%metadata=(name=>$self->dist_name,version=>$self->normalize_version($self->dist_version),author=>$self->dist_author,abstract=>$self->dist_abstract,generated_by=>"Module::Build version $Module::Build::VERSION",'meta-spec'=>{version=>'2',url=>'http://search.cpan.org/perldoc?CPAN::Meta::Spec',},dynamic_config=>exists$p->{dynamic_config}? $p->{dynamic_config}: 1,release_status=>$self->release_status,);my ($meta_license,$meta_license_url)=$self->_get_license;$metadata{license}=[$meta_license ];$metadata{resources}{license}=[$meta_license_url ]if defined$meta_license_url;$metadata{prereqs}=$self->_normalize_prereqs;if (exists$p->{no_index}){$metadata{no_index}=$p->{no_index}}elsif (my$pkgs=eval {$self->find_dist_packages}){$metadata{provides}=$pkgs if %$pkgs}else {$self->log_warn("$@\nWARNING: Possible missing or corrupt 'MANIFEST' file.\n" ."Nothing to enter for 'provides' field in metafile.\n")}if (my$add=$self->meta_add){if (not exists$add->{'meta-spec'}or $add->{'meta-spec'}{version}!=2){require CPAN::Meta::Converter;if (CPAN::Meta::Converter->VERSION('2.141170')){$add=CPAN::Meta::Converter->new($add)->upgrade_fragment;delete$add->{prereqs}}else {$self->log_warn("Can't meta_add without CPAN::Meta 2.141170")}}while (my($k,$v)=each %{$add}){$metadata{$k}=$v}}if (my$merge=$self->meta_merge){if (eval {require CPAN::Meta::Merge}){%metadata=%{CPAN::Meta::Merge->new(default_version=>'1.4')->merge(\%metadata,$merge)}}else {$self->log_warn("Can't merge without CPAN::Meta::Merge")}}return \%metadata}sub prepare_metadata {my ($self,$node,$keys,$args)=@_;unless (ref$node eq 'HASH'){croak "prepare_metadata() requires a hashref argument to hold output\n"}croak 'Keys argument to prepare_metadata is no longer supported' if$keys;%{$node}=%{$self->get_meta(%{$args})};return$node}sub _read_manifest {my ($self,$file)=@_;return undef unless -e $file;require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);return scalar ExtUtils::Manifest::maniread($file)}sub find_dist_packages {my$self=shift;my$manifest=$self->_read_manifest('MANIFEST')or die "Can't find dist packages without a MANIFEST file\nRun 'Build manifest' to generate one\n";my%dist_files=map {$self->localize_file_path($_)=>$_}keys %$manifest;my@pm_files=sort grep {$_ !~ m{^t}}grep {exists$dist_files{$_}}keys %{$self->find_pm_files};return$self->find_packages_in_files(\@pm_files,\%dist_files)}sub find_packages_in_files {my ($self,$file_list,$filename_map)=@_;my(%prime,%alt);for my$file (@{$file_list}){my$mapped_filename=$filename_map->{$file};my@path=split(/\//,$mapped_filename);(my$prime_package=join('::',@path[1..$#path]))=~ s/\.pm$//;my$pm_info=Module::Metadata->new_from_file($file);for my$package ($pm_info->packages_inside){next if$package eq 'main';next if$package eq 'DB';next if grep /^_/,split(/::/,$package);my$version=$pm_info->version($package);if ($package eq $prime_package){if (exists($prime{$package})){die "Unexpected conflict in '$package'; multiple versions found.\n"}else {$prime{$package}{file}=$mapped_filename;$prime{$package}{version}=$version if defined($version)}}else {push(@{$alt{$package}},{file=>$mapped_filename,version=>$version,})}}}for my$package (sort keys(%alt)){my$result=$self->_resolve_module_versions($alt{$package});if (exists($prime{$package})){if ($result->{err}){$self->log_warn("Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" .$result->{err})}elsif (defined($result->{version})){if (exists($prime{$package}{version})&& defined($prime{$package}{version})){if ($self->compare_versions($prime{$package}{version},'!=',$result->{version})){$self->log_warn("Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" ."  $result->{file} ($result->{version})\n")}}else {$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}}}else {}}else {if ($result->{err}){$self->log_warn("Found conflicting versions for package '$package'\n" .$result->{err})}$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}if defined($result->{version})}}for my$provides (values%prime){if ($provides->{version}){$provides->{version}=$self->normalize_version($provides->{version})}else {delete$provides->{version}}}return \%prime}sub _resolve_module_versions {my$self=shift;my$packages=shift;my($file,$version);my$err='';for my$p (@$packages){if (defined($p->{version})){if (defined($version)){if ($self->compare_versions($version,'!=',$p->{version})){$err .= "  $p->{file} ($p->{version})\n"}else {}}else {$file=$p->{file};$version=$p->{version}}}$file ||= $p->{file}if defined($p->{file})}if ($err){$err="  $file ($version)\n" .$err}my%result=(file=>$file,version=>$version,err=>$err);return \%result}sub make_tarball {my ($self,$dir,$file)=@_;$file ||= $dir;$self->log_info("Creating $file.tar.gz\n");if ($self->{args}{tar}){my$tar_flags=$self->verbose ? 'cvf' : 'cf';$self->do_system($self->split_like_shell($self->{args}{tar}),$tar_flags,"$file.tar",$dir);$self->do_system($self->split_like_shell($self->{args}{gzip}),"$file.tar")if$self->{args}{gzip}}else {eval {require Archive::Tar && Archive::Tar->VERSION(1.09);1}or die "You must install Archive::Tar 1.09+ to make a distribution tarball\n"."or specify a binary tar program with the '--tar' option.\n"."See the documentation for the 'dist' action.\n";my$files=$self->rscan_dir($dir);$Archive::Tar::DO_NOT_USE_PREFIX=(grep {length($_)>= 100}@$files)? 0 : 1;my$tar=Archive::Tar->new;$tar->add_files(@$files);for my$f ($tar->get_files){$f->mode($f->mode & ~022)}$tar->write("$file.tar.gz",1)}}sub install_path {my$self=shift;my($type,$value)=(@_,'<empty>');Carp::croak('Type argument missing')unless defined($type);my$map=$self->{properties}{install_path};return$map unless @_;unless (defined($value)){delete($map->{$type});return undef}if ($value eq '<empty>'){return undef unless exists$map->{$type};return$map->{$type}}return$map->{$type}=$value}sub install_sets {my ($self,$dirs,$key,$value)=@_;$dirs=$self->installdirs unless defined$dirs;if (@_==4 && defined$dirs && defined$key){$self->{properties}{install_sets}{$dirs}{$key}=$value}my$map={$self->_merge_arglist($self->{properties}{install_sets},$self->_default_install_paths->{install_sets})};if (defined$dirs && defined$key){return$map->{$dirs}{$key}}elsif (defined$dirs){return$map->{$dirs}}else {croak "Can't determine installdirs for install_sets()"}}sub original_prefix {my ($self,$key,$value)=@_;if (@_==3 && defined$key){$self->{properties}{original_prefix}{$key}=$value}my$map={$self->_merge_arglist($self->{properties}{original_prefix},$self->_default_install_paths->{original_prefix})};return$map unless defined$key;return$map->{$key}}sub install_base_relpaths {my$self=shift;if (@_ > 1){$self->_set_relpaths($self->{properties}{install_base_relpaths},@_)}my$map={$self->_merge_arglist($self->{properties}{install_base_relpaths},$self->_default_install_paths->{install_base_relpaths})};return$map unless @_;my$relpath=$map->{$_[0]};return defined$relpath ? File::Spec->catdir(@$relpath): undef}sub prefix_relpaths {my$self=shift;my$installdirs=shift || $self->installdirs or croak "Can't determine installdirs for prefix_relpaths()";if (@_ > 1){$self->{properties}{prefix_relpaths}{$installdirs}||= {};$self->_set_relpaths($self->{properties}{prefix_relpaths}{$installdirs},@_)}my$map={$self->_merge_arglist($self->{properties}{prefix_relpaths}{$installdirs},$self->_default_install_paths->{prefix_relpaths}{$installdirs})};return$map unless @_;my$relpath=$map->{$_[0]};return defined$relpath ? File::Spec->catdir(@$relpath): undef}sub _set_relpaths {my$self=shift;my($map,$type,$value)=@_;Carp::croak('Type argument missing')unless defined($type);if (!defined($value)){$map->{$type}=undef;return}else {Carp::croak("Value must be a relative path")if File::Spec::Unix->file_name_is_absolute($value);my@value=split(/\//,$value);$map->{$type}=\@value}}sub prefix_relative {my ($self,$type)=@_;my$installdirs=$self->installdirs;my$relpath=$self->install_sets($installdirs)->{$type};return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type,)}sub _prefixify {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m|/$|;$self->log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined($path)&& length($path);if(!defined($path)|| (length($path)==0)){$self->log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->log_verbose("    now $path in $rprefix\n");return$path}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return$default}}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,$relpath): undef}if ($self->prefix){my$relpath=$self->prefix_relative($type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs)->{$type}}sub install_types {my$self=shift;my%types;if ($self->install_base){%types=%{$self->install_base_relpaths}}elsif ($self->prefix){%types=%{$self->prefix_relpaths}}else {%types=%{$self->install_sets($self->installdirs)}}%types=(%types,%{$self->install_path});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my(%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push(@skipping,$type)}}$self->log_warn("WARNING: Can't figure out install path for types: @skipping\n" ."Files will not be installed.\n")if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}sub depends_on {my$self=shift;for my$action (@_){$self->_call_action($action)}}sub rscan_dir {my ($self,$dir,$pattern)=@_;my@result;local $_;my$subr=!$pattern ? sub {push@result,$File::Find::name}: !ref($pattern)|| (ref$pattern eq 'Regexp')? sub {push@result,$File::Find::name if /$pattern/}: ref($pattern)eq 'CODE' ? sub {push@result,$File::Find::name if$pattern->()}: die "Unknown pattern type";File::Find::find({wanted=>$subr,no_chdir=>1,preprocess=>sub {sort @_}},$dir);return \@result}sub delete_filetree {my$self=shift;my$deleted=0;for (@_){next unless -e $_;$self->log_verbose("Deleting $_\n");File::Path::rmtree($_,0,0);die "Couldn't remove '$_': $!\n" if -e $_;$deleted++}return$deleted}sub autosplit_file {my ($self,$file,$to)=@_;require AutoSplit;my$dir=File::Spec->catdir($to,'lib','auto');AutoSplit::autosplit($file,$dir)}sub cbuilder {my$self=shift;my$s=$self->{stash};return$s->{_cbuilder}if$s->{_cbuilder};require ExtUtils::CBuilder;return$s->{_cbuilder}=ExtUtils::CBuilder->new(config=>$self->config,($self->quiet ? (quiet=>1): ()),)}sub have_c_compiler {my ($self)=@_;my$p=$self->{properties};return$p->{_have_c_compiler}if defined$p->{_have_c_compiler};$self->log_verbose("Checking if compiler tools configured... ");my$b=$self->cbuilder;my$have=$b && eval {$b->have_compiler};$self->log_verbose($have ? "ok.\n" : "failed.\n");return$p->{_have_c_compiler}=$have}sub compile_c {my ($self,$file,%args)=@_;if (!$self->have_c_compiler){die "Error: no compiler detected to compile '$file'.  Aborting\n"}my$b=$self->cbuilder;my$obj_file=$b->object_file($file);$self->add_to_cleanup($obj_file);return$obj_file if$self->up_to_date($file,$obj_file);$b->compile(source=>$file,defines=>$args{defines},object_file=>$obj_file,include_dirs=>$self->include_dirs,extra_compiler_flags=>$self->extra_compiler_flags,);return$obj_file}sub link_c {my ($self,$spec)=@_;my$p=$self->{properties};$self->add_to_cleanup($spec->{lib_file});my$objects=$p->{objects}|| [];return$spec->{lib_file}if$self->up_to_date([$spec->{obj_file},@$objects],$spec->{lib_file});my$module_name=$spec->{module_name}|| $self->module_name;$self->cbuilder->link(module_name=>$module_name,objects=>[$spec->{obj_file},@$objects],lib_file=>$spec->{lib_file},extra_linker_flags=>$self->extra_linker_flags);return$spec->{lib_file}}sub compile_xs {my ($self,$file,%args)=@_;$self->log_verbose("$file -> $args{outfile}\n");if (eval {require ExtUtils::ParseXS;1}){ExtUtils::ParseXS::process_file(filename=>$file,prototypes=>0,output=>$args{outfile},)}else {my$xsubpp=Module::Metadata->find_module_by_name('ExtUtils::xsubpp')or die "Can't find ExtUtils::xsubpp in INC (@INC)";my@typemaps;push@typemaps,Module::Metadata->find_module_by_name('ExtUtils::typemap',\@INC);my$lib_typemap=Module::Metadata->find_module_by_name('typemap',[File::Basename::dirname($file),File::Spec->rel2abs('.')]);push@typemaps,$lib_typemap if$lib_typemap;@typemaps=map {+'-typemap',$_}@typemaps;my$cf=$self->{config};my$perl=$self->{properties}{perl};my@command=($perl,"-I".$cf->get('installarchlib'),"-I".$cf->get('installprivlib'),$xsubpp,'-noprototypes',@typemaps,$file);$self->log_info("@command\n");open(my$fh,'>',$args{outfile})or die "Couldn't write $args{outfile}: $!";print {$fh}$self->_backticks(@command);close$fh}}sub split_like_shell {my ($self,$string)=@_;return ()unless defined($string);return @$string if ref$string eq 'ARRAY';$string =~ s/^\s+|\s+$//g;return ()unless length($string);return Text::ParseWords::shellwords($string)}sub oneliner {my($self,$cmd,$switches,$args)=@_;$switches=[]unless defined$switches;$args=[]unless defined$args;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;return$self->_quote_args($perl,@$switches,'-e',$cmd,@$args)}sub run_perl_script {my ($self,$script,$preargs,$postargs)=@_;for ($preargs,$postargs){$_=[$self->split_like_shell($_)]unless ref()}return$self->run_perl_command([@$preargs,$script,@$postargs])}sub run_perl_command {my ($self,$args)=@_;$args=[$self->split_like_shell($args)]unless ref($args);my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;local$ENV{PERL5LIB}=join$self->config('path_sep'),$self->_added_to_INC;return$self->do_system($perl,@$args)}sub _infer_xs_spec {my$self=shift;my$file=shift;my$cf=$self->{config};my%spec;my($v,$d,$f)=File::Spec->splitpath($file);my@d=File::Spec->splitdir($d);(my$file_base=$f)=~ s/\.[^.]+$//i;$spec{base_name}=$file_base;$spec{src_dir}=File::Spec->catpath($v,$d,'');shift(@d)while@d && ($d[0]eq 'lib' || $d[0]eq '');pop(@d)while@d && $d[-1]eq '';$spec{module_name}=join('::',(@d,$file_base));$spec{archdir}=File::Spec->catdir($self->blib,'arch','auto',@d,$file_base);$spec{c_file}=File::Spec->catfile($spec{src_dir},"${file_base}.c");$spec{obj_file}=File::Spec->catfile($spec{src_dir},"${file_base}".$cf->get('obj_ext'));require DynaLoader;my$modfname=defined&DynaLoader::mod2fname ? DynaLoader::mod2fname([@d,$file_base]): $file_base;$spec{bs_file}=File::Spec->catfile($spec{archdir},"$modfname.bs");$spec{lib_file}=File::Spec->catfile($spec{archdir},"$modfname.".$cf->get('dlext'));return \%spec}sub process_xs {my ($self,$file)=@_;my$spec=$self->_infer_xs_spec($file);(my$file_base=$file)=~ s/\.[^.]+$//;$self->add_to_cleanup($spec->{c_file});unless ($self->up_to_date($file,$spec->{c_file})){$self->compile_xs($file,outfile=>$spec->{c_file})}my$v=$self->dist_version;$self->compile_c($spec->{c_file},defines=>{VERSION=>qq{"$v"},XS_VERSION=>qq{"$v"}});File::Path::mkpath($spec->{archdir},0,oct(777))unless -d $spec->{archdir};$self->add_to_cleanup($spec->{bs_file});unless ($self->up_to_date($file,$spec->{bs_file})){require ExtUtils::Mkbootstrap;$self->log_info("ExtUtils::Mkbootstrap::Mkbootstrap('$spec->{bs_file}')\n");ExtUtils::Mkbootstrap::Mkbootstrap($spec->{bs_file});open(my$fh,'>>',$spec->{bs_file});utime((time)x2,$spec->{bs_file})}$self->link_c($spec)}sub do_system {my ($self,@cmd)=@_;$self->log_verbose("@cmd\n");my%seen;my$sep=$self->config('path_sep');local$ENV{PERL5LIB}=(!exists($ENV{PERL5LIB})? '' : length($ENV{PERL5LIB})< 500 ? $ENV{PERL5LIB}: join$sep,grep {!$seen{$_}++ and -d $_}split($sep,$ENV{PERL5LIB}));my$status=system(@cmd);if ($status and $! =~ /Argument list too long/i){my$env_entries='';for (sort keys%ENV){$env_entries .= "$_=>".length($ENV{$_})."; "}warn "'Argument list' was 'too long', env lengths are $env_entries"}return!$status}sub copy_if_modified {my$self=shift;my%args=(@_ > 3 ? (@_): (from=>shift,to_dir=>shift,flatten=>shift));$args{verbose}=!$self->quiet unless exists$args{verbose};my$file=$args{from};unless (defined$file and length$file){die "No 'from' parameter given to copy_if_modified"}$args{flatten}=1 if File::Spec->file_name_is_absolute($file);my$to_path;if (defined$args{to}and length$args{to}){$to_path=$args{to}}elsif (defined$args{to_dir}and length$args{to_dir}){$to_path=File::Spec->catfile($args{to_dir},$args{flatten}? File::Basename::basename($file): $file)}else {die "No 'to' or 'to_dir' parameter given to copy_if_modified"}return if$self->up_to_date($file,$to_path);{local$self->{properties}{quiet}=1;$self->delete_filetree($to_path)}File::Path::mkpath(File::Basename::dirname($to_path),0,oct(777));$self->log_verbose("Copying $file -> $to_path\n");if ($^O eq 'os2'){chmod 0666,$to_path;File::Copy::syscopy($file,$to_path,0x1)or die "Can't copy('$file', '$to_path'): $!"}else {File::Copy::copy($file,$to_path)or die "Can't copy('$file', '$to_path'): $!"}my$mode=oct(444)| ($self->is_executable($file)? oct(111): 0);chmod($mode,$to_path);return$to_path}sub up_to_date {my ($self,$source,$derived)=@_;$source=[$source]unless ref$source;$derived=[$derived]unless ref$derived;return 0 if @$source &&!@$derived || grep {not -e}@$derived;my$most_recent_source=time / (24*60*60);for my$file (@$source){unless (-e $file){$self->log_warn("Can't find source file $file for up-to-date check");next}$most_recent_source=-M _ if -M _ < $most_recent_source}for my$derived (@$derived){return 0 if -M $derived > $most_recent_source}return 1}sub dir_contains {my ($self,$first,$second)=@_;($first,$second)=map File::Spec->canonpath($_),($first,$second);my@first_dirs=File::Spec->splitdir($first);my@second_dirs=File::Spec->splitdir($second);return 0 if@second_dirs < @first_dirs;my$is_same=($self->_case_tolerant ? sub {lc(shift())eq lc(shift())}: sub {shift()eq shift()});while (@first_dirs){return 0 unless$is_same->(shift@first_dirs,shift@second_dirs)}return 1}1;
  
  ERRORS/WARNINGS FOUND IN PREREQUISITES.  You may wish to install the versions
  of the modules indicated above before proceeding with this installation
  
  EOF
  * FATAL ERROR: Perl interpreter mismatch. Configuration was initially
    created with '$self->{properties}{perl}'
    but we are now using '$perl'.  You must
    run 'Build realclean' or 'make realclean' and re-configure.
  DIEFATAL
  * WARNING: Configuration was initially created with Module::Build
    version '$self->{properties}{mb_version}' but we are now using version '$mb_version'.
    If errors occur, you must re-run the Build.PL or Makefile.PL script.
  MISMATCH
  ERROR: This build seems to be unattended, but there is no default value
  for this question.  Aborting.
  EOF
  package $opts{class};
  use $pack;
  \@ISA = qw($pack);
  $opts{code}
  1;
  EOF
  No 'module_name' was provided and it could not be inferred
  from other properties.  This will prevent a packlist from
  being written for this file.  Please set either 'module_name'
  or 'dist_version_from' in Build.PL.
  END_WARN
  Bundling in inc/ is disabled because ExtUtils::Installed could not
  create a list of your installed modules.  Here is the error:
  $@
  EUI_ERROR
  Could not find a packlist for '$mod'.  If it's a core module, try
  force installing it from CPAN.
  NO_PACKLIST
  Module::Build was not found in configure_requires! Adding it now
  automatically as: configure_requires => { 'Module::Build' => $ver }
  EOM
  Warning: ExtUtils::CBuilder not installed or no compiler detected
  Proceeding with configuration, but compilation may fail during Build
  
  EOM
  $shebang
  
  use strict;
  use Cwd;
  use File::Basename;
  use File::Spec;
  
  sub magic_number_matches {
    return 0 unless -e '$q{magic_numfile}';
    my \$FH;
    open \$FH, '<','$q{magic_numfile}' or return 0;
    my \$filenum = <\$FH>;
    close \$FH;
    return \$filenum == $magic_number;
  }
  
  my \$progname;
  my \$orig_dir;
  BEGIN {
    \$^W = 1;  # Use warnings
    \$progname = basename(\$0);
    \$orig_dir = Cwd::cwd();
    my \$base_dir = '$q{base_dir}';
    if (!magic_number_matches()) {
      unless (chdir(\$base_dir)) {
        die ("Couldn't chdir(\$base_dir), aborting\\n");
      }
      unless (magic_number_matches()) {
        die ("Configuration seems to be out of date, please re-run 'perl Build.PL' again.\\n");
      }
    }
    unshift \@INC,
      (
  $quoted_INC
      );
  }
  
  close(*DATA) unless eof(*DATA); # ensure no open handles to this script
  
  use $build_package;
  Module::Build->VERSION(q{$config_requires});
  
  # Some platforms have problems setting \$^X in shebang contexts, fix it up here
  \$^X = Module::Build->find_perl_interpreter;
  
  if (-e 'Build.PL' and not $build_package->up_to_date('Build.PL', \$progname)) {
     warn "Warning: Build.PL has been altered.  You may need to run 'perl Build.PL' again.\\n";
  }
  
  # This should have just enough arguments to be able to bootstrap the rest.
  my \$build = $build_package->resume (
    properties => {
      config_dir => '$q{config_dir}',
      orig_dir => \$orig_dir,
    },
  );
  
  \$build->dispatch;
  EOF
  
   Usage: $0 <action> --arg1=value --arg2=value ...
   Example: $0 test --verbose=1
  
   Actions defined:
  EOF
  Can't create LICENSE file: '$l' is not a valid license key
  or Software::License subclass;
  HERE
  Cannot create README: can't determine which file contains documentation;
  Must supply either 'dist_version_from', or 'module_name' parameter.
  EOF
  # Avoid configuration metadata file
  ^MYMETA\.
  
  # Avoid Module::Build generated and utility files.
  \bBuild$
  \bBuild.bat$
  \b_build
  \bBuild.COM$
  \bBUILD.COM$
  \bbuild.com$
  ^MANIFEST\.SKIP
  
  # Avoid archives of this distribution
  EOF
MODULE_BUILD_BASE

$fatpacked{"Module/Build/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COMPAT';
  package Module::Build::Compat;use strict;use warnings;our$VERSION='0.03';use File::Basename ();use File::Spec;use Config;use Module::Build;use Module::Metadata;use version;use Data::Dumper;my%convert_installdirs=(PERL=>'core',SITE=>'site',VENDOR=>'vendor',);my%makefile_to_build=(TEST_VERBOSE=>'verbose',VERBINST=>'verbose',INC=>sub {map {(extra_compiler_flags=>$_)}Module::Build->split_like_shell(shift)},POLLUTE=>sub {(extra_compiler_flags=>'-DPERL_POLLUTE')},INSTALLDIRS=>sub {(installdirs=>$convert_installdirs{uc shift()})},LIB=>sub {my$lib=shift;my%config=(installprivlib=>$lib,installsitelib=>$lib,installarchlib=>"$lib/$Config{archname}",installsitearch=>"$lib/$Config{archname}");return map {(config=>"$_=$config{$_}")}sort keys%config},(map {my$name=$_;$name=>sub {my@ret=(config=>lc($name)."=" .shift);print STDERR "# Converted to @ret\n";return@ret}}qw(INSTALLARCHLIB INSTALLSITEARCH INSTALLVENDORARCH INSTALLPRIVLIB INSTALLSITELIB INSTALLVENDORLIB INSTALLBIN INSTALLSITEBIN INSTALLVENDORBIN INSTALLSCRIPT INSTALLSITESCRIPT INSTALLVENDORSCRIPT INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR)),map {$_,lc($_)}qw(DESTDIR PREFIX INSTALL_BASE UNINST),);my%macro_to_build=%makefile_to_build;delete$macro_to_build{LIB};sub _merge_prereq {my ($req,$breq)=@_;$req ||= {};$breq ||= {};for my$p ($req,$breq){for my$k (sort keys %$p){next if$k eq 'perl';my$v_obj=eval {version->new($p->{$k})};if (!defined$v_obj){die "A prereq of the form '$p->{$k}' for '$k' is not supported by Module::Build::Compat ( use a simpler version like '0.05' or 'v1.4.25' )\n"}if ($v_obj->is_qv){my$proper_ver=$v_obj->numify;warn "Dotted-decimal prereq '$p->{$k}' for '$k' is not portable - converting it to '$proper_ver'\n";$p->{$k}=$proper_ver}}}my$merge={%$req };for my$k (keys %$breq){my$v1=$merge->{$k}|| 0;my$v2=$breq->{$k};$merge->{$k}=$v1 > $v2 ? $v1 : $v2}return %$merge}sub create_makefile_pl {my ($package,$type,$build,%args)=@_;die "Don't know how to build Makefile.PL of type '$type'" unless$type =~ /^(small|passthrough|traditional)$/;if ($type eq 'passthrough'){$build->log_warn(<<"HERE")}my$fh;if ($args{fh}){$fh=$args{fh}}else {$args{file}||= 'Makefile.PL';local$build->{properties}{quiet}=1;$build->delete_filetree($args{file});open($fh,'>',"$args{file}")or die "Can't write $args{file}: $!"}print {$fh}"# Note: this file was auto-generated by ",__PACKAGE__," version $VERSION\n";my$requires=$build->requires;if (my$minimum_perl=$requires->{perl}){my$min_ver=version->new($minimum_perl)->numify;print {$fh}"require $min_ver;\n"}my$subclass_load='';if (ref($build)ne "Module::Build"){my$subclass_dir=$package->subclass_dir($build);if (File::Spec->file_name_is_absolute($subclass_dir)){my$base_dir=$build->base_dir;if ($build->dir_contains($base_dir,$subclass_dir)){$subclass_dir=File::Spec->abs2rel($subclass_dir,$base_dir);$subclass_dir=$package->unixify_dir($subclass_dir);$subclass_load="use lib '$subclass_dir';"}}else {$subclass_dir=$package->unixify_dir($subclass_dir);$subclass_load="use lib '$subclass_dir';"}}if ($type eq 'small'){printf {$fh}<<'EOF',$subclass_load,ref($build),ref($build)}elsif ($type eq 'passthrough'){printf {$fh}<<'EOF',$subclass_load,ref($build),ref($build)}elsif ($type eq 'traditional'){my (%MM_Args,%prereq);if (eval "use Tie::IxHash 1.2; 1"){tie%MM_Args,'Tie::IxHash';tie%prereq,'Tie::IxHash'}my%name=($build->module_name ? (NAME=>$build->module_name): (DISTNAME=>$build->dist_name));my%version=($build->dist_version_from ? (VERSION_FROM=>$build->dist_version_from): (VERSION=>$build->dist_version));%MM_Args=(%name,%version);%prereq=_merge_prereq($build->requires,$build->build_requires);%prereq=map {$_,$prereq{$_}}sort keys%prereq;delete$prereq{perl};$MM_Args{PREREQ_PM}=\%prereq;$MM_Args{INSTALLDIRS}=$build->installdirs eq 'core' ? 'perl' : $build->installdirs;$MM_Args{EXE_FILES}=[sort keys %{$build->script_files}]if$build->script_files;$MM_Args{PL_FILES}=$build->PL_files || {};if ($build->recursive_test_files){$MM_Args{test}={TESTS=>join q{ },$package->_test_globs($build)}}local$Data::Dumper::Terse=1;my$args=Data::Dumper::Dumper(\%MM_Args);$args =~ s/\{(.*)\}/($1)/s;print$fh <<"EOF"}}sub _test_globs {my ($self,$build)=@_;return map {File::Spec->catfile($_,'*.t')}@{$build->rscan_dir('t',sub {-d $File::Find::name})}}sub subclass_dir {my ($self,$build)=@_;return (Module::Metadata->find_module_dir_by_name(ref$build)|| File::Spec->catdir($build->config_dir,'lib'))}sub unixify_dir {my ($self,$path)=@_;return join '/',File::Spec->splitdir($path)}sub makefile_to_build_args {my$class=shift;my@out;for my$arg (@_){next if$arg eq '';my ($key,$val)=($arg =~ /^(\w+)=(.+)/ ? ($1,$2): die "Malformed argument '$arg'");($val)=Module::Build->_detildefy($val)if$val =~ /^~/;if (exists$makefile_to_build{$key}){my$trans=$makefile_to_build{$key};push@out,$class->_argvify(ref($trans)? $trans->($val): ($trans=>$val))}elsif (exists$Config{lc($key)}){push@out,$class->_argvify(config=>lc($key)."=$val")}else {push@out,$class->_argvify("\L$key"=>$val)}}return@out}sub _argvify {my ($self,@pairs)=@_;my@out;while (@pairs){my ($k,$v)=splice@pairs,0,2;push@out,("--$k",$v)}return@out}sub makefile_to_build_macros {my@out;my%config;for my$macro (sort keys%macro_to_build){my$trans=$macro_to_build{$macro};next unless exists$ENV{$macro}&& length$ENV{$macro};my$val=$ENV{$macro};my@args=ref($trans)? $trans->($val): ($trans=>$val);while (@args){my ($k,$v)=splice(@args,0,2);if ($k eq 'config'){if ($v =~ /^([^=]+)=(.*)$/){$config{$1}=$2}else {warn "Couldn't parse config '$v'\n"}}else {push@out,($k=>$v)}}}push@out,(config=>\%config)if%config;return@out}sub run_build_pl {my ($pack,%in)=@_;$in{script}||= 'Build.PL';my@args=$in{args}? $pack->makefile_to_build_args(@{$in{args}}): ();print "# running $in{script} @args\n";Module::Build->run_perl_script($in{script},[],\@args)or die "Couldn't run $in{script}: $!"}sub fake_makefile {my ($self,%args)=@_;unless (exists$args{build_class}){warn "Unknown 'build_class', defaulting to 'Module::Build'\n";$args{build_class}='Module::Build'}my$class=$args{build_class};my$perl=$class->find_perl_interpreter;$perl='MCR ' .$perl if$self->_is_vms_mms;my$noop=($class->is_windowsish ? 'rem>nul' : $self->_is_vms_mms ? 'Continue' : 'true');my$filetype=$class->is_vmsish ? '.COM' : '';my$Build='Build' .$filetype .' --makefile_env_macros 1';my$unlink=$class->oneliner('1 while unlink $ARGV[0]',[],[$args{makefile}]);$unlink =~ s/\$/\$\$/g unless$class->is_vmsish;my$maketext=join '',map {"$_=\n"}sort keys%macro_to_build;$maketext .= ($^O eq 'os2' ? "SHELL = sh\n\n" : $^O eq 'MSWin32' && $Config{make}=~ /gmake/ ? "SHELL = $ENV{COMSPEC}\n\n" : "\n\n");$maketext .= <<"EOF";for my$action ($class->known_actions){next if$action =~ /^(all|distclean|realclean|force_do_it)$/;$maketext .= <<"EOF"}if ($self->_is_vms_mms){$maketext .= "\n.FIRST\n\t\@ $noop\n";for my$macro (sort keys%macro_to_build){$maketext .= ".IFDEF $macro\n\tDEFINE $macro \"\$($macro)\"\n.ENDIF\n"}$maketext .= "\n"}else {$maketext .= "\n.EXPORT : " .join(' ',sort keys%macro_to_build)."\n\n"}return$maketext}sub fake_prereqs {my$file=File::Spec->catfile('_build','prereqs');open(my$fh,'<',"$file")or die "Can't read $file: $!";my$prereqs=eval do {local $/;<$fh>};close$fh;my%merged=_merge_prereq($prereqs->{requires},$prereqs->{build_requires});my@prereq;for (sort keys%merged){next if $_ eq 'perl';push@prereq,"$_=>q[$merged{$_}]"}return unless@prereq;return "#     PREREQ_PM => { " .join(", ",@prereq)." }\n\n"}sub write_makefile {my ($pack,%in)=@_;unless (exists$in{build_class}){warn "Unknown 'build_class', defaulting to 'Module::Build'\n";$in{build_class}='Module::Build'}my$class=$in{build_class};$in{makefile}||= $pack->_is_vms_mms ? 'Descrip.MMS' : 'Makefile';open MAKE,"> $in{makefile}" or die "Cannot write $in{makefile}: $!";print MAKE$pack->fake_prereqs;print MAKE$pack->fake_makefile(%in);close MAKE}sub _is_vms_mms {return Module::Build->is_vmsish && ($Config{make}=~ m/MM[SK]/i)}1;
  
  IMPORTANT NOTE: The '$type' style of Makefile.PL is deprecated and
  may be removed in a future version of Module::Build in favor of the
  'configure_requires' property.  See Module::Build::Compat
  documentation for details.
  
  HERE
      use Module::Build::Compat 0.02;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  
      unless (eval "use Module::Build::Compat 0.02; 1" ) {
        print "This module requires Module::Build to install itself.\n";
  
        require ExtUtils::MakeMaker;
        my $yn = ExtUtils::MakeMaker::prompt
  	('  Install Module::Build now from CPAN?', 'y');
  
        unless ($yn =~ /^y/i) {
  	die " *** Cannot install without Module::Build.  Exiting ...\n";
        }
  
        require Cwd;
        require File::Spec;
        require CPAN;
  
        # Save this 'cause CPAN will chdir all over the place.
        my $cwd = Cwd::cwd();
  
        CPAN::Shell->install('Module::Build::Compat');
        CPAN::Shell->expand("Module", "Module::Build::Compat")->uptodate
  	or die "Couldn't install Module::Build, giving up.\n";
  
        chdir $cwd or die "Cannot chdir() back to $cwd: $!";
      }
      eval "use Module::Build::Compat 0.02; 1" or die $@;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      my $build_script = 'Build';
      $build_script .= '.com' if $^O eq 'VMS';
      exit(0) unless(-e $build_script); # cpantesters convention
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  use ExtUtils::MakeMaker;
  WriteMakefile
  $args;
  EOF
  all : force_do_it
  	$perl $Build
  realclean : force_do_it
  	$perl $Build realclean
  	$unlink
  distclean : force_do_it
  	$perl $Build distclean
  	$unlink
  
  
  force_do_it :
  	@ $noop
  EOF
  $action : force_do_it
  	$perl $Build $action
  EOF
MODULE_BUILD_COMPAT

$fatpacked{"Module/Build/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIG';
  package Module::Build::Config;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Config;sub new {my ($pack,%args)=@_;return bless {stack=>{},values=>$args{values}|| {},},$pack}sub get {my ($self,$key)=@_;return$self->{values}{$key}if ref($self)&& exists$self->{values}{$key};return$Config{$key}}sub set {my ($self,$key,$val)=@_;$self->{values}{$key}=$val}sub push {my ($self,$key,$val)=@_;push @{$self->{stack}{$key}},$self->{values}{$key}if exists$self->{values}{$key};$self->{values}{$key}=$val}sub pop {my ($self,$key)=@_;my$val=delete$self->{values}{$key};if (exists$self->{stack}{$key}){$self->{values}{$key}=pop @{$self->{stack}{$key}};delete$self->{stack}{$key}unless @{$self->{stack}{$key}}}return$val}sub values_set {my$self=shift;return undef unless ref($self);return$self->{values}}sub all_config {my$self=shift;my$v=ref($self)? $self->{values}: {};return {%Config,%$v}}1;
MODULE_BUILD_CONFIG

$fatpacked{"Module/Build/ConfigData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIGDATA';
  package Module::Build::ConfigData;use strict;my$arrayref=eval do {local $/;<DATA>}or die "Couldn't load ConfigData data: $@";close DATA;my ($config,$features,$auto_features)=@$arrayref;sub config {$config->{$_[1]}}sub set_config {$config->{$_[1]}=$_[2]}sub set_feature {$features->{$_[1]}=0+!!$_[2]}sub auto_feature_names {sort grep!exists$features->{$_},keys %$auto_features}sub feature_names {my@features=(sort keys %$features,auto_feature_names());@features}sub config_names {sort keys %$config}sub write {my$me=__FILE__;require Data::Dumper;my$mode_orig=(stat$me)[2]& 07777;chmod($mode_orig | 0222,$me);open(my$fh,'+<',$me)or die "Can't rewrite $me: $!";seek($fh,0,0);while (<$fh>){last if /^__DATA__$/}die "Couldn't find __DATA__ token in $me" if eof($fh);seek($fh,tell($fh),0);my$data=[$config,$features,$auto_features];print($fh 'do{ my ' .Data::Dumper->new([$data],['x'])->Purity(1)->Dump().'$x; }');truncate($fh,tell($fh));close$fh;chmod($mode_orig,$me)or warn "Couldn't restore permissions on $me: $!"}sub feature {my ($package,$key)=@_;return$features->{$key}if exists$features->{$key};my$info=$auto_features->{$key}or return 0;require Module::Build;for my$type (sort keys %$info){my$prereqs=$info->{$type};next if$type eq 'description' || $type eq 'recommends';for my$modname (sort keys %$prereqs){my$status=Module::Build->check_installed_status($modname,$prereqs->{$modname});if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}__DATA__ do{ my $x = [
         {},
         {},
         {
           'HTML_support' => {
                               'description' => 'Create HTML documentation',
                               'requires' => {
                                               'Pod::Html' => 0
                                             }
                             },
           'PPM_support' => {
                              'description' => 'Generate PPM files for distributions'
                            },
           'dist_authoring' => {
                                 'description' => 'Create new distributions',
                                 'recommends' => {
                                                   'Module::Signature' => '0.21',
                                                   'Pod::Readme' => '0.04'
                                                 },
                                 'requires' => {
                                                 'Archive::Tar' => '1.09'
                                               }
                               },
           'inc_bundling_support' => {
                                       'description' => 'Bundle Module::Build in inc/',
                                       'requires' => {
                                                       'ExtUtils::Install' => '1.54',
                                                       'ExtUtils::Installed' => '1.999',
                                                       'inc::latest' => '0.5'
                                                     }
                                     },
           'license_creation' => {
                                   'description' => 'Create licenses automatically in distributions',
                                   'requires' => {
                                                   'Software::License' => '0.103009'
                                                 }
                                 },
           'manpage_support' => {
                                  'description' => 'Create Unix man pages',
                                  'requires' => {
                                                  'Pod::Man' => 0
                                                }
                                }
         }
       ];
  $x; }
MODULE_BUILD_CONFIGDATA

$fatpacked{"Module/Build/Cookbook.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COOKBOOK';
  package Module::Build::Cookbook;use strict;use warnings;our$VERSION='0.03';
MODULE_BUILD_COOKBOOK

$fatpacked{"Module/Build/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_DUMPER';
  package Module::Build::Dumper;use strict;use warnings;our$VERSION='0.03';use Data::Dumper;sub _data_dump {my ($self,$data)=@_;return ("do{ my " .Data::Dumper->new([$data],['x'])->Purity(1)->Terse(0)->Sortkeys(1)->Dump().'$x; }')}1;
MODULE_BUILD_DUMPER

$fatpacked{"Module/Build/Notes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_NOTES';
  package Module::Build::Notes;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Data::Dumper;use Module::Build::Dumper;sub new {my ($class,%args)=@_;my$file=delete$args{file}or die "Missing required parameter 'file' to new()";my$self=bless {disk=>{},new=>{},file=>$file,%args,},$class}sub restore {my$self=shift;open(my$fh,'<',$self->{file})or die "Can't read $self->{file}: $!";$self->{disk}=eval do {local $/;<$fh>};die $@ if $@;close$fh;$self->{new}={}}sub access {my$self=shift;return$self->read()unless @_;my$key=shift;return$self->read($key)unless @_;my$value=shift;$self->write({$key=>$value });return$self->read($key)}sub has_data {my$self=shift;return keys %{$self->read()}> 0}sub exists {my ($self,$key)=@_;return exists($self->{new}{$key})|| exists($self->{disk}{$key})}sub read {my$self=shift;if (@_){my$key=shift;return$self->{new}{$key}if exists$self->{new}{$key};return$self->{disk}{$key}}my$out=(keys %{$self->{new}}? {%{$self->{disk}},%{$self->{new}}}: $self->{disk});return wantarray ? %$out : $out}sub _same {my ($self,$x,$y)=@_;return 1 if!defined($x)and!defined($y);return 0 if!defined($x)or!defined($y);return$x eq $y}sub write {my ($self,$href)=@_;$href ||= {};@{$self->{new}}{keys %$href }=values %$href;for my$key (keys %{$self->{new}}){next if ref$self->{new}{$key};next if ref$self->{disk}{$key}or!exists$self->{disk}{$key};delete$self->{new}{$key}if$self->_same($self->{new}{$key},$self->{disk}{$key})}if (my$file=$self->{file}){my ($vol,$dir,$base)=File::Spec->splitpath($file);$dir=File::Spec->catpath($vol,$dir,'');return unless -e $dir && -d $dir;return if -e $file and!keys %{$self->{new}};@{$self->{disk}}{keys %{$self->{new}}}=values %{$self->{new}};$self->_dump($file,$self->{disk});$self->{new}={}}return$self->read}sub _dump {my ($self,$file,$data)=@_;open(my$fh,'>',$file)or die "Can't create '$file': $!";print {$fh}Module::Build::Dumper->_data_dump($data);close$fh}my$orig_template=do {local $/;<DATA>};close DATA;sub write_config_data {my ($self,%args)=@_;my$template=$orig_template;$template =~ s/NOTES_NAME/$args{config_module}/g;$template =~ s/MODULE_NAME/$args{module}/g;$template =~ s/=begin private\n//;$template =~ s/=end private/=cut/;$template =~ s{$_\n}{} for '=begin private','=end private';open(my$fh,'>',$args{file})or die "Can't create '$args{file}': $!";print {$fh}$template;print {$fh}"\n__DATA__\n";print {$fh}Module::Build::Dumper->_data_dump([$args{config_data},$args{feature},$args{auto_features}]);close$fh}1;__DATA__ package NOTES_NAME;
  use strict;
  my $arrayref = eval do {local $/; <DATA>}
    or die "Couldn't load ConfigData data: $@";
  close DATA;
  my ($config, $features, $auto_features) = @$arrayref;
  
  sub config { $config->{$_[1]} }
  
  sub set_config { $config->{$_[1]} = $_[2] }
  sub set_feature { $features->{$_[1]} = 0+!!$_[2] }  # Constrain to 1 or 0
  
  sub auto_feature_names { sort grep !exists $features->{$_}, keys %$auto_features }
  
  sub feature_names {
    my @features = (sort keys %$features, auto_feature_names());
    @features;
  }
  
  sub config_names  { sort keys %$config }
  
  sub write {
    my $me = __FILE__;
  
    # Can't use Module::Build::Dumper here because M::B is only a
    # build-time prereq of this module
    require Data::Dumper;
  
    my $mode_orig = (stat $me)[2] & 07777;
    chmod($mode_orig | 0222, $me); # Make it writeable
    open(my $fh, '+<', $me) or die "Can't rewrite $me: $!";
    seek($fh, 0, 0);
    while (<$fh>) {
      last if /^__DATA__$/;
    }
    die "Couldn't find __DATA__ token in $me" if eof($fh);
  
    seek($fh, tell($fh), 0);
    my $data = [$config, $features, $auto_features];
    print($fh 'do{ my '
  	      . Data::Dumper->new([$data],['x'])->Purity(1)->Dump()
  	      . '$x; }' );
    truncate($fh, tell($fh));
    close $fh;
  
    chmod($mode_orig, $me)
      or warn "Couldn't restore permissions on $me: $!";
  }
  
  sub feature {
    my ($package, $key) = @_;
    return $features->{$key} if exists $features->{$key};
  
    my $info = $auto_features->{$key} or return 0;
  
    require Module::Build;  # XXX should get rid of this
    foreach my $type (sort keys %$info) {
      my $prereqs = $info->{$type};
      next if $type eq 'description' || $type eq 'recommends';
  
      foreach my $modname (sort keys %$prereqs) {
        my $status = Module::Build->check_installed_status($modname, $prereqs->{$modname});
        if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
        if ( ! eval "require $modname; 1" ) { return 0; }
      }
    }
    return 1;
  }
  
  =begin private
  
  =head1 NAME
  
  NOTES_NAME - Configuration for MODULE_NAME
  
  =head1 SYNOPSIS
  
    use NOTES_NAME;
    $value = NOTES_NAME->config('foo');
    $value = NOTES_NAME->feature('bar');
  
    @names = NOTES_NAME->config_names;
    @names = NOTES_NAME->feature_names;
  
    NOTES_NAME->set_config(foo => $new_value);
    NOTES_NAME->set_feature(bar => $new_value);
    NOTES_NAME->write;  # Save changes
  
  
  =head1 DESCRIPTION
  
  This module holds the configuration data for the C<MODULE_NAME>
  module.  It also provides a programmatic interface for getting or
  setting that configuration data.  Note that in order to actually make
  changes, you'll have to have write access to the C<NOTES_NAME>
  module, and you should attempt to understand the repercussions of your
  actions.
  
  
  =head1 METHODS
  
  =over 4
  
  =item config($name)
  
  Given a string argument, returns the value of the configuration item
  by that name, or C<undef> if no such item exists.
  
  =item feature($name)
  
  Given a string argument, returns the value of the feature by that
  name, or C<undef> if no such feature exists.
  
  =item set_config($name, $value)
  
  Sets the configuration item with the given name to the given value.
  The value may be any Perl scalar that will serialize correctly using
  C<Data::Dumper>.  This includes references, objects (usually), and
  complex data structures.  It probably does not include transient
  things like filehandles or sockets.
  
  =item set_feature($name, $value)
  
  Sets the feature with the given name to the given boolean value.  The
  value will be converted to 0 or 1 automatically.
  
  =item config_names()
  
  Returns a list of all the names of config items currently defined in
  C<NOTES_NAME>, or in scalar context the number of items.
  
  =item feature_names()
  
  Returns a list of all the names of features currently defined in
  C<NOTES_NAME>, or in scalar context the number of features.
  
  =item auto_feature_names()
  
  Returns a list of all the names of features whose availability is
  dynamically determined, or in scalar context the number of such
  features.  Does not include such features that have later been set to
  a fixed value.
  
  =item write()
  
  Commits any changes from C<set_config()> and C<set_feature()> to disk.
  Requires write access to the C<NOTES_NAME> module.
  
  =back
  
  
  =head1 AUTHOR
  
  C<NOTES_NAME> was automatically created using C<Module::Build>.
  C<Module::Build> was written by Ken Williams, but he holds no
  authorship claim or copyright claim to the contents of C<NOTES_NAME>.
  
  =end private
  
MODULE_BUILD_NOTES

$fatpacked{"Module/Build/PPMMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PPMMAKER';
  package Module::Build::PPMMaker;use strict;use warnings;use Config;our$VERSION='0.03';$VERSION=eval$VERSION;sub new {my$package=shift;return bless {@_},$package}sub make_ppd {my ($self,%args)=@_;my$build=delete$args{build};my@codebase;if (exists$args{codebase}){@codebase=ref$args{codebase}? @{$args{codebase}}: ($args{codebase})}else {my$distfile=$build->ppm_name .'.tar.gz';print "Using default codebase '$distfile'\n";@codebase=($distfile)}my%dist;for my$info (qw(name author abstract version)){my$method="dist_$info";$dist{$info}=$build->$method()or die "Can't determine distribution's $info\n"}$self->_simple_xml_escape($_)foreach$dist{abstract},@{$dist{author}};my$ppd=<<"PPD";for my$type (qw(requires)){my$prereq=$build->$type();for my$modname (sort keys %$prereq){next if$modname eq 'perl';my$min_version='0.0';for my$c ($build->_parse_conditions($prereq->{$modname})){my ($op,$version)=$c =~ /^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x;if ($op eq '>='){$min_version=$version;last}}$modname .= '::' unless$modname =~ /::/;$ppd .= qq!        <REQUIRE NAME="$modname" VERSION="$min_version" />\n!}}if (keys %{$build->find_xs_files}){my$perl_version=$self->_ppd_version($build->perl_version);$ppd .= sprintf(<<'EOF',$self->_varchname($build->config))}for my$codebase (@codebase){$self->_simple_xml_escape($codebase);$ppd .= sprintf(<<'EOF',$codebase)}$ppd .= <<'EOF';my$ppd_file="$dist{name}.ppd";open(my$fh,'>',$ppd_file)or die "Cannot write to $ppd_file: $!";binmode($fh,":utf8")if $] >= 5.008 && $Config{useperlio};print$fh $ppd;close$fh;return$ppd_file}sub _ppd_version {my ($self,$version)=@_;return join ',',(split(/\./,$version),(0)x4)[0..3]}sub _varchname {my ($self,$config)=@_;my$varchname=$config->{archname};if ($] >= 5.008){my$vstring=sprintf "%vd",$^V;$vstring =~ s/\.\d+$//;$varchname .= "-$vstring"}return$varchname}{my%escapes=("\n"=>"\\n",'"'=>'&quot;','&'=>'&amp;','>'=>'&gt;','<'=>'&lt;',);my$rx=join '|',keys%escapes;sub _simple_xml_escape {$_[1]=~ s/($rx)/$escapes{$1}/go}}1;
  <SOFTPKG NAME=\"$dist{name}\" VERSION=\"$dist{version}\">
      <ABSTRACT>$dist{abstract}</ABSTRACT>
  @{[ join "\n", map "    <AUTHOR>$_</AUTHOR>", @{$dist{author}} ]}
      <IMPLEMENTATION>
  PPD
          <ARCHITECTURE NAME="%s" />
  EOF
          <CODEBASE HREF="%s" />
  EOF
      </IMPLEMENTATION>
  </SOFTPKG>
  EOF
MODULE_BUILD_PPMMAKER

$fatpacked{"Module/Build/Platform/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DEFAULT';
  package Module::Build::Platform::Default;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);1;
MODULE_BUILD_PLATFORM_DEFAULT

$fatpacked{"Module/Build/Platform/MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_MACOS';
  package Module::Build::Platform::MacOS;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);use ExtUtils::Install;sub have_forkpipe {0}sub new {my$class=shift;my$self=$class->SUPER::new(@_);for ('sitelib','sitearch'){$self->config($_=>$self->config("install$_"))unless$self->config($_)}(my$sp=$self->config('startperl'))=~ s/.*Exit \{Status\}\s//;$self->config(startperl=>$sp);return$self}sub make_executable {my$self=shift;require MacPerl;for (@_){MacPerl::SetFileInfo('McPL','TEXT',$_)}}sub dispatch {my$self=shift;if(!@_ and!@ARGV){require MacPerl;my@action_list=qw(build test install);my%actions=map {+($_,1)}$self->known_actions;delete@actions{@action_list};push@action_list,sort {$a cmp $b}keys%actions;my%toolserver=map {+$_=>1}qw(test disttest diff testdb);for (@action_list){$_ .= ' *' if$toolserver{$_}}my$cmd=MacPerl::Pick("What build command? ('*' requires ToolServer)",@action_list);return unless defined$cmd;$cmd =~ s/ \*$//;$ARGV[0]=($cmd);my$args=MacPerl::Ask('Any extra arguments?  (ie. verbose=1)','');return unless defined$args;push@ARGV,$self->split_like_shell($args)}$self->SUPER::dispatch(@_)}sub ACTION_realclean {my$self=shift;chmod 0666,$self->{properties}{build_script};$self->SUPER::ACTION_realclean}sub ACTION_install {my$self=shift;return$self->SUPER::ACTION_install(@_)if eval {ExtUtils::Install->VERSION('1.30');1};local $^W=0;local*ExtUtils::Install::find=sub {my ($code,@dirs)=@_;@dirs=map {$_ eq '.' ? File::Spec->curdir : $_}@dirs;return File::Find::find($code,@dirs)};return$self->SUPER::ACTION_install(@_)}1;
MODULE_BUILD_PLATFORM_MACOS

$fatpacked{"Module/Build/Platform/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_UNIX';
  package Module::Build::Platform::Unix;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);sub is_executable {my ($self,$file)=@_;return +(stat$file)[2]& 0100}sub _startperl {"#! " .shift()->perl}sub _construct {my$self=shift()->SUPER::_construct(@_);my$c=$self->{config};for (qw(siteman1 siteman3 vendorman1 vendorman3)){$c->{"install${_}dir"}||= $c->{"install${_}"}}return$self}sub _detildefy {my ($self,$value)=@_;$value =~ s[^~([^/]+)?(?=/|$)]   # tilde with optional username [$1 ? (eval{(getpwnam $1)[7]}|| "~$1"): ($ENV{HOME}|| eval{(getpwuid $>)[7]}|| glob("~"))]ex;return$value}1;
MODULE_BUILD_PLATFORM_UNIX

$fatpacked{"Module/Build/Platform/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VMS';
  package Module::Build::Platform::VMS;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Module::Build::Base;use Config;our@ISA=qw(Module::Build::Base);sub _set_defaults {my$self=shift;$self->SUPER::_set_defaults(@_);$self->{properties}{build_script}='Build.com'}sub cull_args {my$self=shift;my($action,$args)=$self->SUPER::cull_args(@_);my@possible_actions=grep {lc $_ eq lc$action}$self->known_actions;die "Ambiguous action '$action'.  Could be one of @possible_actions" if@possible_actions > 1;return ($possible_actions[0],$args)}sub manpage_separator {return '__'}sub _catprefix {my($self,$rprefix,$default)=@_;my($rvol,$rdirs)=File::Spec->splitpath($rprefix);if($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->log_verbose("  prefixify $path from $sprefix to $rprefix\n");$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->log_verbose("  rprefix translated to $rprefix\n"."  sprefix translated to $sprefix\n");if(length($path)==0){$self->log_verbose("  no path to prefixify.\n")}elsif(!File::Spec->file_name_is_absolute($path)){$self->log_verbose("    path is relative, not prefixifying.\n")}elsif($sprefix eq $rprefix){$self->log_verbose("  no new prefix.\n")}else {my($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config('vms_prefix');if($path_vol eq $vms_prefix.':'){$self->log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix($rprefix,$path_dirs)}else {$self->log_verbose("    cannot prefixify.\n");return$self->prefix_relpaths($self->installdirs,$type)}}$self->log_verbose("    now $path\n");return$path}sub _quote_args {my ($self,@args)=@_;my$got_arrayref=(scalar(@args)==1 && ref$args[0]eq 'ARRAY')? 1 : 0;map {if (!/^\//){$_ =~ s/\"/""/g;$_=q(").$_.q(")}}($got_arrayref ? @{$args[0]}: @args);return$got_arrayref ? $args[0]: join(' ',@args)}sub have_forkpipe {0}sub _backticks {my ($self,@cmd)=@_;my$cmd=shift@cmd;my$args=$self->_quote_args(@cmd);return `$cmd $args`}sub find_command {my ($self,$command)=@_;if ($^O eq 'VMS'){require VMS::DCLsym;my$syms=VMS::DCLsym->new;return$command if scalar$syms->getsym(uc$command)}$self->SUPER::find_command($command)}sub _maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d _;my(@dirs)=('');my(@exts)=('',$Config{'exe_ext'},'.exe','.com');if ($file !~ m![/:>\]]!){for (my$i=0;defined$ENV{"DCL\$PATH;$i"};$i++){my$dir=$ENV{"DCL\$PATH;$i"};$dir .= ':' unless$dir =~ m%[\]:]$%;push(@dirs,$dir)}push(@dirs,'Sys$System:');for my$dir (@dirs){my$sysfile="$dir$file";for my$ext (@exts){return$file if -x "$sysfile$ext" &&!-d _}}}return}sub do_system {my ($self,@cmd)=@_;$self->log_verbose("@cmd\n");my$cmd=shift@cmd;my$args=$self->_quote_args(@cmd);return!system("$cmd $args")}sub oneliner {my$self=shift;my$oneliner=$self->SUPER::oneliner(@_);$oneliner =~ s/^\"\S+\"//;return "MCR $^X $oneliner"}sub rscan_dir {my ($self,$dir,$pattern)=@_;my$result=$self->SUPER::rscan_dir($dir,$pattern);for my$file (@$result){if (!_efs()&& ($file =~ m#/#)){$file =~ s/\.$//}}return$result}sub dist_dir {my$self=shift;my$dist_dir=$self->SUPER::dist_dir;$dist_dir =~ s/\./_/g unless _efs();return$dist_dir}sub man3page_name {my$self=shift;my$mpname=$self->SUPER::man3page_name(shift);my$sep=$self->manpage_separator;$mpname =~ s/^$sep//;return$mpname}sub expand_test_dir {my ($self,$dir)=@_;my@reldirs=$self->SUPER::expand_test_dir($dir);for my$eachdir (@reldirs){my ($v,$d,$f)=File::Spec->splitpath($eachdir);my$reldir=File::Spec->abs2rel(File::Spec->catpath($v,$d,''));$eachdir=File::Spec->catfile($reldir,$f)}return@reldirs}sub _detildefy {my ($self,$arg)=@_;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}sub find_perl_interpreter {return VMS::Filespec::vmsify($^X)}sub localize_file_path {my ($self,$path)=@_;$path=VMS::Filespec::vmsify($path);$path =~ s/\.\z//;return$path}sub localize_dir_path {my ($self,$path)=@_;return VMS::Filespec::vmspath($path)}sub ACTION_clean {my ($self)=@_;for my$item (map glob(VMS::Filespec::rmsexpand($_,'.;0')),$self->cleanup){$self->delete_filetree($item)}}my$use_feature;BEGIN {if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_feature=1}}sub _unix_rpt {my$unix_rpt;if ($use_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub _efs {my$efs;if ($use_feature){$efs=VMS::Feature::current("efs_charset")}else {my$env_efs=$ENV{'DECC$EFS_CHARSET'}|| '';$efs=$env_efs =~ /^[ET1]/i}return$efs}1;
MODULE_BUILD_PLATFORM_VMS

$fatpacked{"Module/Build/Platform/VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VOS';
  package Module::Build::Platform::VOS;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);1;
MODULE_BUILD_PLATFORM_VOS

$fatpacked{"Module/Build/Platform/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_WINDOWS';
  package Module::Build::Platform::Windows;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Config;use File::Basename;use File::Spec;use Module::Build::Base;our@ISA=qw(Module::Build::Base);sub manpage_separator {return '.'}sub have_forkpipe {0}sub _detildefy {my ($self,$value)=@_;$value =~ s,^~(?= [/\\] | $ ),$ENV{HOME},x if$ENV{HOME};return$value}sub ACTION_realclean {my ($self)=@_;$self->SUPER::ACTION_realclean();my$basename=basename($0);$basename =~ s/(?:\.bat)?$//i;if (lc$basename eq lc$self->build_script){if ($self->build_bat){$self->log_verbose("Deleting $basename.bat\n");my$full_progname=$0;$full_progname =~ s/(?:\.bat)?$/.bat/i;require Win32;my$null_arg=(Win32::IsWinNT())? '""' : '';my$cmd=qq(start $null_arg /min "\%comspec\%" /c del "$full_progname");open(my$fh,'>>',"$basename.bat")or die "Can't create $basename.bat: $!";print$fh $cmd;close$fh }else {$self->delete_filetree($self->build_script .'.bat')}}}sub make_executable {my$self=shift;$self->SUPER::make_executable(@_);for my$script (@_){if ($script =~ /\.(bat|cmd)$/){$self->SUPER::make_executable($script);next}else {my%opts=();if ($script eq $self->build_script){$opts{ntargs}=q(-x -S %0 --build_bat %*);$opts{otherargs}=q(-x -S "%0" --build_bat %1 %2 %3 %4 %5 %6 %7 %8 %9)}my$out=eval {$self->pl2bat(in=>$script,update=>1,%opts)};if ($@){$self->log_warn("WARNING: Unable to convert file '$script' to an executable script:\n$@")}else {$self->SUPER::make_executable($out)}}}}sub pl2bat {my$self=shift;my%opts=@_;$opts{ntargs}='-x -S %0 %*' unless exists$opts{ntargs};$opts{otherargs}='-x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9' unless exists$opts{otherargs};$opts{stripsuffix}='/\\.plx?/' unless exists$opts{stripsuffix};$opts{stripsuffix}=($opts{stripsuffix}=~ m{^/([^/]*[^/\$]|)\$?/?$} ? $1 : "\Q$opts{stripsuffix}\E");unless (exists$opts{out}){$opts{out}=$opts{in};$opts{out}=~ s/$opts{stripsuffix}$//oi;$opts{out}.= '.bat' unless$opts{in}=~ /\.bat$/i or $opts{in}=~ /^-$/}my$head=<<EOT;$head =~ s/^\s+//gm;my$headlines=2 + ($head =~ tr/\n/\n/);my$tail="\n__END__\n:endofperl\n";my$linedone=0;my$taildone=0;my$linenum=0;my$skiplines=0;my$start=$Config{startperl};$start="#!perl" unless$start =~ /^#!.*perl/;open(my$in,'<',"$opts{in}")or die "Can't open $opts{in}: $!";my@file=<$in>;close($in);for my$line (@file){$linenum++;if ($line =~ /^:endofperl\b/){if (!exists$opts{update}){warn "$opts{in} has already been converted to a batch file!\n";return}$taildone++}if (not $linedone and $line =~ /^#!.*perl/){if (exists$opts{update}){$skiplines=$linenum - 1;$line .= "#line ".(1+$headlines)."\n"}else {$line .= "#line ".($linenum+$headlines)."\n"}$linedone++}if ($line =~ /^#\s*line\b/ and $linenum==2 + $skiplines){$line=""}}open(my$out,'>',"$opts{out}")or die "Can't open $opts{out}: $!";print$out $head;print$out $start,($opts{usewarnings}? " -w" : ""),"\n#line ",($headlines+1),"\n" unless$linedone;print$out @file[$skiplines..$#file];print$out $tail unless$taildone;close($out);return$opts{out}}sub _quote_args {my ($self,@args)=@_;my@quoted;for (@args){if (/^[^\s*?!\$<>;|'"\[\]\{\}]+$/){push@quoted,$_}else {s/"/\\"/g;push@quoted,qq("$_")}}return join " ",@quoted}sub split_like_shell {(my$self,local $_)=@_;return @$_ if defined()&& ref()eq 'ARRAY';my@argv;return@argv unless defined()&& length();my$length=length;m/\G\s*/gc;ARGS: until (pos==$length){my$quote_mode;my$arg='';CHARS: until (pos==$length){if (m/\G((?:\\\\)+)(?=\\?(")?)/gc){if (defined $2){$arg .= '\\' x (length($1)/ 2)}else {$arg .= $1}}elsif (m/\G\\"/gc){$arg .= '"'}elsif (m/\G"/gc){if ($quote_mode && m/\G"/gc){$arg .= '"'}$quote_mode=!$quote_mode}elsif (!$quote_mode && m/\G\s+/gc){last}elsif (m/\G(.)/sgc){$arg .= $1}}push@argv,$arg}return@argv}sub do_system {my ($self,@cmd)=@_;my$cmd=$self->_quote_args(@cmd);my$status=system($cmd);if ($status and $! =~ /Argument list too long/i){my$env_entries='';for (sort keys%ENV){$env_entries .= "$_=>".length($ENV{$_})."; "}warn "'Argument list' was 'too long', env lengths are $env_entries"}return!$status}sub _maybe_command {my($self,$file)=@_;my@e=exists($ENV{'PATHEXT'})? split(/;/,$ENV{PATHEXT}): qw(.com .exe .bat .cmd);my$e='';for (@e){$e .= "\Q$_\E|"}chop$e;if ($file =~ /($e)$/i){return$file if -e $file}else {for (@e){return "$file$_" if -e "$file$_"}}return}1;
      \@rem = '--*-Perl-*--
      \@echo off
      if "%OS%" == "Windows_NT" goto WinNT
      perl $opts{otherargs}
      goto endofperl
      :WinNT
      perl $opts{ntargs}
      if NOT "%COMSPEC%" == "%SystemRoot%\\system32\\cmd.exe" goto endofperl
      if %errorlevel% == 9009 echo You do not have Perl in your PATH.
      if errorlevel 1 goto script_failed_so_exit_with_non_zero_val 2>nul
      goto endofperl
      \@rem ';
  EOT
MODULE_BUILD_PLATFORM_WINDOWS

$fatpacked{"Module/Build/Platform/aix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_AIX';
  package Module::Build::Platform::aix;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);1;
MODULE_BUILD_PLATFORM_AIX

$fatpacked{"Module/Build/Platform/cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_CYGWIN';
  package Module::Build::Platform::cygwin;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);sub manpage_separator {'.'}sub _maybe_command {my ($self,$file)=@_;if ($file =~ m{^/cygdrive/}i){require Module::Build::Platform::Windows;return Module::Build::Platform::Windows->_maybe_command($file)}return$self->SUPER::_maybe_command($file)}1;
MODULE_BUILD_PLATFORM_CYGWIN

$fatpacked{"Module/Build/Platform/darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DARWIN';
  package Module::Build::Platform::darwin;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);1;
MODULE_BUILD_PLATFORM_DARWIN

$fatpacked{"Module/Build/Platform/os2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_OS2';
  package Module::Build::Platform::os2;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);sub manpage_separator {'.'}sub have_forkpipe {0}sub _maybe_command {my($self,$file)=@_;$file =~ s,[/\\]+,/,g;return$file if -x $file &&!-d _;return "$file.exe" if -x "$file.exe" &&!-d _;return "$file.cmd" if -x "$file.cmd" &&!-d _;return}1;
MODULE_BUILD_PLATFORM_OS2

$fatpacked{"Module/Build/PodParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PODPARSER';
  package Module::Build::PodParser;use strict;use warnings;our$VERSION='0.03';$VERSION=eval$VERSION;sub new {my$package=shift;my$self;$self=bless {have_pod_parser=>0,@_},$package;unless ($self->{fh}){die "No 'file' or 'fh' parameter given" unless$self->{file};open($self->{fh},'<',$self->{file})or die "Couldn't open $self->{file}: $!"}return$self}sub parse_from_filehandle {my ($self,$fh)=@_;local $_;while (<$fh>){next unless /^=(?!cut)/ .. /^=cut/;last if ($self->{abstract})=/^ (?: [a-z_0-9:]+ | [BCIF] < [a-z_0-9:]+ > ) \s+ - \s+ (.*\S) /ix}my@author;while (<$fh>){next unless /^=head1\s+AUTHORS?/i ... /^=/;next if /^=/;push@author,$_ if /\@/}return unless@author;s/^\s+|\s+$//g foreach@author;$self->{author}=\@author;return}sub get_abstract {my$self=shift;return$self->{abstract}if defined$self->{abstract};$self->parse_from_filehandle($self->{fh});return$self->{abstract}}sub get_author {my$self=shift;return$self->{author}if defined$self->{author};$self->parse_from_filehandle($self->{fh});return$self->{author}|| []}
MODULE_BUILD_PODPARSER

$fatpacked{"Module/Build/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_TINY';
  package Module::Build::Tiny;$Module::Build::Tiny::VERSION='0.03';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=qw/Build Build_PL/;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/basename dirname/;use File::Find ();use File::Path qw/mkpath rmtree/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;use JSON::PP 2 qw/encode_json decode_json/;sub write_file {my ($filename,$content)=@_;open my$fh,'>',$filename or die "Could not open $filename: $!\n";print$fh $content}sub read_file {my ($filename,$mode)=@_;open my$fh,'<',$filename or die "Could not open $filename: $!\n";return do {local $/;<$fh>}}sub get_meta {my ($metafile)=grep {-e $_}qw/META.json META.yml/ or die "No META information provided\n";return CPAN::Meta->load_file($metafile)}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub process_xs {my ($source,$options)=@_;die "Can't build xs files under --pureperl-only\n" if$options->{'pureperl-only'};my (undef,@parts)=splitdir(dirname($source));push@parts,my$file_base=basename($source,'.xs');my$archdir=catdir(qw/blib arch auto/,@parts);my$tempdir='temp';my$c_file=catfile($tempdir,"$file_base.c");require ExtUtils::ParseXS;mkpath($tempdir,$options->{verbose},oct '755');ExtUtils::ParseXS::process_file(filename=>$source,prototypes=>0,output=>$c_file);my$version=$options->{meta}->version;require ExtUtils::CBuilder;my$builder=ExtUtils::CBuilder->new(config=>$options->{config}->values_set);my$ob_file=$builder->compile(source=>$c_file,defines=>{VERSION=>qq/"$version"/,XS_VERSION=>qq/"$version"/ },include_dirs=>[curdir,dirname($source)]);require DynaLoader;my$mod2fname=defined&DynaLoader::mod2fname ? \&DynaLoader::mod2fname : sub {return $_[0][-1]};mkpath($archdir,$options->{verbose},oct '755')unless -d $archdir;my$lib_file=catfile($archdir,$mod2fname->(\@parts).'.' .$options->{config}->get('dlext'));return$builder->link(objects=>$ob_file,lib_file=>$lib_file,module_name=>join '::',@parts)}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;for my$pl_file (find(qr/\.PL$/,'lib')){(my$pm=$pl_file)=~ s/\.PL$//;system $^X,$pl_file,$pm and die "$pl_file returned $?\n"}my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared},catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});process_xs($_,\%opt)for find(qr/.xs$/,'lib');if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and exit 1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/})},clean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp/},realclean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp Build _build_params MYMETA.yml MYMETA.json/},);sub Build {my$action=@ARGV && $ARGV[0]=~ /\A\w+\z/ ? shift@ARGV : 'build';die "No such action '$action'\n" if not $actions{$action};my($env,$bargv)=@{decode_json(read_file('_build_params'))};my%opt;GetOptionsFromArray($_,\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($env,$bargv,\@ARGV);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),get_meta());$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub Build_PL {my$meta=get_meta();printf "Creating new 'Build' script for '%s' version '%s'\n",$meta->name,$meta->version;my$dir=$meta->name eq 'Module-Build-Tiny' ? "use lib 'lib';" : '';write_file('Build',"#!perl\n$dir\nuse Module::Build::Tiny;\nBuild();\n");make_executable('Build');my@env=defined$ENV{PERL_MB_OPT}? split_like_shell($ENV{PERL_MB_OPT}): ();write_file('_build_params',encode_json([\@env,\@ARGV ]));$meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MODULE_BUILD_TINY

$fatpacked{"Test/Fatal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_FATAL';
  use strict;use warnings;package Test::Fatal;$Test::Fatal::VERSION='0.03';use Carp ();use Try::Tiny 0.07;use Exporter 5.57 'import';our@EXPORT=qw(exception);our@EXPORT_OK=qw(exception success dies_ok lives_ok);our ($REAL_TBL,$REAL_CALCULATED_TBL)=(1,1);sub exception (&) {my$code=shift;return try {my$incremented=$Test::Builder::Level - $REAL_CALCULATED_TBL;local$Test::Builder::Level=$REAL_CALCULATED_TBL;if ($incremented){$Test::Builder::Level += 5;for my$i (1..$incremented){my$caller=caller($Test::Builder::Level - 2);if ($caller eq __PACKAGE__){$Test::Builder::Level=$Test::Builder::Level + 5}else {$Test::Builder::Level=$Test::Builder::Level + 1}}}local$REAL_CALCULATED_TBL=$Test::Builder::Level;$code->();return undef}catch {return $_ if $_;my$problem=defined $_ ? 'false' : 'undef';Carp::confess("$problem exception caught by Test::Fatal::exception")}}sub success (&;@) {my$code=shift;return finally(sub {return if @_;$code->()},@_)}my$Tester;sub dies_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||= Test::Builder->new;my$ok=$Tester->ok(exception(\&$code),$name);$ok or $Tester->diag("expected an exception but none was raised");return$ok}sub lives_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||= Test::Builder->new;my$ok=$Tester->ok(!exception(\&$code),$name);$ok or $Tester->diag("expected return but an exception was raised");return$ok}1;
TEST_FATAL

$fatpacked{"Test/TempDir/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TEMPDIR_TINY';
  use 5.006002;use strict;use warnings;package Test::TempDir::Tiny;our$VERSION='0.03';use Exporter 5.57 qw/import/;our@EXPORT=qw/tempdir in_tempdir/;use Carp qw/confess/;use Cwd qw/abs_path/;use Errno qw/EEXIST ENOENT/;{no warnings 'numeric';use File::Path 2.01 qw/remove_tree/}use File::Spec::Functions qw/catdir/;use File::Temp;my ($ROOT_DIR,$TEST_DIR,%COUNTER);my ($ORIGINAL_PID,$ORIGINAL_CWD,$TRIES,$DELAY,$SYSTEM_TEMP)=($$,abs_path("."),100,50 / 1000,0);sub _untaint {my$thing=shift;($thing)=$thing =~ /^(.*)$/;return$thing}sub tempdir {my$label=defined($_[0])? $_[0]: 'default';$label =~ tr{a-zA-Z0-9_-}{_}cs;_init()unless$ROOT_DIR && $TEST_DIR;my$suffix=++$COUNTER{$label};my$subdir=catdir($TEST_DIR,"${label}_${suffix}");mkdir _untaint($subdir)or confess("Couldn't create $subdir: $!");return$subdir}sub in_tempdir {my ($label,$code)=@_;my$wantarray=wantarray;my$cwd=abs_path(".");my$tempdir=tempdir($label);chdir$tempdir or die "Can't chdir to '$tempdir'";my (@ret);my$ok=eval {$code->($tempdir);1};my$err=$@;chdir$cwd or chdir "/" or die "Can't chdir to either '$cwd' or '/'";confess($err || "error from eval was lost")if!$ok;return}sub _inside_t_dir {-d "../t" && abs_path(".")eq abs_path("../t")}sub _init {my$DEFAULT_ROOT=catdir($ORIGINAL_CWD,"tmp");if (-d 't' && (-w $DEFAULT_ROOT || -w '.')){$ROOT_DIR=$DEFAULT_ROOT}elsif (_inside_t_dir()&& (-w '../$DEFAULT_ROOT' || -w '..')){$ROOT_DIR=catdir($ORIGINAL_CWD,"..","tmp")}else {$ROOT_DIR=File::Temp::tempdir(TMPDIR=>1,CLEANUP=>1);$SYSTEM_TEMP=1}(my$dirname=$0)=~ tr{:\\/.}{_};$TEST_DIR=catdir($ROOT_DIR,$dirname);if (-d $TEST_DIR){remove_tree(_untaint($TEST_DIR),{safe=>0,keep_root=>1 });return}for my$n (1 .. $TRIES){if (!mkdir(_untaint($ROOT_DIR))){confess("Couldn't create $ROOT_DIR: $!")unless $!==EEXIST}$ROOT_DIR=abs_path($ROOT_DIR);if (mkdir _untaint($TEST_DIR)){$TEST_DIR=abs_path($TEST_DIR);return}if ($!!=ENOENT){confess("Couldn't create $TEST_DIR: $!")}if (-e $ROOT_DIR &&!-d _){confess("$ROOT_DIR is not a directory")}select(undef,undef,undef,$DELAY)if$n < $TRIES}warn "Couldn't create $TEST_DIR in $TRIES tries.\n" ."Using a regular tempdir instead.\n";$TEST_DIR=File::Temp::tempdir(TMPDIR=>1,CLEANUP=>1);return}sub _cleanup {return if$ENV{PERL_TEST_TEMPDIR_TINY_NOCLEANUP};if ($ROOT_DIR && -d $ROOT_DIR){if ($SYSTEM_TEMP or not $?){chdir _untaint($ORIGINAL_CWD)or chdir "/" or warn "Can't chdir to '$ORIGINAL_CWD' or '/'. Cleanup might fail.";remove_tree(_untaint($TEST_DIR),{safe=>0 })if -d $TEST_DIR}rmdir _untaint($ROOT_DIR)unless -l $ROOT_DIR}}sub _root_dir {return$ROOT_DIR}END {if ($$==$ORIGINAL_PID){if ($] lt "5.008000"){*Test::TempDir::Tiny::_CLEANER::DESTROY=\&_cleanup;*blob=bless({},'Test::TempDir::Tiny::_CLEANER')}else {require B;push @{B::end_av()->object_2svref},\&_cleanup}}}1;
TEST_TEMPDIR_TINY

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.03';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}my$caller=caller;_subname("${caller}::try {...} "=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map {Try::Tiny::ScopeGuard->_new($_)}@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;my$caller=caller;_subname("${caller}::catch {...} "=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;my$caller=caller;_subname("${caller}::finally {...} "=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"Win32/DBIODBC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WIN32_DBIODBC';
  package Win32::ODBC;use strict;use DBI;$INC{'Win32/ODBC.pm'}=$INC{'Win32/DBIODBC.pm'}|| 1;sub new {shift;my$connect_line=shift;my$temp_connect_line;$connect_line=~/DSN=\w+/;$temp_connect_line="$&;";if ($connect_line=~/UID=\w?/){$temp_connect_line.="$&;"}else {$temp_connect_line.="UID=;"};if ($connect_line=~/PWD=\w?/){$temp_connect_line.="$&;"}else {$temp_connect_line.="PWD=;"};$connect_line=$temp_connect_line;my$self={};$_=$connect_line;/^(DSN=)(.*)(;UID=)(.*)(;PWD=)(.*)(;)$/;$self->{ODBC_DSN}=$2;$self->{ODBC_UID}=$4;$self->{ODBC_PWD}=$6;$self->{DBI_DBNAME}=$self->{ODBC_DSN};$self->{DBI_USER}=$self->{ODBC_UID};$self->{DBI_PASSWORD}=$self->{ODBC_PWD};$self->{DBI_DBD}='ODBC';$self->{'DBI_DBH'}=DBI->connect($self->{'DBI_DBNAME'},$self->{'DBI_USER'},$self->{'DBI_PASSWORD'},$self->{'DBI_DBD'});warn "Error($DBI::err) : $DBI::errstr\n" if!$self->{'DBI_DBH'};bless$self}sub Sql {my$self=shift;my$SQL_statment=shift;$self->{'DBI_SQL_STATMENT'}=$SQL_statment;my$dbh=$self->{'DBI_DBH'};my$sth=$dbh->prepare("$SQL_statment");$self->{'DBI_STH'}=$sth;if ($sth){$sth->execute()}$self->{DBI_ERR}=$DBI::err;$self->{DBI_ERRSTR}=$DBI::errstr;if ($sth){$self->{'DBI_NAME'}=$sth->{NAME}}return ($self->{'DBI_ERR'})?1:undef}sub FetchRow {my$self=shift;my$sth=$self->{'DBI_STH'};if ($sth){my@row=$sth->fetchrow_array;$self->{'DBI_ROW'}=\@row;if (scalar(@row)>0){return 1}}return undef}sub Data {my$self=shift;my@array=@{$self->{'DBI_ROW'}};for my$element (@array){$element=~s/(\s*$)//};return (wantarray())?@array:join('',@array)};sub DataHash {my$self=shift;my$p_name=$self->{'DBI_NAME'};my$p_row=$self->{'DBI_ROW'};my@name=@$p_name;my@row=@$p_row;my%DataHash;while (@name){my$name=shift(@name);my$value=shift(@row);$name=~s/(\s*$)//;$value=~s/(\s*$)//;$DataHash{$name}=$value};return%DataHash}sub Error {my$self=shift;if ($self->{'DBI_ERR'}ne ''){$self->{'DBI_ERRSTR'}}}sub Close {my$self=shift;my$dbh=$self->{'DBI_DBH'};$dbh->disconnect}1;
WIN32_DBIODBC

$fatpacked{"boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BOOLEAN';
  use strict;use warnings;package boolean;our$VERSION='0.03';my ($true,$false);use overload '""'=>sub {${$_[0]}},'!'=>sub {${$_[0]}? $false : $true},fallback=>1;use base 'Exporter';@boolean::EXPORT=qw(true false boolean);@boolean::EXPORT_OK=qw(isTrue isFalse isBoolean);%boolean::EXPORT_TAGS=(all=>[@boolean::EXPORT,@boolean::EXPORT_OK],test=>[qw(isTrue isFalse isBoolean)],);sub import {my@options=grep $_ ne '-truth',@_;$_[0]->truth if@options!=@_;@_=@options;goto&Exporter::import}my ($true_val,$false_val,$bool_vals);BEGIN {my$t=1;my$f=0;$true=do {bless \$t,'boolean'};$false=do {bless \$f,'boolean'};$true_val=overload::StrVal($true);$false_val=overload::StrVal($false);$bool_vals={$true_val=>1,$false_val=>1}}sub CLONE {$true_val=overload::StrVal($true);$false_val=overload::StrVal($false);$bool_vals={$true_val=>1,$false_val=>1}}sub true() {$true}sub false() {$false}sub boolean($) {die "Not enough arguments for boolean::boolean" if scalar(@_)==0;die "Too many arguments for boolean::boolean" if scalar(@_)> 1;return not(defined $_[0])? false : "$_[0]" ? $true : $false}sub isTrue($) {not(defined $_[0])? false : (overload::StrVal($_[0])eq $true_val)? true : false}sub isFalse($) {not(defined $_[0])? false : (overload::StrVal($_[0])eq $false_val)? true : false}sub isBoolean($) {not(defined $_[0])? false : (exists$bool_vals->{overload::StrVal($_[0])})? true : false}sub truth {die "-truth not supported on Perl 5.22 or later" if $] >= 5.021005;&Internals::SvREADONLY(\!!0,0);&Internals::SvREADONLY(\!!1,0);${\!!0}=$false;${\!!1}=$true;&Internals::SvREADONLY(\!!0,1);&Internals::SvREADONLY(\!!1,1)}sub TO_JSON {${$_[0]}? \1 : \0}1;
BOOLEAN

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use Carp qw(croak);
use Docopt;
use App::mimi;

my $opts = docopt();

my $command;
for (qw(check setup migrate fix set)) {
    if ($opts->{$_}) {
        $command = $_;
        last;
    }
}

App::mimi->new(
    dsn       => $opts->{'--dsn'},
    schema    => $opts->{'--schema'},
    dry_run   => $opts->{'--dry-run'},
    verbose   => $opts->{'--verbose'},
    migration => $opts->{'<migration>'}
)->$command;

__END__

=pod

=head1 NAME

mimi - dbi migrations

=head1 SYNOPSIS

  mimi check   --dsn=<dsn>
  mimi migrate --dsn=<dsn> --schema=<directory> [--verbose] [--dry-run]
  mimi setup   --dsn=<dsn> [--verbose] [--dry-run]
  mimi fix     --dsn=<dsn> [--verbose] [--dry-run]
  mimi set     --dsn=<dsn> <migration> [--verbose] [--dry-run]
  mimi -h | --help

  --dsn=<dsn>           DBI dsn string, 'dbi:SQLite:database.db' for example
  --schema=<directory>  Directory with migrations
  --dry-run             Do nothing, just show what's to be done
  --verbose             Be verbose
  -h --help             Show this screen.

=head1 DESCRIPTION

This is a migration script for small home projects. Despite of being small it's
still robust. This means that all the precautions are made to not to corrupt
your data.

=head2 Safety first

Every command has C<verbose> and C<dry-run> flags. Thus it is easy to check
first what's going to happen.

=head2 Check

    mimi check --dsn 'dbi:SQLite:database.db'

Check what's going on. Are migrations installed? What is the latest migration? Was there an error?

=head2 Setupping your database

    mimi setup --dsn 'dbi:SQLite:database.db'

This creates C<mimi> table in your database. This table is used as a journal for
migrations.

=head2 Migrations

    mimi migrate --dsn 'dbi:SQLite:database.db' --schema sql_files/

This will search C<sql_files> for C<*.sql> files, parse their names that usually
look like C<01add_column.sql>, C<02drop_table.sql> and so on. Then it will try
to find the last migration and run everything with a bigger number.

=head2 Failures and fixes

Failures do occur. Like you made a mistake in your migration (of course you
should run them on a local machine first!). C<mimi> will die but remember that
last migration was with error and won't let you run next migrations dying with:

    Error: Migrations are dirty. Last error was in migration 1:

        DBD::SQLite::db do failed: near "CREAT": syntax error

    After fixing the problem run <fix> command

After fixing the stuff, you either can C<fix> or C<set> the current migration
number manually:

    mimi fix --dsn '...'
    mimi set --dsn '...' 123

=head2 Additional checks

You will get descriptive errors when trying to do unexpected stuff, like running
migrations on a fresh database or supplying a directory without migration files.

=cut
